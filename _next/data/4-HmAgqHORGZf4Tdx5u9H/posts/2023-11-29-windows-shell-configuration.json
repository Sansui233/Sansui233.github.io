{"pageProps":{"meta":{"title":"Windows 命令行相关配置","date":"2023-11-29 12:07","tags":["Windows"],"categories":"工具","description":null,"keywords":"Windows命令行, Windows调整，Windows设置, powershell"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"常用-shell\",\n      children: \"常用 shell\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一直以来 windows 的命令行方案都很多，个人感觉都有不太好用的点，怎么配置也是仁者见仁智者见智的一个事情。先总结一下常用shell 方案\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"powershell\"\n        }), \" 官方shell，各种工具库支持最全，缺点自带的命令太长，以至于完全没有日常使用的想法。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"msys2\"\n        }), \" windows 上的类 unix 环境，基于现代 Cygwin (POSIX兼容层) 和 MinGW-w64（工具包）。确实像 unix，一般命令可以无缝迁移。缺点是兼容性，需要手动配置很多东西，比如是否继承 windows 环境变量，不继承的话不想维护两份环境，继承了又容易冲突。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"git bash\"\n        }), \" msys2 阉割版，无包管理，多了 git。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"wsl\"\n        }), \" 完全的 Linux 子系统，但太占内存。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"方案选择\",\n      children: \"方案选择\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我需求\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"常用命令必须是类 unix 命令\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"有包管理器，各类命令行工具配置友好且兼容性不错。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"不要太占内存\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"结果发现这就是经典的三圈相交，没有任何一个常用方案能满足以上要求。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最后，我决定用 powershell。除了第一条外都满足。后面两条属于难以解决的硬伤，而第一条可以编写脚本，将常用的命令模拟。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"powershell-配置流程\",\n      children: \"powershell 配置流程\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"包含工具包、终端美化。\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Install the latest Powershell Core\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://gitforwindows.org/\",\n          children: \"git-bash\"\n        }), \" for basic bash and git tools\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701?hl=zh-cn&gl=cn&rtc=1\",\n          children: \"Windows Terminal\"\n        }), \" and open Powershell\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://github.com/PowerShell/PSReadLine\",\n          children: \"PSReadLine\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://github.com/dahlbyk/posh-git\",\n          children: \"posh-git\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://ohmyposh.dev/\",\n          children: \"oh-my-posh\"\n        }), \" for showing extra info in term.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://github.com/gerardog/gsudo\",\n          children: \"gsudo\"\n        }), \" for softlink\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Install \", _jsx(_components.a, {\n          href: \"https://eza.rocks/\",\n          children: \"eza\"\n        }), \" for listing\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"open \", _jsx(_components.code, {\n          children: \"$PROFILE\"\n        }), \" in powershell, append the contents of \", _jsx(_components.a, {\n          href: \"https://gist.github.com/Sansui233/0451b8f7c354d600c4efa74fc284d39c#file-microsoft-powershell_profile-ps1\",\n          children: _jsx(_components.strong, {\n            children: \"Microsoft.PowerShell_profile.ps1\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"大致介绍一下用途。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"git-bash，一系列类 unix 工具，git 一类的\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Windows Terminal，微软的终端。我拒绝终端用 electron 去套的……\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PSReadLine，改变一系列 powershell 的行为。比如复制粘贴的快捷键。可惜在 vscode 里会没用，只能右键粘贴。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"posh-git，显示 git 的状态\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"oh-my-posh，美化。具体主题可能需要会自己改一下，要么丑，要么不支持提示 conda 环境或者 npm 环境。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"gsudo，提权，类似 unix 的 sudo。可能运行时会被杀软报毒，需要加入信任区。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"eza，2024年了，终于有了一个像样的 ls 替代……\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"powershell 的用户配置文件输入 \", _jsx(_components.code, {\n        children: \"$PROFILE\"\n      }), \" 就能找到。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我的配置文件上传到了 \", _jsx(_components.a, {\n        href: \"https://gist.github.com/Sansui233/0451b8f7c354d600c4efa74fc284d39c#file-microsoft-powershell_profile-ps1\",\n        children: _jsx(_components.strong, {\n          children: \"Microsoft.PowerShell_profile.ps1\"\n        })\n      }), \"。需要挂代理打开。配置文件包含 \", _jsx(_components.code, {\n        children: \"ls\"\n      }), \" \", _jsx(_components.code, {\n        children: \"ln\"\n      }), \" \", _jsx(_components.code, {\n        children: \"open\"\n      }), \" \", _jsx(_components.code, {\n        children: \"grep\"\n      }), \" \", _jsx(_components.code, {\n        children: \"which\"\n      }), \" 等命令模拟。powershell 的缩写默认支持了 \", _jsx(_components.code, {\n        children: \"mv\"\n      }), \" \", _jsx(_components.code, {\n        children: \"cat\"\n      }), \" \", _jsx(_components.code, {\n        children: \"rm\"\n      }), \" 等命令，配合起来日常基本够用。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"终端代理\",\n      children: \"终端代理\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我在配置文件中设置了\", _jsx(_components.code, {\n        children: \"proxy\"\n      }), \"和\", _jsx(_components.code, {\n        children: \"unproxy\"\n      }), \"函数，以快速设置与取消终端的代理连接。自己改下端口就能用。因为我自己习惯上不开系统代理，都是软件内的 http 连接。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-powershell\",\n        children: \"# Proxy Togglers\\nfunction proxy {\\n\\t$portInUse = netstat -ano | findstr \\\"LISTENING\\\" | findstr \\\"7890\\\"\\n\\t$portInUse2 = netstat -ano | findstr \\\"LISTENING\\\" | findstr \\\"10808\\\"\\n\\tif ($portInUse -ne $null) {\\n\\t\\t$env:HTTP_PROXY = \\\"socks5://127.0.0.1:7890\\\"\\n\\t\\t$env:HTTPS_PROXY = \\\"socks5://127.0.0.1:7890\\\"\\n\\t\\tWrite-Host \\\"Proxy set to socks port 7890\\\"\\n\\t} elseif ($portInUse2 -ne $null) {\\n\\t\\t$env:HTTP_PROXY = \\\"socks5://127.0.0.1:10808\\\"\\n\\t\\t$env:HTTPS_PROXY = \\\"socks5://127.0.0.1:10808\\\"\\n\\t\\tWrite-Host \\\"Proxy set to socks port 10808\\\"\\n\\t} else {\\n\\t\\t$env:HTTP_PROXY = \\\"socks5://127.0.0.1:1080\\\"\\n\\t\\t$env:HTTPS_PROXY = \\\"socks5://127.0.0.1:1080\\\"\\n\\t\\tWrite-Host \\\"Proxy set to socks port \\\"\\n\\t}\\n}\\nfunction unproxy {\\n\\t$env:HTTP_PROXY = \\\"\\\"\\n\\t$env:HTTPS_PROXY = \\\"\\\"\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"其他常用工具\",\n      children: \"其他常用工具\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"winget：自带的包管理器，命令行工具都是这个装的。部分用的 scoop，非常少。还有的直接用的官网 setup。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"nvim：命令行编辑器，vim 的替代品。我用的是发行版 AstroNvim。之前也有自己折腾插件，太懒得维护了，算了。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"nodejs：JS 环境，nvim 的插件要用，开发也要用\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"zoxide：快速跳转目录。最有用的功能没有之一。类似 unix 的 autojump\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Terminal-Icons：ls 命令加 icon，还能解决 ls 不高亮的问题。但是，颜色很丑。但是，我不也想再配置了，配置真的心好累。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"ripgrep：类似 grep 的用法。我在模拟 grep 命令时只是单纯替换成了 findstr，真的 grep 建议用 ripgrep (rg) 替代。nvim 的 telescope 一些插件也会用到。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"安装脚本汇总：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-powershell\",\n        children: \"winget install conda\\n\\nwinget install neovim\\ngit clone --depth 1 https://github.com/AstroNvim/AstroNvim ~/.config/nvim\\n\\nwinget install gerardog.gsudo\\nwinget install OpenJS.NodeJSLTS\\nInstall-Module -Name Terminal-Icons -Repository PSGallery; Import-Module -Name Terminal-Icons\\n# z-jump\\nwinget install zoxide # z-jump, see https://github.com/ajeetdsouza/zoxide\\nwinget install BurntSushi.ripgrep.MSVC # grep 的完全替代品\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"zsh\",\n      children: \"ZSH\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"有关 zsh 相关的配置，我放在了 \", _jsx(_components.a, {\n        href: \"https://sansui233.github.io/posts/windows-zsh-conf\",\n        children: \"Windows 命令行相关配置之 msys2+zsh+zi\"\n      }), \" 。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":"## 常用 shell  一直以来 windows 的命令行方案都很多，个人感觉都有不太好用的点，怎么配置也是仁者见仁智者见智的一个事情。先总结一下常用shell 方案  - `powershell` 官方shell，各种工具库支持最全，缺点自带的命令太长，以至于完全没有日常使用的想法。","prevPost":{"title":"白嫖怪的经验","link":"/posts/白嫖怪的经验"},"nextPost":{"title":"大概是关于五笔打字更慢的一点碎碎念？","link":"/posts/thoughts-about-wubi-im"},"headings":[{"title":"常用 shell","rank":1,"id":"常用-shell"},{"title":"方案选择","rank":1,"id":"方案选择"},{"title":"powershell 配置流程","rank":2,"id":"powershell-配置流程"},{"title":"终端代理","rank":1,"id":"终端代理"},{"title":"其他常用工具","rank":1,"id":"其他常用工具"},{"title":"ZSH","rank":1,"id":"zsh"}]},"__N_SSG":true}