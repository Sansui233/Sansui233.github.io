{"pageProps":{"meta":{"title":"记一道题排列组合题解","date":"2022-11-18 08:00","tags":["数学"],"categories":"学习","description":"难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。","keywords":"数学, 算法"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    blockquote: \"blockquote\",\n    h2: \"h2\",\n    hr: \"hr\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"题目\",\n      children: \"题目\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg\",\n      alt: \"8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"题来自 tg 里玩 ai 的小水群，很多人第一眼是想全排列剪枝……阶乘的复杂度得瞎了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不过看到求方案数，帮人面试时被动态规划虐过的直觉在告诉我，凡事让写方案数不枚举方案的，很可能能写动态规划。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"于是从动态规划的方面想去了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"关于素数\",\n      children: \"关于素数\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个题有一个非常奇怪的地方，就是要和为素数。我不禁想，和为素数是对解题方法有什么加成吗？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（其实因为我最初看走眼了，以为是子集里所有数为素数，且和为素数，还以为素数和有什么定理）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"素数的特殊点在于乘法分解，至于加法上与一般数有什么不同，以凡人视角未曾听说。并且这题还并不限于子集中取用什么数。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"综上，和为素数对解题方法不仅没有什么加成，反而是多了个如何判断一个数是不是素数的问题。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"至于如何判断素数，在 Leetcode 204，略，也没什么很省时间的方法，就是筛，不算简单。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"子集动态规划\",\n      children: \"子集动态规划\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然素数对于解题思路没有加成，就按一般数处理，很快写出了下面的思路：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一维dp中存下和为当前数的方案数\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"遍历更新dp，把新数n拆分成已有数+余数，按余数从大到小（已有数从小到大），把所有已有数的拆分方案加起来，再+1，即可得到当前数的子集数。\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"需要注意的是，为了保证不重复，也就是保证子集序列递增，已有数不会超过n/2（余数不会小于n/2）\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"更新dp时，也要计算新数n是否为质数，是的话把其子集数加入最终结果（算质数见leetcode 204）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"由于取值范围1-2000，最大和为1000^2，100w，也是dp要遍历的次数。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面的图是在解释什么叫“遍历但不用枚举子集”时写的，也是上述dp的步骤。\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/2E06B8C3-1DF4-492D-A009-55F4D7A041CE.jpeg\",\n      alt: \"img\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"发题人仔细看了，并且手动枚举了10个数后，指出，我这会漏掉10=1+2+3+4。（后面自己发现这样还漏了145和235，后面越漏越多）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"仔细回顾了一下之前的思路，发现我的问题出在递增的判断上。我当时认为保证递增序列，只要保证已有数小于余数就行，所以余数>2/n。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但不是的，比如n=10时，已有数为6，余数为4，6拆分为1+2+3就行，1234还是序列递增的。6拆分为2+4、1+5就不行。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"归根结底就是我只把余数算了较大的一半，因为余数较大的一半肯定能保证序列递增。如果不想漏情况，余数要全部遍历，但怎么保证序列递增呢？比如6+4，如何只拆到1+2+3+4，不算1+5+4和2+4+4呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"于是更新了一下递增的条件：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"已有数的拆分的子序列最大数小于余数，则拆分方案合法\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再更新dp时余数范围：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"余数从n取到1，分别计算子集数后再sum。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这样可以保证思路没问题了，但这个“已有数的拆分的子序列最大数小于余数”，明显当前dp只统计了子集数，根本不知道各个子集中具体最大数的情况。因此，我改成了个二维dp，含义和过程如下图：\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/6D139DD5-A95F-4467-BA58-3B5E61D9207D.jpeg\",\n      alt: \"img\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"简单总结一下，整个问题我简化到了求“和为 n 的子集数”，并利用二维动规从 1 求到 n。 n 是不是素数单独算的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"并且发现，其实更新每一行时，都是把上一行为止的方阵以“/”方向45度拆开，mask掉右边部分，按行求和后，从右往左地写进下一行，还能用gpu加个速（不是）。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"另一种解法\",\n      children: \"另一种解法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"发题人在看了我的新方案后，说在上面看到了类似杨辉三角之类的东西。并且得出了另一个方案：\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"和为 n 的子集组合数，为多项式 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1) 的 x^n 项系数\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://raw.githubusercontent.com/NamiLing/upic/master/uPic/IMG_5434.JPG\",\n      alt: \"多项式展开\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（我本来没理解，是死缠烂打地问才知道他在说什么）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"仔细一想真的是这个理， x^n 对应的多项式系数就是排列组合到 n 的所有方案数了，也天然没有重复用数的问题。怎么想到的，神。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以现在问题是：怎么求 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1)的多项式系数。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（当时已经不想动脑了，又是死缠烂打地问）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其实迭代就能算，因为 F(n) = x^n • F(n-1) + F(n-1)，对应系数直接挪位置后复制粘贴再相加就好了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"空间复杂度\",\n      children: \"空间复杂度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这里有点难以定义 n 具体指哪个，默认 n = 2000 。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我的解法是要 1000^4 的空间去存方案数，矩阵中有很多地方是空的，有点浪费。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"后者的解法要1000^2 空间去存多项式系数。省很多。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"时间复杂度\",\n      children: \"时间复杂度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以我的动规方法，时间复杂度为在 O(n^6)，准确说是O(n^2(n^2+1)(2n^2+1)/6)，因为要算到 (n/2)^2，且内部还有已填矩阵按行遍历。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以后者的的解法，时间复杂度为 O(n^3)，因为多项式的 n 需要到 (n/2)^2。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"线性筛到 (n/2)^2 的素数, 时间复杂度为 O(n^2)。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"总得来说还是数学好的强啊。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外还有一个人非让我看完一个 30 分钟的高斯素数判断法，结果我一直在想 dp，搞得他怨念深重 hh\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":" 难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。  ## 题目  ![8B414946-F4D4-479C-9092-9AEA8EC26FA3.jpeg](https://raw.githubusercontent.com/NamiLin","prevPost":{"title":"部署饥荒联机版Linux服务器","link":"/posts/dontstarvetogether-linux-server"},"nextPost":{"title":"理解 Rust 闭包与环境变量所有权","link":"/posts/rust-closure-and-ownership"},"headings":[{"title":"题目","rank":1,"id":"题目"},{"title":"关于素数","rank":1,"id":"关于素数"},{"title":"子集动态规划","rank":1,"id":"子集动态规划"},{"title":"另一种解法","rank":1,"id":"另一种解法"},{"title":"空间复杂度","rank":1,"id":"空间复杂度"},{"title":"时间复杂度","rank":1,"id":"时间复杂度"}]},"__N_SSG":true}