{"pageProps":{"meta":{"title":"uv 管理 conda 项目依赖","date":"2025-07-25 04:12","tags":["python"],"categories":"学习","description":"沐神都解决不了的……","keywords":"python, 包管理, uv"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    del: \"del\",\n    h2: \"h2\",\n    h3: \"h3\",\n    img: \"img\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"conda-的问题\",\n      children: \"conda 的问题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"https://img-cf.sansui233.com/imgs/2025/07/202507242029977.webp\",\n      alt: \"沐神都解决不了的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"conda 的问题在于\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"requirements.txt \", _jsx(_components.strong, {\n          children: \"全手写\"\n        }), \"！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python 发了论文和仓库就跑的项目是很多的。安装一个旧项目导致之前安装 numpy 被卸载，然后整个项目就垮掉。这种情况相当之多，又解决两个小时的依赖问题。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"（至少我不愿意看到）电脑里十几个相同版本的 torch 和 cuda。当时的硬盘还只有 256G，多装几个 torch 无法接受，嗯……\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"直到现在都还是这样的，大家主打一个能跑完实验就行。包的更新是激进的，包管理是落后的。在几年前有人说用 PDM，后面有 poetry。这两是不用再手写 \", _jsx(_components.code, {\n        children: \"requirements.txt\"\n      }), \" 了，依赖也会自动 resolve 不会覆盖来覆盖去的了。但还是会装十几个 torch。直到 uv 开始用硬链接进行包管理。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"uv-之于-conda-项目\",\n      children: \"uv 之于 conda 项目\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"uv 接管 python 界的依赖管理按理说已经没什么问题。但实际情况是，很多项目还是在用 conda。除非哪天 torch 和 HF 都把 uv 设置为首推，否则就得一直与  conda 存在的问题战斗。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"1.-不提供-venv-的项目\",\n      children: \"1. 不提供 venv 的项目\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"用于研究的项目一般都是不提供的打包好的环境的，主要是太大了，每个人设备情况也不一样。所以下载后第一件事是\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-sh\",\n        children: \"uv venv\\r\\n./.venv/Script/activate\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果这个项目不再更新了，或者是打算迁移到 uv，可以直接使用 uv 的方式管理依赖。uv 会自动维护 \", _jsx(_components.code, {\n        children: \"pyproject.toml\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"uv.lock\"\n      }), \" 文件。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"uv add -r requirements.in -c requirements.txt\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果这个项目，他还在更新，你时不时就得去拉一下分支。这时候最好用 \", _jsx(_components.code, {\n        children: \"uv pip\"\n      }), \" 。至于依赖混乱问题，听天由命吧。\", _jsx(_components.del, {\n        children: \"跑得起来就得了\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"uv pip install -r requirement.txt\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"2.-提供-venv-的项目\",\n      children: \"2. 提供 venv 的项目\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"提供 venv 的项目通常是给人用的，b 站的整合包一大堆。这种已经配好环境的项目也意味着你最好只用 pip。通常还是非常原始地调用 pip\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"./.venv/python -m pip install xxx\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"……等于说又开始了安装十几份 torch 的依赖管理模式。用 uv 是可以重复利用缓存的。这个时候 uv 的问题在于无法接管 python 环境，需要设置一下环境变量：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-sh\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"export\"\n        }), \" UV_PYTHON=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"./.venv/python\\\"\"\n        }), \"\\r\\nuv pip list\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后就可以利用 uv 的缓存了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"当然，依赖混乱问题使用 \", _jsx(_components.code, {\n        children: \"uv pip\"\n      }), \" 是无法避免的。这对于发行版也是一种麻烦。因为发行版的环境全给你配好了，但有的项目设计了插件系统，插件系统又需要装插件的 requirement.txt，安一个许久没更新的插件让主项目废掉的情况也不是不可能……\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果让插件作者指定的兼容版本？只靠规范做不到，必须像MC那样检查版本号，不更新版本号就不放行。这样就算不更新代码了，也得倒逼作者每个版本都进行一次（至少是与主项目的）依赖兼容性测试。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我觉得以当前 python 的运行方式，不 lock 子依赖的版本，这个问题是没法解决的。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"uv-管理-torch-下载源\",\n      children: \"uv 管理 torch 下载源\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常而言，在不指定 index 时 uv add torch 是去 pypi 或清华镜像源找 CPU 版本。如果打算每个项目都采用一样的 torch 版本 和 cuda ——\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"uv-创建的新项目\",\n      children: \"uv 创建的新项目\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"共用的 \", _jsx(_components.code, {\n        children: \"uv.toml\"\n      }), \" 指定下载源。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Linux 在 \", _jsx(_components.code, {\n        children: \".config/uv/\"\n      }), \" 下，Windows 在 \", _jsx(_components.code, {\n        children: \"%APPDATA%/uv/\"\n      }), \" 下。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-toml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-section\",\n          children: \"[[index]]\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"url\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/\\\"\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"default\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-section\",\n          children: \"[[index]]\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pytorch-cu128\\\"\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"url\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://download.pytorch.org/whl/cu128\\\"\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"explicit\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"项目级别的 \", _jsx(_components.code, {\n        children: \"pyproject.toml\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-toml\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dependencies\"\n        }), \" = [\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"torch==2.7.1\\\"\"\n        }), \",\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"torchvision==0.22.1\\\"\"\n        }), \",\\r\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"torchaudio==2.7.1\\\"\"\n        }), \",\\r\\n]\\r\\n\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-section\",\n          children: \"[tool.uv.sources]\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"torch\"\n        }), \" = [\\r\\n  { index = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pytorch-cu128\\\"\"\n        }), \"},\\r\\n]\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"torchvision\"\n        }), \" = [\\r\\n  { index = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pytorch-cu128\\\"\"\n        }), \"},\\r\\n]\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"torchaudio\"\n        }), \" = [\\r\\n  { index = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"pytorch-cu128\\\"\"\n        }), \"},\\r\\n]\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"然后执行 \", _jsx(_components.code, {\n        children: \"uv sync\"\n      }), \" 安装。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"uv-pip-管理老项目\",\n      children: \"uv pip 管理老项目\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"直接指定命令行 的 \", _jsx(_components.code, {\n        children: \"--index-url\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-shell\",\n        children: \"uv pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu124\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"和用 pip 的方式差不多，区别是会硬链接到集中的缓存，不会重复占用十几份 torch。当然。该有的依赖冲突还是会有的。\", _jsx(_components.del, {\n        children: \"关键是装好后就不要更新了\"\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":" ##  conda 的问题  Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。  ","prevPost":null,"nextPost":{"title":"踩了一圈 CSS 构建方案的坑","link":"/posts/2025-07-12-compare-css-solutions"},"headings":[{"title":"conda 的问题","rank":1,"id":"conda-的问题"},{"title":"uv 之于 conda 项目","rank":1,"id":"uv-之于-conda-项目"},{"title":"1. 不提供 venv 的项目","rank":2,"id":"1.-不提供-venv-的项目"},{"title":"2. 提供 venv 的项目","rank":2,"id":"2.-提供-venv-的项目"},{"title":"uv 管理 torch 下载源","rank":1,"id":"uv-管理-torch-下载源"},{"title":"uv 创建的新项目","rank":2,"id":"uv-创建的新项目"},{"title":"uv pip 管理老项目","rank":2,"id":"uv-pip-管理老项目"}]},"__N_SSG":true}