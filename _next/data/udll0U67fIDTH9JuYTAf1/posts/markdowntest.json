{"pageProps":{"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    hr: \"hr\",\n    h2: \"h2\",\n    del: \"del\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    h3: \"h3\",\n    h4: \"h4\",\n    h5: \"h5\",\n    h6: \"h6\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"此文件留做 Blog 开发的新 feature 测试文件。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      id: \"draft属性\",\n      children: \"Draft属性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"目前，在 yaml header 中，draft 属性设置为 false ，意思此 posts 将作为草稿，后续可能修订，不在 rss 中发布。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"此举主要是考虑到，由于某些 rss 服务的缓存机制，一旦获取过旧的 rss 订阅，即便后续更新过内容，后续读者也不会获得更新的内容。这使得 rss 的发布相对网页发布而言更加正式。而我个人写博客的时候通常较为随意，会有挤牙膏式修订。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"具体是否在网页上是标注为草稿待考量，\", _jsx(_components.del, {\n        children: \"设计太难了\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"添加于 2023-08-30 日。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"code-highlight\",\n      children: \"Code  HighLight\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() {\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"x\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sum\"\n        }), \" = |y: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"| { x + y }; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\"\n        }), \"\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"println!\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"sum\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"99\"\n        }), \")); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 输出 100\"\n        }), \"\\r\\n\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sum2\"\n        }), \" = |y :\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"i32\"\n        }), \"| x + y + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 也可以省略花括号\"\n        }), \"\\r\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"println!\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"{}\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"sum2\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"99\"\n        }), \")); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 输出 101\"\n        }), \"\\r\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"添加于 2023-09-15。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"typography\",\n      children: \"Typography\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"排版，以功能性划分，而非纯粹的美学scaling划分。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"很多时候web的一级标题应该独立设计，不是正文的一部分，仅作字号展示\"\n    }), \"\\n\", _jsx(_components.h1, {\n      id: \"很大很大的一级标题\",\n      children: \"很大很大的一级标题\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"很大的二级标题\",\n      children: \"很大的二级标题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"分Section的功能，下面经常接的是正文或直接的三级标题\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"三级标题\",\n      children: \"三级标题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"正文，需要和二级标题在远距离明显区分\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"四级标题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"正文，一般不用\"\n    }), \"\\n\", _jsx(_components.h5, {\n      children: \"五级标题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"正文，一般不用\"\n    }), \"\\n\", _jsx(_components.h6, {\n      children: \"六级标题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"正文，图一乐。下面是夹杂在正文中的列表。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Item1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Item2\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Item3\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"完毕\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{"title":"Markdown 测试","date":"2023-08-30","categories":"其他","description":"测试 draft 属性","draft":true,"tags":["blog"]},"scope":{}},"prevPost":null,"nextPost":{"title":"Windows调整之基础功能与常用插件","link":"/posts/2023-08-30-windows-tweak-and-enhancement"},"excerpt":" 此文件留做 Blog 开发的新 feature 测试文件。\r \r ----\r \r ## Draft属性\r \r 目前，在 yaml header 中，draft 属性设置为 false ，意思此 posts 将作为草稿，后续可能修订，不在 rss 中发布。\r \r 此举主要是考虑到，由于某","headings":[{"title":"Draft属性","rank":2,"id":"draft属性"},{"title":"Code  HighLight","rank":2,"id":"code-highlight"},{"title":"Typography","rank":2,"id":"typography"},{"title":"很大很大的一级标题","rank":1,"id":"很大很大的一级标题"},{"title":"很大的二级标题","rank":2,"id":"很大的二级标题"},{"title":"三级标题","rank":3,"id":"三级标题"}]},"__N_SSG":true}