{"pageProps":{"meta":{"title":"踩了一圈 CSS 构建方案的坑","date":"2025-07-12 20:49","tags":["CSS"],"categories":"学习","description":"前端代码中质量最薄弱的一环","keywords":"CSS, SCSS, Bootstrap, tailwind, styled-components, Linaria"},"mdxcode":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    strong: \"strong\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"css类复用粒度\",\n      children: \"CSS类复用粒度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我自己把 css 选择器（类）的复用粒度分三个层级。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"组件类\",\n      children: \"组件类\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-css\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".wrapper\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".container\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".list-item\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"组件化的选择器下面通常有很多条的 css。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"功能类\",\n      children: \"功能类\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常是共用的样式或状态，比如\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-css\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".open\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".close\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".light\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".dark\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".glass-effect\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个看起来好像和组件类不冲突，但硬说的话组件类其实应该是这样\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-css\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".container\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".open\"\n        }), \" { 此处将 \", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".open\"\n        }), \" 的所有样式全覆盖 }\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".container\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".close\"\n        }), \" { 此处将 \", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".close\"\n        }), \" 的所有样式全覆盖 }\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".container\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".light\"\n        }), \" { 此处将 \", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".light\"\n        }), \" 的所有样式全覆盖 }\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".container\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".dark\"\n        }), \" { 此处将 \", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".dark\"\n        }), \" 的所有样式全覆盖 }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"组件类的状态严格在组件的 scope 下。功能类则是可以不限 Scope 的复用。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这 CSS 容易混乱的根源。在工程维护角度，功能类是最不敢乱动的类，不知道动了后哪里样式就会出问题。但在设计角度，用功能类复用一些状态又确实很方便，统一设计也好用。比如增加统一的圆角、描边、阴影样式。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"功能类的优缺点是一体两面——图像的只有主观的好看与否，没有客观的对错。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"原子类\",\n      children: \"原子类\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"定义海量常用的基础样式类，在 class 上直接写类名就能获得对应效果。就是 tailwind css。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"原子类相较于功能类粒度更小，也不会轻易改动 css 属性。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-css\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".flex\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".col-1\"\n        }), \"\\r\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-class\",\n          children: \".text-sm\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"方案\",\n      children: \"方案\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常来说，一个库的样式会着重在一个某一个粒度上。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"原生-css\",\n      children: \"原生 css\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"用原生 css 时通常会以 \", _jsx(_components.strong, {\n        children: \"组件化\"\n      }), \" 的粒度为主，带极少的功能类。现在配合 css 变量使用。早期的网页简单，一个 CSS 文件就能搞定全站，设计上并没有考虑项目变得越来越复杂后的实践。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"优点\"\n      }), \"：性能好，扁平的结构利好小项目。适合写研究新样式。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"缺点\"\n      }), \"：过于扁平，大量工程化后易屎山，存在样式与 DOM 分离带来的维护混乱。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"scss\",\n      children: \"SCSS\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"古法预处理器，可能多层嵌套 css，可组合。是 \", _jsx(_components.strong, {\n        children: \"组件化\"\n      }), \" 的粒度。在 CSS.module 出来前，用 SCSS 分割 Scope 挺好用。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"优点\"\n      }), \"：结构非常清晰\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"缺点\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"编译后的选择器很长一串，从浏览器渲染角度，匹配DOM是耗性能的\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"难以应对复杂项目 DOM 结构的改变，需要考虑扁平化 + 命名，但这样做和原生 CSS 的维护体验也不相上下。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"css-module\",\n      children: \"CSS Module\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"CSS Module 是完全 \", _jsx(_components.strong, {\n        children: \"组件化\"\n      }), \" 的粒度。相比起 SCSS 的样式与 DOM 分离，CSS Module 为组件内部样式耦合，组件间样式分离。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"优点：\"\n      }), \" 在组件粒度分割合理的情况下，清晰易维护。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"缺点\"\n      }), \"：依赖预构建，写类名写起来太磨叽了。整体我用得不多没法评价。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"bootstrap\",\n      children: \"BootStrap\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"组件化\"\n      }), \" 为主，少量原子化修饰的预置样式库，拿来即用是不错的。早期 CSS 框架大多是指预制样式，和预构建的库有本质区别。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"tailwind-css\",\n      children: \"Tailwind css\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"完全原子化的神奇之库，通过编译可以有功能类和组件类。它更像是重新定义了 css 语法。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"优点\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"灵活，快，好看\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"工具链齐全，可以裁剪掉不用的原子类。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"缺点\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"稍微要写复杂一点的样式，DOM 就会被一大堆 class 埋没。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"从浏览器渲染角度，匹配、合并大量 CSS 样式是需要更多性能开销的\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"要做到同种样式的复用，必须组合原子类，变成功能类或组件类，否则维护起来相当麻烦。这似乎违背了用 tailwind css 的初衷，熟悉了 css 的不如直接自己用 css 手撮功能类和组件类。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"其实我是 tailwind 黑，嗯。但无法否认开发时确实很快很方便。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"原生-css-in-js\",\n      children: \"原生 css in js\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指 JS Object 转译为 CSS。由于写起来太不像 CSS，复杂的功能写起来过于不直观 ，我直接 PASS。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"styled-components\",\n      children: \"Styled-components\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"组件化\"\n      }), \"的 CSS in JS 方案，写起来像 CSS 实际是 JS。支持客户端动态修改 CSS 具体属性（其他方案做状态改变主要依靠 selector 的匹配）\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"优点\"\n      }), \"：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"灵活好拓展，比如主题管理不仅仅是颜色，还可以是图片资源一类的。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"缺点\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"因为是 JS 转 CSS，服务器编译慢和客户端渲染慢得选一个\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React 的 useContext 要被废弃了，而 styled-components 严重依赖此 hook，导致进入了维护状态。JS 框架发展太快了。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"linaria\",\n      children: \"Linaria\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"自定义 \", _jsx(_components.strong, {\n        children: \"功能类\"\n      }), \" 的 CSS in js 方案，同时也支持 \", _jsx(_components.strong, {\n        children: \"组件化\"\n      }), \" 写法\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"优点\"\n      }), \"：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"是预构建方案，和原始的 CSS 写法和思路差不多。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"缺点\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"组件化鸡肋， 功能类和组件化过于割裂，反而使得组件化样式管理困难（比如组件样式和自定义原子样式写两个地方，加上DOM 上写 classname，等于写个样式得看三个窗口）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"使用功能类有点像原子化，又完全不如 tailwind 已经给你预设好一堆东西的效率。写类名和 cssmodule 一样，太磨叽了\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总之有点四不像。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"构建组建库\",\n      children: \"构建组建库\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"每一个 CSS 方案都有对应的构建组件库的实践。 \", _jsx(_components.a, {\n        href: \"https://github.com/shadcn-ui/ui\",\n        children: \"shadcn\"\n      }), \" 是基于 tailwind 构建组件库实践。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"css-框架选择要素\",\n      children: \"CSS 框架选择要素\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"样式复用\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"样式组合\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"动态样式\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"主题切换\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"代码提示\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"自动裁剪\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"随意重构\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"渲染性能\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"实践的统一性\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最重要的还是自己的需求。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","excerpt":" css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）  ## CSS类复用粒度  我自己把 css 选择器（类）的复用粒度分三个层级。  ### ","prevPost":{"title":"uv 管理 conda 项目依赖","link":"/posts/2025-07-24-embed-python-with-uv"},"nextPost":{"title":"Steam 假入库是怎么做的","link":"/posts/2025-04-22-techs-about-steam-crack"},"headings":[{"title":"CSS类复用粒度","rank":1,"id":"css类复用粒度"},{"title":"组件类","rank":2,"id":"组件类"},{"title":"功能类","rank":2,"id":"功能类"},{"title":"原子类","rank":2,"id":"原子类"},{"title":"方案","rank":1,"id":"方案"},{"title":"原生 css","rank":2,"id":"原生-css"},{"title":"SCSS","rank":2,"id":"scss"},{"title":"CSS Module","rank":2,"id":"css-module"},{"title":"BootStrap","rank":2,"id":"bootstrap"},{"title":"Tailwind css","rank":2,"id":"tailwind-css"},{"title":"原生 css in js","rank":2,"id":"原生-css-in-js"},{"title":"Styled-components","rank":2,"id":"styled-components"},{"title":"Linaria","rank":2,"id":"linaria"},{"title":"构建组建库","rank":1,"id":"构建组建库"},{"title":"CSS 框架选择要素","rank":1,"id":"css-框架选择要素"}]},"__N_SSG":true}