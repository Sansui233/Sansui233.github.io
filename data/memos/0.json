[{"id":"2026-02-21 18:31:09","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,0],"word_count":374,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有时还是不可避免地觉得很无奈，人没办法既要又要，你没法要求同一个人同时具备躺平和探索前沿，没法要求一个人又要保守遵循传统又要冒险和创新。他们什么时候工作不会因为工作季的到来从天而降，我需要学习很多东西，花大量的时间去实践很多东西，我不觉得这很辛苦，凭什么就说这样没有生活。连续10天接连不断的亲戚与接待，想着我必须要面对的一切，烦躁又爬上了顶峰，人没办法既要又要。你要教育人抛弃自己的理念听很多人的意见患得患失深谋远虑，代价就是长远的踌躇不前；你大谈国际形势金价飞涨，就算再对也远不如早就行动的股民。你一边畅想科技发展十年后人人开飞机一边说你考虑去电网。我听着亲戚的敲门声突然又陷入了崩溃，你知道为什么我在家就是这样，根本没法学习，没法写完一句提示词，我整个人再次陷入了崩溃。永远都是这样被烦死的状态，永远永远。30分钟内被叫走的概率为 100 %。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那我要带上耳机，把音乐放到最大声，即便我的门锁再次被撞坏也在所不惜。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-02-08 06:01:00","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,1],"word_count":583,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"不知道从哪里看到了再次西西弗斯，在搜索中 AI 总结的寥寥数语有着对于人生「荒诞」的理解，因此而对加缪的此本随笔产生了兴趣。尽管我厌恶哲学一类的词，总是被贴上晦涩难懂的标签，也少不了一些阴阳怪气的话。小时候对此感觉不明觉厉，不过就是以「嘻嘻，还是小孩子」打发。而人到三十岁后还谈论这些，便是「都扯到哲学上了，多宏大多难懂啊」。诚然十三岁和三十岁对于意义的追求不尽相同，十三岁总会往生活上加「重」，幻想文学中二文学盛行；三十岁不再会为赋新辞强说愁，只道是寻常。从所谓的“哲学”意义上说，人和人之间的差距，比人和狗之间的差距都大。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"承认生命的无意义，便可以避免自杀。此种体验早发生在尚未来得及做出反应的时候，我认可所有人对生命意义的理解，却又不认可是属于我的事实。于我而言，「活着的意义只是活着本身」而已。不曾想到加缪开篇便道明了一切，真正会自杀的人反而是对于生的意义明确之人。这个国家这个年代几乎不见对待生命之轻，充满了生命之重，当你不可承受这样的重量，那就是人人诛之，就像 35 岁失业极为死刑一般。“网暴”对人的精神摧残也是如此，倘若你接受这样的叙事，就是自杀之时。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"网络上“及时享乐”主义的盛行，是大家普遍活在宏观叙事意义的重压下的结果。「重」到极致，从而衍生出了「轻」到极致的追求。我无法忍受这样的「轻」真正践行于生活之中，却也无法忍受被赋予的「重」。真正破局的方法唯有行动本身，不为行动而做的计划（画大饼、讲故事）没有任何作用，正如同对于未曾到来的未来而散播的语言焦虑一般。可破局之法唯有行动本身，唯有行动本身。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-29 01:32:56","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,2],"word_count":59,"content_jsx":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [_jsx(_components.a, {\n      href: \"https://yazi-rs.github.io/\",\n      children: \"Yazi\"\n    }), \" 确实好用，早日干掉 Windows 资源管理器（不是）。Windows 资源管理器现在都没有多栏 View，UI 在 23h2 上卡爆炸。 25h2 现在好像修了，其实还不错的。那只剩没有多栏  view 了。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-26 20:37:38","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,3],"word_count":90,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"挺看好  anrigravity 的。我倒希望和 vscode 差别越来越大。能干的事不只有写纯文本。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是模型写代码能力真的不太行，gemini 系列的幻觉还是太重了喜欢乱猜原因，然后把代码改得一团乱，而不是使用一些方法验证。这点还是 GPT5.2 和 cc 比较强。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-25 19:09:16","tags":["分享"],"imgs_md":[],"sourceFile":"","csrIndex":[0,4],"word_count":412,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/yuaotian/antigravity-proxy\",\n          children: \"免 tun 使用 Antigravity 的工具\"\n        }), \"\\n实测可以登录，但获取模型列表会出错。把\", _jsx(_components.a, {\n          href: \"https://github.com/yuaotian/antigravity-proxy/issues/29#issuecomment-3794299080\",\n          children: \"编辑器内 http proxy 也设置为 7890\"\n        }), \"  就好了。至于为什么不开 tun …… 我的 tun 目前还要留给学校 vpn，学术网站走代理软件即便是直连也不行。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/magic-research/magic-animate\",\n          children: \"magic-animate\"\n        }), \" 原来AI换动作用的是这个……其实我是想搜 motion 相关的插件，没想到出了这个……\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=xuoHLyWymz0\",\n          children: \"magic-animate\"\n        }), \" Davinci 很方便的做转场的动画插件。\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"出入场动画： Zoom, Whip，可设置延迟速度时长等等。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"中场动画，Shake, Mid Wave\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fusion 我用了，感觉是好难用。写了表达式可以在样条线里看，虽然写表达式不用手 K 帧是好事，但是你也没说能存个表达式和变量组的预设啊？变量有没有效果也不知道没报错。而且动画经常是要一段一段的，不是一个表达式就是写完的。样条线也没有预设保存，次次手K吗……很少见到这种强大又鸡肋的东西了。就是感觉 HTML 都写得比快……总之不要用 Fusion 做动画！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而且 Fusion 效果无法预览这点也很要命，要把所有节点的作用背下来……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外 MG 动画其实只要重复 + 非线性一下就会有好的效果，真的，就看有没有那个心情去 K 重复的动画。常见套路就是非线性+重复动画+时间差（视差），再加点莫名其妙的 Mask。 复古的抽个帧。PATH 类的常见路径动画。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-24 02:47:21","tags":["分享"],"imgs_md":[],"sourceFile":"","csrIndex":[0,5],"word_count":12,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"3D\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=gdOaUv0_TC8\",\n          children: \"Blender Bones For Beginners - EASY - YouTube\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-19 21:09:44","tags":["分享"],"imgs_md":[],"sourceFile":"","csrIndex":[0,6],"word_count":444,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"技术\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://cacm.acm.org/blogcacm/two-concepts-of-intelligence/\",\n            children: \"智能的两种概念 – Communications of the ACM\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"我觉得可以折中一下，是在无相关经验情况下给出正确答案能力，既有了明确指标也避免了“归纳式智能”。这在现实世界是很确定的出题方式了吧，IQ 测试题都是被设计为无需先验知识的，不会有语言题，你甚至可以给猩猩做。看看图像模型看这么多图后，能不能补全呀哈哈的最后一颗石头就行了。我觉得 AI 是可以有逻辑的，要是有合适的无监督聚类算法，训练了说不定真的可以完成这种任务。但是没有这种无监督随便迁移领域的聚类算法，现在说的无监督实际是自动生成标注/不需要额外人力标注的有监督。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"对于情商我自己定义为，“在自我有相关经验情况下，能给出被社会接纳的答案，并强烈遵守此答案” 的能力。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"刚问了 GPT 下面这个问题，嗯，一塌糊涂。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://austinhenley.com/blog/ladybugclock.html\",\n            children: \"一个随机游走问题\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"结论应该是这样的：每个数字上的停留概率是一样的，这是一个理论上稳态分布 stationary distribution，有限次数内只能逼近无法到达的完美分布。如果限定到在有限次数内完成遍历，在 1 和 11 停留的概率是最大的，停留在 6 的概率是最小的。或者说，在 6 停留的平均步数要比其他的数字长，停留在 6 的 step 比 停留在 1 上的步数上要多个十几次，这已经超过了一圈的距离。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-18 18:05:29","tags":["TODO"],"imgs_md":[],"sourceFile":"","csrIndex":[0,7],"word_count":207,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"感觉 rust 的出现一统 shell 体验的天下……尤其是 windows 版本的。没有 rust 就不会出现 starship zoxide eza 这些东西，跨平台还要用到系统库 c++ 够得受了。如果 tree-sitter 生在现在就不会有各种 libc 的破事了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外就是小模型的浏览器 C 端运行…… onnx 还真是可以试一下，小工具狂魔又有玩的了。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/microsoft/onnxruntime-web-demo\",\n          children: \"onnxruntime demo\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/vietanhdev/samexporter\",\n          children: \"SAMexporter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/Xenova/whisper-web\",\n          children: \"Whisper Web - a Hugging Face Space by Xenova\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/webml-community/YOLO26-WebGPU\",\n          children: \"YOLO26 WebGPU - a Hugging Face Space by webml-community\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我觉得超分辨率模型还挺适合做这个的。列入 \", _jsx(Tag, {\n        text: \"TODO\",\n        children: \"#TODO\"\n      }), \" 吧。还有抠图，真的没有做纯客户端的抠图吗全都去服务器排队…… seg 模型 CPU 算个几秒也是完全可以接受的啊。哦对，这倒是有商业模式的问题。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-16 21:50:19","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,8],"word_count":30,"content_jsx":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"看了下 zed 的 \", _jsx(_components.a, {\n      href: \"https://www.gpui.rs/\",\n      children: \"gui 库\"\n    }), \"，wow，DOM 之青春版，蛮喜欢的。zed 团队的复刻轮子能力是真的强。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-16 16:05:27","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[0,9],"word_count":179,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    hr: \"hr\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"域名搬到 porkbun 了。namecheap 直接涨到 25刀了。本来想说迁移到 CF 算了，结果 Cloudflare 的 transfer  系统错误一次后就此卡住了。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"给了 vscode 编辑器一个 vim emulator。很早之前有用过但是实在是用不习惯。现在我觉得驯化程度比以前高一点了所以再试下。vim normal mode 可以解决快捷键不够用的问题，像是侧栏图标是很难按的，但给的快捷键实在不是人，三键起步还是最不好按的 ctrl + shift 组合。但我觉得 emulator 的响应速度有点慢，特别是保存文件时，调用的 vscode api 但要卡一秒， 不知道为什么。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"}]