[{"id":"2026-01-14 17:32:36","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[1,0],"word_count":830,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    blockquote: \"blockquote\",\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"暴论之：如果 Rag 真的能变好用，能检索知识库到最相关的知识的而没有那么多噪声，建议去开个公司起个昵称 RAGoogle，口号是就划时代的谷歌。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"好像也不是第一次吐槽了，上一个这么吐槽的还是无代码。还觉得是个方向问题，并不 AI，更像是现在的工程。RAG 不够“AI”、效果不好的根源是检索时没有对 Prompt 的文本理解，只是把之前相关性排序的方式用机器学习又做了一遍，这个就是传统的数据分析，一直以来都算是脏活。搜索引擎的结果就没用过机器学习吗？巨硬广告营销部门搞算法的他们现在工作是在干什么？算法的准确性离开了人们的点击率驻留时长效果还能好的吗？要有好的结果必须要在排序文本相关性时理解人类的偏好，哪怕是推理出的偏好。大模型的长上下文有用正是胜在了对人类的输入与参考资料的相关性有一个推理的过程，如果拿一大串完全无关资料给大模型，大模型会告诉你引用似乎看起来没有关系，答案的正确性并不会受太多影响。但你在 User Query 后面说点废话（知识库包含的主题）看看 RAG 的 embedding 计算会不会检索出没用的资料？包的。同时可以试试谷歌，会不会在 \", _jsx(_components.code, {\n        children: \"bash 的配置方法 RAG 2025年的应用\"\n      }), \" 这种关键词里，真的在第一页搜出 bash 的配置的方法。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"真正的 AI 时代完全没有来临，因为市场结构完全没有因其变化。上世纪的那场泡沫用了7年破灭，如果到5年后还没有什么能用上的地方，嗯。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"我是感觉最终形态可能会是仿生生物的记忆储存方式，类似于一个虚拟大脑的结构，知识做了一些提取（但是同时有标记知识点的出处）处理，如果是知识点的调用，直接从虚拟大脑取到记忆即可，如果是想获取详细的原文，就通过出处去寻找原文，给出原文的详细内容。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"确实不如去做 summary（不一定是人类可读的形式 ColBERT 那种表征也行）。相关性排序（reranker）功能目前只能给大模型做，很难参数量小，没办法事实证明了产生够用的语言逻辑就得要这么大的模型，但问题是 rerank 前 retrieval 的部分效果，从 User Query 到召回这部分就还是纯数学的，问题不是出在 rerank 上。都到这个地步了又会想，不如大模型一把梭了得了，真到给人用的时候，又没有条件去做实时的 embedding FT，再小不也得几十 G 的 显存也没法说 1 分钟内训练完成。可以说 embedding 模型不下放到每个知识库去 fine-tune 都是没有意义的，即便下放了，也会面临缺乏对应知识库 QA 数据的问题，这就是个死路。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-12 16:27:54","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[1,1],"word_count":395,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"看了看 practical vim，感想是果然用不来。心智负担很重的。很多为了简化操作而进行的步骤，是因为当时没有直觉性的鼠标定位和编辑器不够智能才需要学。有里面提到，“程序员大部分时候在思考而不是写代码，所以默认为普通模式”。所以不思考的时候，用鼠标/触摸板滚动和浏览不是更好吗？主要就是大滚动后的定位，这个键盘怎么做都没可能比鼠标和触摸板好的。我个人觉得触摸板更适合这个任务，因为手的位置不用变化，真正的补齐了全键盘流最不方便的地方。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"批量编辑在 vim 中被拆解成了编辑一次、多次重复“定位与编辑”。但现代编辑器的替换工具都内置了，双击后 \", _jsx(_components.code, {\n        children: \"C-h\"\n      }), \" 再一路 \", _jsx(_components.code, {\n        children: \"enter\"\n      }), \" 下去，不需要换的 \", _jsx(_components.code, {\n        children: \"f3\"\n      }), \" 跳过。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但读这个还是有好处的，明白了给 vscode 安装 vim 插件到底是为了解决什么问题——分散的键位（由其 fn 系列）和频繁用小拇指。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于鼠标流，可以双击进入 view ，配合上的 smart expand 或者 \", _jsx(_components.code, {\n        children: \"af\"\n      }), \"，text object 的精准选择是可以更快的，然后再进行操作。对于 vscode，我觉得 view mode 比较重要一点，因为可视化软件都是先选中对象再操作的逻辑，这和 view mode 很像。先操作再选择怎么都不太能适应。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-11 06:42:02","tags":["分享"],"imgs_md":[],"sourceFile":"","csrIndex":[1,2],"word_count":597,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"综艺/生活\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://www.bilibili.com/video/BV1tfiFBzEhD\",\n            children: \"あざとくて何が悪いの？有点心机又如何\"\n          }), \" - bilibili 5的人的爱情，突然刷到看了起来……\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://www.bilibili.com/video/BV1tfiFBzEhD\",\n            children: \"一个韩国旅游博主的成都丽江之旅\"\n          }), \" 这位是真的会拍会剪的。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看了一下有人在说虾皮的技术更新网页文档，全是滑动交互，感觉是用 three.js 塞了很多3D模型，确实好看。不过说由此说什么等领导审美觉醒不觉醒就不必了，真的想要自己的页面3s打不开吗，打开了第一页啥信息也看不出吗。特如果是做中文设计，要用系统字体以外的字体，可能就不是三秒的问题了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我有很喜欢的设计师的个站，但对设计师自己做的交互丰富的站有三个很刻板的印象。1是太卡了，用 JS 动画 CPU 爆炸，用 WebGL则是没有 GPU 时 CPU 爆炸，2是响应式容易不注意有一堆问题。其实还有一个是，3是信息密度太低看个什么都要划很多下，看不到重点的信息。有人会觉得硬件过剩，并没有，什么时候办公本都能做 AE 不卡了再来说硬件过剩，什么时候讨厌 Electron 教会解散了再来说硬盘和内存够用。设计是一个会用 10 倍资源去为了实现那 1 倍视觉效果的，就像剪辑里的动画一样，但设计师可不会只想要 1 倍效果，会想要 10 倍。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最实用且有效率的方式就是，画图，图片排版，做印象效果视差等等也够了。但图片的问题是依旧得拿字体去配图像风格，到中文这边，字体又是一个巨大的坑，一个字体能放一百张图。所以最好是图像的风格也是现代的无衬线字体换个颜色就能配上了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有设计感的站通常带有强烈的表达倾向，以至于字体语言配图全都是为表达服务的。体验是这样的效果非常酷，但也就意味着不可复用。我觉得把信息量和交互动效平衡做得很好的还算是 flatstudio.jp。他们用得很克制了。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-10 03:19:55","tags":["react"],"imgs_md":[],"sourceFile":"","csrIndex":[1,3],"word_count":496,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"react\",\n        children: \"#react\"\n      }), \" 现在虚拟滚动的纯 JS 方案，或多或少都有 Jitter，我指是所有包括 twitter，只不过 twitter 属于不 resize 一下看不出来。我这个页面也是这样的，resize 和 内部展开后不收起，前向重新滚到时会抖，其余情况不会。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是 tanstack 不一样，子元素高度为auto，前向滚动就一定抖……\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"issue 追踪： \", _jsx(_components.a, {\n        href: \"https://github.com/TanStack/virtual/issues/659\",\n        children: \"https://github.com/TanStack/virtual/issues/659\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"他们的算法的问题是：第一，向下滚动后再向上滚动没有占位缓存，只能使用估算值（或子元素的 style）。第二，他们的 overscan 虽然设置了值但其实是一个一个进的，每进一项都在调，这导致一直滚一直在抖。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不过，如果子元素有明确指定 height ，占位使用子元素的 height 值，这种情况是不会抖的。所以在子元素高度自己在挂载前就算得很准的情况也可以，但复杂排版意味着你还得假挂一下去算高度。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那，为什么不能是 measure Element 里提前去假挂一下呢？挂完了返回的 DOM 还能真挂。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"浏览器本身有 Scroll anchor 定位，直接挂到视窗前面本来也不会偏移。问题在于虚拟列表的 transform 给偏移了（要怪就怪浏览器没有负坐标吧）。前身滚动时\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"增大窗口 height：对子元素视觉0影响，不造成 jitter。子元素是 absolute transform 定位的。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"在设定 子元素 transform 的瞬间设定 scrollTop，以批量更新\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后就涉及到了 React 这个纯函数祖宗之法的问题，你怎么保证useMemo后可以一起渲染？当 itemHeights 更新后，所有的子元素肯定是下一帧渲染了，但 ScrollTop 是要怎么一起更新的？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你不能使用 useEffect 去订阅 itemHeights，因为这个副作用会在子元素渲染完成后才能更新，那就成功 jitter 了。所以，要使用 useLayoutEffect。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-09 03:25:00","tags":["分享"],"imgs_md":[],"sourceFile":"","csrIndex":[1,4],"word_count":30,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"社会\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://b23.tv/lKNoN9d\",\n          children: \"十分钟解读社会学神书《日常生活中的自我呈现》-哔哩哔哩\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-08 14:14:49","tags":["react"],"imgs_md":[],"sourceFile":"","csrIndex":[1,5],"word_count":386,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"react\",\n        children: \"#react\"\n      }), \" 回看 next mdx remote 的实现，当时我是着实不知道是为什么要分 rsc 和非 rsc。我知道 rsc 是服务端渲染的，但难道非 rsc compile 出来的组件就不能服务端渲染了吗。因为我看了下两个组件反序列化的过程可以说是一模一样一致，都是在客户端水合一下。唯一的区别就是非 rsc 把 mdx.js 暴露的全部组件都传了进去，\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Compile Options\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providerImportSource\"\n        }), \": rsc ? \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@mdx-js/react'\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 对应 MDXRemote index 里的 \"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" mdx \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@mdx-js/react'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 因为反序列化后的函数字符串可能会调用到 mdx-js 的内容，也就是 useMDXComponent，RSC 不支持，所以序列化前必须指明编译参数。\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也就是rsc 的组件实现对 mdx-js 零依赖的。所以到底有什么必要在非 RSC 里的组件里把 mdx.js 所有的组件都传进去呢。主要就是是否注入 mdx-js 库里的 \", _jsx(_components.code, {\n        children: \"useMDXComponent\"\n      }), \"的调用。但不编译能有什么影响呢\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"问了 Gemini，他是这么说的：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// 纯 Props 模式，每次用都要传，累死人\\n<MDXContent components={{ YouTube, Tweet, Chart, ... }} />\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"看了一眼 \", _jsx(_components.a, {\n        href: \"https://mdxjs.com/docs/using-mdx/#mdx-provider\",\n        children: \"MDXProvider\"\n      }), \"……其实开头就说得很清楚了：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"You probably don’t need a provider. Passing components is typically  fine. Providers often only add extra weight.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"意思就是没需求别用……所以这种小东西自己写库就可以了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"给 markdown 自定义语法和渲染，其实就是需要两部分\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"remark 插件（rehype 也行 但我觉得 remark 更简单）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"component 渲染替换\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2026-01-07 10:26:00","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[1,6],"word_count":137,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"看到一些说搞 AI 人的科普贴子，一看是部署的不是算法的，感觉有点无奈。学NLP在NLP最火的时候不搞NLP，论文不想写也就算了跟风搞应用也不想搞还能把自己饿死，跟有病一样。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后那种精神上想吐感并没有消失，我知道怎么解决但解决不了。不过远离对象一种烦躁的感觉消失了。什么他人即地狱（原意，不是其他人都是恶魔那个意思）。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-06 23:15:00","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[1,7],"word_count":32,"content_jsx":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"呕……好想吐，很难说是精神原因还是生理原因。我觉得有点偏向于精神上想吐。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-06 04:10:28","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[1,8],"word_count":71,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"草，有瓜\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"\",\n          children: \"这是一篇号商无能狂怒的聚集地：This is a gathering place for the incompetence and rage of a number merchant\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"全被删了。有贴子看了一眼风格\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"总结：\", _jsx(_components.a, {\n            href: \"https://linux.do/t/topic/1408515\",\n            children: \"https://linux.do/t/topic/1408515\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"贴子风格：\", _jsx(_components.a, {\n            href: \"https://x.com/flyiiawei/status/2008124574379212830\",\n            children: \"https://x.com/flyiiawei/status/2008124574379212830\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://linux.do/t/topic/1408358\",\n            children: \"https://linux.do/t/topic/1408358\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"怎么传播广的不是骂人就是黄段子……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2026-01-04 20:32:00","tags":["react"],"imgs_md":[],"sourceFile":"","csrIndex":[1,9],"word_count":985,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h3: \"h3\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"react\",\n        children: \"#react\"\n      }), \" 一个没有预料到的状态管理问题：如果组件层级 A>B>C，A负责获取数据源，C负责渲染。那 State 缓存数据不要给到 B。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为什么？因为 C 同时应用 A 的更新数据和 B 的缓存数据时，B的缓存数据更新会慢一拍，因为B需要去订阅A的更新再通知C更新 props（useEffect 是异步的）。如果 C 中有 state 的初始化依赖缓存数据，那这个初始化也会慢一拍。导致渲染结果（随着缓存更新）和 C_state（只随初始化更新）不一致。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可能会想，那 C_state 也去订阅 B 缓存就好了？不行，订阅 B 缓存，C_state 更新也还是比渲染慢一拍。此时如果渲染会更新 C_state，那就和对于 B 的订阅冲突了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用缓存是副作用，谨慎处理副作用。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"为什么有这么奇葩的结构……因为A和C都是库啊！！只能存到B。好消息是C库自己实现的，改成C库自己存数据，有数据更新后通知B了。但要是真只能写B，C不存数据，那 C 的 props\", _jsx(_components.strong, {\n        children: \"需要全部用同步更新的缓存\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这其实提到了一个叫派生状态，知乎上有说，但最终也没提出来解决办法。派生状态至今没有检测。 \", _jsx(_components.a, {\n        href: \"https://zhuanlan.zhihu.com/p/349372515\",\n        children: \"https://zhuanlan.zhihu.com/p/349372515\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这是我使用 react-router clientLoader 最大的坑。非常容易遇到反模式。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Lazy import 组件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"好好了解一下 Lazy 的概念，看 SSG 这种重 SEO 场景首屏能不能用。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先是要明白，Lazy 导入的组件必须被 Suspense 包裹，不然会 Throw 一个异常向上报错直到遇到了 Suspense 组件进行一个 fallback。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其次是分情况\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"函数 await import，以 show State 加载 -> 无首屏，不显示在Dom\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Lazy import，以 show State 加载 Suspense -> 无首屏，不显示在Dom，用 Lazy 属于多此一举。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Lazy import ，以 Suspense 加载 -> 大致能用（Dom 能显示，有短时间不可交互，直到浏览器自动下载完代码分割）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"仅以 Suspense 加载 -> 能用（Dom能显示，显示就能交互，没有代码分割）（RSC核心）\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于以上第三个点，“大致能用”是有个坑\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"如果 JS 加载慢，React 在客户端运行时发现代码没到，它可能会判定为“未准备好”，于是\", _jsx(_components.strong, {\n          children: \"扔掉\"\n        }), \"服务端渲染好的完美 HTML，转而显示 \", _jsx(_components.code, {\n          children: \"Suspense\"\n        }), \" 的 \", _jsx(_components.code, {\n          children: \"fallback\"\n        }), \" (即 \\\"Loading JS...\\\")。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"需求2\"\n      }), \"：需要手动点击后再下载 JS，下载 JS 过程中显示一个 Fallback 。使用 \", _jsx(_components.code, {\n        children: \"Lazy import\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"useState\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 可做。\", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 可以让人少写一个 state 三目运算符，显得好看一点，别的没用。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"需求3\"\n      }), \"： 首屏不加载，但首屏挂载后偷偷下载 JS chunk 之后用。可以直接使用 \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" 普通 import。但是这边有个问题，这个import的结果是在副作用里，你要暂时存到一个变量才能在需要的时候调用。如果嫌组件存变量占内存，可以 \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" + 顶层\", _jsx(_components.code, {\n        children: \"Lazy import\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"总之： \", _jsxs(_components.strong, {\n        children: [\"用 \", _jsx(_components.code, {\n          children: \"useEffect\"\n        }), \" 触发网络请求，用 \", _jsx(_components.code, {\n          children: \"lazy\"\n        }), \" 管理组件引用，用 \", _jsx(_components.code, {\n          children: \"Suspense\"\n        }), \" 处理加载状态。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Suspense\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 的本质并不是为了服务 \", _jsx(_components.code, {\n        children: \"lazy\"\n      }), \" 组件的，它的本质是：\", _jsx(_components.strong, {\n        children: \"让组件“暂停”渲染，等待某个异步操作（Promise）完成。\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Suspense 里挂载一个\", _jsx(_components.strong, {\n        children: \"异步组件\"\n      }), \"，就可以等异步组件有返回后再显示。比如子组件里使用 await fetch 阻塞了结果返回。而Lazy 组件，也这么一种异步组件。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Suspense 里挂载一个带有 \", _jsx(_components.code, {\n        children: \"use hook\"\n      }), \" 的组件在 use hook 完成前，都会使用最近的 Suspense。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"use hook\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在最新的 React 版本中，推出了 \", _jsx(_components.code, {\n        children: \"use\"\n      }), \" Hook，它允许你在组件内部直接“解包”一个 Promise。如果 Promise 没完成，它会触发最近的 \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \"。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"}]