[{"id":"2023-11-06 19:18:22","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,0],"word_count":228,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"突然好喜欢可爱的字体哇~\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"好想用 consolas 做 UI font，这个有点可爱气质的打字机字体竟然意外适合，找不到任何一个替代品。可惜 mono font 因为等宽空格的关系，中英混排不行。我又是一个非常喜欢在中英文之间打空格的人。最后还是折中用了万能的 IBM Plex Sans。IBM Plex Sans 正文无敌强，和中文搭配也非常好。但是写 UI 的话就显得有点挤了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI 字体要和 正文搭起来挺难的。英文字体的搭配主要看几个基线，还有宽度和间距。基本比例一样的都行。但在不同字体间，要找比例一致字体的是一件极其困难的事，因为很容易没特色。IBM Plex Sans 和 arial 的比例就非常接近，只有宽度和风格区别。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-11-05 21:04:56","tags":["mdx"],"imgs_md":[],"sourceFile":"","csrIndex":[19,1],"word_count":249,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"以一个极其复杂的方式解决了 \", _jsx(Tag, {\n        text: \"mdx\",\n        children: \"#mdx\"\n      }), \" 渲染后的标签点击事件绑定问题。因为这不是 html 原生标签的替换，就有一点点麻烦。最后是从自定义 remark 的 AST 入手，直接解析后转换标签为对应的 estree 节点，再加上三次传 clickhandler，闭包持有 clickhandler，进行元素替换，终于绑上了……不愿再来一次，有这种需求应该直接写一个替换的框架。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以我终于可以进行下一步了吗，写 img 相关的组件。但是其实 memo 后端 parse 还有bug，突然到某一条就停了。重构了之后 bug 真的多……search组件还没统一拆出来呢，可以说是因为不会……但主要还是设计问题，没有想好移动端和桌面端怎么做才能统一，不要渲染两遍……还有目录，目录又应该放哪。目录和导航，选一个没吧……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2023-11-05 02:51:44","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,2],"word_count":30,"content_jsx":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"scroll bar 好烦！！！还没有一个好的思路来处理 scroll bar 时隐时现导致样式shift的问题。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-11-04 21:43:14","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,3],"word_count":229,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"看了一下 nextra 的解决方案…………额额额，他们重写了compiler，并没有用 mdx.js 原生的方法去 compile 成不可序列化的函数。他们的结果是可序列化的……不想重复造轮子。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"然后我又去搜了下 \", _jsx(_components.a, {\n        href: \"https://github.com/orgs/mdx-js/discussions/1980\",\n        children: \"discussion\"\n      }), \" ，又看了看 mdx.js 的 doc。才发现人家其实有函数的序列化和反序列化啊！但是不要看 Guide 里面说什么 Next 有自己的 mdx 方法，那个真的很鸡肋，非常鸡肋！最后搞定了，把巨大的 \", _jsx(_components.a, {\n        href: \"https://github1s.com/hashicorp/next-mdx-remote/blob/HEAD/src/rsc.tsx\",\n        children: \"next-mdx-remote\"\n      }), \" 移除了。这个库倒不是思路有问题，而是很久没有维护了导致不兼容新的插件。可能是 mdx.js 支持了所以停更了吧，没有考证，而且其实它做的事也不是很复杂，但引入的包是真的多，明明有 MDXProvider 但没有导出，又要多引入二十几个包……\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-11-03 22:50:03","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,4],"word_count":11,"content_jsx":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"今天是 Clash 全系删库的一天。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-11-02 22:20:54","tags":["工具"],"imgs_md":[],"sourceFile":"","csrIndex":[19,5],"word_count":135,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"工具\",\n        children: \"#工具\"\n      }), \" IPA签名工具：\", _jsx(_components.a, {\n        href: \"https://esign.yyyue.xyz/\",\n        children: \"轻松签\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"今日重要新闻：Clash for windows 删库。原因不知道。有说是晒车牌的，有说是推发了太多个人信息的，有说是内置机场被抓的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对不起我写着写着代码又开始画画了……这次是一个能画完的独立故事！不是片段了！加油！不加戏的话，九图可以画完！但我是真的会一边画一边加戏……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"啊好肝，肝起来根本没有时间写论文。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"},{"id":"2023-11-02 03:39:17","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,6],"word_count":118,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"说来面包推荐了一下 \", _jsx(_components.a, {\n        href: \"https://github.com/shuding/nextra\",\n        children: \"nextra\"\n      }), \"，我哭了，这不就是，我要的 60% 的功能都有，在这重复造啥轮子呢……\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后想看看他们 rehype 这一圈的文件是怎么组织的，学一学，要被这生态圈里类型不一致问题和版本兼容性问题搞疯了（真的先学后端语言的人会有强类型强迫症）。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"然后我就看到了：\", _jsx(_components.code, {\n        children: \"// @ts-nocheck\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（手动拜拜微笑脸）\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-11-01 03:33:06","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,7],"word_count":188,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"看了一下 \", _jsx(_components.a, {\n        href: \"https://github1s.com/hashicorp/next-mdx-remote/blob/HEAD/src/rsc.tsx\",\n        children: \"next-mdx-remote\"\n      }), \" 的 SSG 实现，汗，原来 getStaticProps 直接传的函数字符串。然后用渲染时还原函数。相当于函数的序列化与反序列化吧……\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-ts\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" fullScope = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Object\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"assign\"\n        }), \"(\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"opts\"\n        }), \": jsxRuntime,\\n    },\\n    { frontmatter },\\n    scope,\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其中的 jsxRuntime 是通过 process.env 动态获取的，也就是可以区分是生产还是在是 Dev。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总结一下就是，核心功能包括 SSR 依赖的是 mdx.js，只要能传函数 render 为一个 RSC (React Server Components) 就可以了嗯……这个库只是包装了一下下静态渲染的功能，核心渲染还是 mdx.js 做的。mdx.js 的解析核心又是unist……但比起解析我更想看 rsc 的底层是什么……我又不行了……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-10-31 14:22:26","tags":[],"imgs_md":[],"sourceFile":"","csrIndex":[19,8],"word_count":98,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"抠完样式和搜索了，现在要抠交互，交互写起来有时候很有成就感，有时候又没有，但大部分情况下是没有。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"架构的部分写起来很痛苦，但是后续开始复用时，就觉得我草我真牛逼。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"后端除了架构外大部分是在 debug，成就感取决于日志的输出情况。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n"},{"id":"2023-10-29 01:13:43","tags":["博客"],"imgs_md":[],"sourceFile":"","csrIndex":[19,9],"word_count":774,"content_jsx":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"对于 \", _jsx(Tag, {\n        text: \"博客\",\n        children: \"#博客\"\n      }), \" 我也有另外的打算。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"memos 页我要考虑重新布局，做成动态页当主页，还是多一些社交元素进来，确实我现在用比较多。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"有可能做成无限滚动的吧，留言板放侧栏，手机上的话，嗯，确实算是个有点麻烦的问题呢…………我是比较讨厌手机常驻浮动图标的……\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"把 date 的统计数据加上，再做一个流行的小日历。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"支持带九宫格图，主要影响渲染，解析又得重写。之前为了省事直接用的现成的mdx的渲染，现在就是一把心酸泪，要重写的东西还挺多的……而且，emmm，图文分离真的是好事吗？其实对于图像博主来说确实是好事。但对长文就不是了。但长文我又有 Posts 页面。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"另外还有图床的问题，由于我白嫖的 github 倒是从不考虑图像大小问题，上传图片前我也有压缩强迫症。但万一以后我想换到别的图床……算了，到时候再改吧，短期内没这个打算就是了。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"支持标签的解析，memos 支持标签过滤，但这又是个对于静态博客来说非常麻烦的搜索问题，需要提前生成索引文件，索引文件的维护也是个大问题，每个分析都得带有原文件位置和CSR文件位置防止失联。有时候真的想上sqlite3来存这些乱七八糟的东西。真想问问有没有一个库叫逆ORM，就是把一个 的 object list  当关系型数据库使，来构建一个新的Object……结构转换太常见，我觉得得有这种库，只是我不知道。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"另外要分析的东西比较多的话，memos的底层设计就得重新考虑了，必要时直接读进内存吧，不然又是在不停对磁盘io……特别是当要分析的东西比较多的时候。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后还有i18n，我突然又怀念起了中文UI，觉得中文UI很好，直接放字在那里也很精简。之前设计博客的时候，我就只想装，几何感强的英文是就特别好的选择。但现在的瓦塔西非常实用主义……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外，随着页面增多，构建速度越来越慢了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于memos和索引，我可以构建索引改变build时的状态。但是pages这个我是真的没法控制会不会被重复build，除非我去改变Next.js框架的build行为。但这样的话，额，我又是为什么要用这个框架啊（扶额）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果谁还说 Next.js 适合个人静态博客，我就先给他个大逼兜。要么老实用 Hugo 和 Hexo，至少人家有针对博文的 build 优化。要么做成动态的，上 CMS 。千万不要用 Next.js，会变得不幸，嗯。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不说了，一把心塞泪，原来静态博客的尽头是动态。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n"}]