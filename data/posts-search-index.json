[{"id":"z-index-and-context-management-and-design-logic","title":"z-index 设计与海浪模型","content":"摘要：本文针对前端中多个元素层叠时 z-index 管理混乱的问题，提出一个名为海浪模型的设计模型，以构建复杂 z-index 管理的最佳实践。 ……好像 AI。但我是人，我纯手打的。 基础知识 - 代码的画布 层叠上下文是代码逻辑上的画布。一旦一个元素产生了层叠上下文，它内部的所有子元素就被包裹在这个范围里。 层叠上下文的产生 根元素： &#x3C;html> 定位 + 层级： position 为 relative / absolute 且 z-index 不是 auto 。 固定定位： position: fixed 或 sticky 。 CSS3 属性： opacity 小于 1。 transform 不为 none（比如旋转、缩放）。 filter（滤镜）、flex/grid 子元素的 z-index 等。 ❗注意：层叠上下文的产生，和层内元素关系，是两套规则，两者之间 没有关系，没有关系，没有关系 。因为部分规则相似，很容易给记混了。 层叠内元素关系 为了好解释，我使用 context-level 说明绝对的上下覆盖关系。 CL-1: 背景和边框（最底层） CL-2: 定位元素（如absolute）且负 z-index CL-3: 块级元素（static 定位的普通 div 等） CL-4: 浮动元素（float） CL-5: 内联/行内块元素（文字、图片） CL-6: 定位元素（如absolute）且 z-index 没有设定为负，还有 opacity，transform 等。 CL-7: 定位元素（如absolute）正 z-index（最顶层） z-index 在其中的作用相当于是一个算层叠关系的插件。 必须和定位配套使用，否则不生效。 从功能上说， 层叠上下文才是真正面向用户的Z轴 ，z-index属性只是这个 z轴的一个插件。 视觉画布 可以发现，被提升到 CL-6 的层，其规则和产生一个层叠上下文高度重合， 就像产生了一个新的画布 。这也是为什么说，容易把 CL-6 层等同于产生层叠上下文的层，但是不是的， CL-6 是描述自己作为子元素的层级 ，而“产生层叠上下文”描述的自己作为父元素的行为。 opacity 且 z-index: 0。位于 CL-3，产生了层叠上下层文，但是其实层级很低，z-index 是无效的。 CL6: relative 且 z-index: auto。位于 CL-6，产生不了层叠上下文，其子元素如果有更低的层级，可能会被盖掉。子元素有更高的层级，会盖掉别人。 CL6: relative 且 z-index: 0。位于 CL-6，产生不层叠上下层文，其子元素层级和当前元素严格一致。 理解了这一点，可以记住。在做目录头时，并不是设置了 relative 就万事大吉了，如果你的后面的元素也是 relative，很容易被覆盖。 z-index 划分 考虑到我们不可能把所有画布内元素全挤在 CL-6，全靠 DOM 关系划分层级，因此需要设计 CL-7 的层级，也就是正 index 区域。 正 z-index 的画布内元素应处于同一个层叠上下文内。如果不在同一个，则按产生了新的层叠上下文设计。 基础逻辑 对于一个画布（层叠上下文）内，我设计新产生的画布设计上分100层。对应 z-index 0（CL-6）到 z-index 100。每 20 层为一个全屏大画布，比如 Modal。也就是 0-20：画布内组件层级 20、40、60、80、100：新画布层级 那 21-39 有什么用？ 没有用，不要用 。只是为了提醒你，这个东西是个大画布。如果把画布内组件设定到了 20 以上，你可能就不知道什么东西溢出到了 Modal。 此外，如果真的想做一些在不同层级上换来换去的小组件，也可以根据模型的定义很快决定放到哪个层级，非常方便。 海浪模型 想象一个海星被 5 层海浪（大画布）冲到沙滩上，每一层海浪上有自己的生物群。 大部分生物都挤在海底（0层以下）层，形成了基石。到第 0-19 层有一堆小东西争先恐后地彰显存在感，但是你又觉得不那么重要。之后的20层、40层、60层通常而言清澈透明，但一旦染色后，就会将下面的生物变得不见天日。 此时你觉得这个海星，你应该看到它吗？应该放在哪一层？ 通常而言，层级设计遵循以下基础逻辑。 大尺寸元素的层级低小，小尺寸元素的层级高。 重要性高的层级高。 第一条是一个视觉规律，第二条则是功能需要。 0-19 层 根据基础的逻辑，0-20 层我会如下划分。 移动端菜单栏 -> 中偏小，重要，9 浮动按钮 -> 中偏小，但不重要，5 侧边栏 -> 大，但重要。你很难说和浮动按钮哪个在上面。这两个要权衡一下，给到 4。 Hover tips -> 小，重要，19 如果 Hover tip 也可能本身是一个交互丰富的大画布，这时要看重要性。如果重要性与 Modal 相当，设到 20（新一层海浪）。如果只是随便看看，共享当前层的主要内容，只是覆盖一下正文，设到 0 或 1。大画布谨慎设置中间值，容易造成混乱。 目录头：暂时一下冒头，给到 0（注意是 z-index:0，不能是 z-index:auto） 拖拽：暂时冒一下头，给到0。 在海浪模型里， 带 9 的数字被表示为重要，而整十数表示为新的起点 。 20、40、60层 几乎为 Modal 层。通常页面上只会出现一个Modal，20 层足够使用，或者你要设置为40，60，都可以。如果你有很多层 Modal 要排序（窗口管理）。要么从 z-index 入手，要么从 DOM 结构入手。显然，别去动 DOM 结构树，靠 z-index 足够完成窗口层级管理。 最重要的海星 这个海星如果你认为是稀世珍宝，任何时候都需要被看见，请直接设置到 999。但一旦，你认为它有可能会被覆盖，请思考它被覆盖时，是不是还是这么重要。 如果不确定，参考基础逻辑： 面积越小通常越重要 。这不是一个我定义的规则，而是客观的视觉逻辑。面积越小，通常代表了信息量越密集。一个很常见的对比是： Hover tips（小面积）：在一个层非常非常重要。但需要被新画布覆盖 消息通知（中小面积）：重要吗？超重要的，但是消息通知上是不是还是应该可以 Hover 一些提示？ Hover reference（大面积）：比如参考。重要吗？很重要。但是你觉得需要被消息通知、进度条覆盖吗？需要。 天空层（1000+） 总有些东西，你希望他们不要在海浪里浮动，而浮动在天上，不被任何东西覆盖。比如全局进度条、全局 Hover、全局消息。 放在天空的这点问题本身不大。最大的问题是，你觉得这个海星，应该放在海浪还是天空？ 不要让本该在海里的海星升天 。一旦你觉得这个海星会被新逻辑的 Modal 覆盖，请让海星立刻返回 0-19 层。 为什么要思考海浪模型 易于复用：对于可复用的浮动组件，不管其父元素的 CL 层级，总能被安插到正确的位置。如果发现异常，那就是忘了使父元素产生层叠上下文来包裹他 避免混乱，减少设计的心智负担","tags":["前端"],"description":"z-index 只是个插件，层叠上下文才是真正的 z 轴","keywords":["z-index","层叠上下文",""],"date":"2026-01-06T18:20:00.000Z"},{"id":"2025-12-30-Better-Web-Typography-for-a-Better-Web-Chinese-Version","title":"Better Web Typography for a Better Web 中文版","content":"这是一本讲网页排版的书籍，书中内容有在线示例与代码，是这么多年来对我极其有用的平面设计书籍之一，说是我的排版启蒙也不为过。此博客的采用的正文排版均构建于此书所介绍的基础上。 书名：Better Web Typography for a Better Web 译名：更好的网页排版，造就更好的互联网 此书为 90% 的 AI 翻译，完全保留原书排版，由人工校对以确保大部分用词统一。 推荐语 2018 年，我还在大学社团做海报，那时候对排版的理解更多是靠“直觉”。直到接触到了 Matej Latin 的网页排版公开课，也就是这本书的起源。课和中提出“排版的完美等边三角形”——即字号、行高与行宽之间的动态平衡，以及“模块化比例”的概念，彻底改变了我观察网页的视角。我至今铭记在心：“要获得完美的段落，需要三样东西：字体大小、行高和行宽。它们需要达到平衡。” 从那以后，这三要素就成了我做阅读文字时绕不开的底层直觉。每当我看到一个网页，总会下意识地去拆解它的文字比例是否协调。尽管此书以英文为基准，其中的排版规律对多种语言均适用。 虽然这本书写在八年前，在互联网平面设计风格迭代如此之快的今天，它讨论的核心规则却依然稳固。甚至可以说，如今主流的网页排版方向，就如书中的所言。如果你想摆脱“凭感觉”排版，真正理解排版的美学逻辑，倾情您阅读推荐这本书。 简介 Better Web Typography for a Better Web 是一本源自高分在线课程的著作，旨在向网页设计师和开发人员等网站构建者讲解排版。作者 Matej Latin 将垂直节奏（vertical rhythm）、模块化比例（modular scale）和页面构成（page composition）等复杂概念，以通俗易懂的方式进行了深入浅出的解析。本书配有实时代码示例，读者在阅读过程中将亲历设计并构建一个示例网站的完整流程。这是一本针对新媒介的排印新书：基本规则虽未改变，但除此之外的一切都已焕然一新。 摘录 “……如果说我希望你们从这次演讲中记住一个关键要点，那就是以下内容——要获得完美的段落，需要三样东西：字体大小、行高和行宽。它们需要达到平衡。” 大多数网站都会犯的一个错误，就是将主体文本设置得过小。早在21世纪初，将主体文本大小设置在大约11像素是常见的做法。但当时的屏幕更小，分辨率也较低，这意味着11像素的字体在当时看起来比现在更大。 推荐文本行长度为45至75个字符。需考虑所用语言的平均词长。 我认为，我们开始创建网站时，首先应该审视网站的主要目的。不仅仅是我们正在设计的特定网站，而是其真正、根本的目的。我指的是—— 内容 。试想，没有内容的网站是什么？它是一个空壳。内容糟糕但外观精美的网站是什么？它就像一个外表好看但缺乏个性的人。那么反过来说呢——内容出色但外观贫乏的网站？它就像是一个个性鲜明、趣味十足的人，却因为“外表不够标准”而无人关注。 资源链接 CloudFlare - R2 直链下载： 更好的网页排版，造就更好的互联网 - Matej Latin 标签： 排版，字体排印，平面设计，网页设计","tags":["教程","设计","blog"],"description":"我的排版启蒙书","keywords":["平面设计","排版","网页排版","字体","网页设计","字体排印","epub","电子书","资源","下载"],"date":"2025-12-29T22:10:00.000Z"},{"id":"2025-07-24-embed-python-with-uv","title":"uv 管理 conda 项目依赖","content":"conda 的问题 Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。 conda 的问题在于 requirements.txt 全手写 ！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。 依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python 发了论文和仓库就跑的项目是很多的。安装一个旧项目导致之前安装 numpy 被卸载，然后整个项目就垮掉。这种情况相当之多，又解决两个小时的依赖问题。 （至少我不愿意看到）电脑里十几个相同版本的 torch 和 cuda。当时的硬盘还只有 256G，多装几个 torch 无法接受，嗯…… 直到现在都还是这样的，大家主打一个能跑完实验就行。包的更新是激进的，包管理是落后的。在几年前有人说用 PDM，后面有 poetry。这两是不用再手写 requirements.txt 了，依赖也会自动 resolve 不会覆盖来覆盖去的，但还是会装十几个 torch。直到 uv 开始用硬链接进行包管理。 uv 之于 conda 项目 uv 接管 python 界的依赖管理按理说已经没什么问题。但实际情况是，很多项目还是在用 conda。除非哪天 torch 和 HF 都把 uv 设置为首推，否则就得一直与 conda 存在的问题战斗。 1. 不提供 venv 的项目 用于研究的项目一般都是不提供的打包好的环境的，主要是太大了，每个人设备情况也不一样。所以下载后第一件事是 uv venv ./.venv/Script/activate 如果这个项目不再更新了，或者是打算迁移到 uv，可以直接使用 uv 的方式管理依赖。uv 会自动维护 pyproject.toml 和 uv.lock 文件。 uv add -r requirements.in -c requirements.txt 如果这个项目，他还在更新，你时不时就得去拉一下分支。这时候最好用 uv pip 。至于依赖混乱问题，听天由命吧。 跑得起来就得了 uv pip install -r requirement.txt 2. 提供 venv 的项目 提供 venv 的项目通常是给人用的，b 站的整合包一大堆。这种已经配好环境的项目也意味着你最好只用 pip。通常还是非常原始地调用 pip ./.venv/python -m pip install xxx ……等于说又开始了安装十几份 torch 的依赖管理模式。用 uv 是可以重复利用缓存的。这个时候 uv 的问题在于无法接管 python 环境，需要设置一下环境变量： export UV_PYTHON=\"./.venv/python\" uv pip list 然后就可以利用 uv 的缓存了。 当然，依赖混乱问题使用 uv pip 是无法避免的。这对于发行版也是一种麻烦。因为发行版的环境全给你配好了，但有的项目设计了插件系统，插件系统又需要装插件的 requirement.txt，安一个许久没更新的插件让主项目废掉的情况也不是不可能…… 如果让插件作者指定的兼容版本？只靠规范做不到，必须像MC那样检查版本号，不更新版本号就不放行。这样就算不更新代码了，也得倒逼作者每个版本都进行一次（至少是与主项目的）依赖兼容性测试。 我觉得以当前 python 的运行方式，不 lock 子依赖的版本，这个问题是没法解决的。 uv 管理 torch 下载源 通常而言，在不指定 index 时 uv add torch 是去 pypi 或清华镜像源找 CPU 版本。如果打算每个项目都采用一样的 torch 版本 和 cuda —— uv 创建的新项目 共用的 uv.toml 指定下载源。 Linux 在 .config/uv/ 下，Windows 在 %APPDATA%/uv/ 下。 [[index]] url = \"https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/\" default = true [[index]] name = \"pytorch-cu128\" url = \"https://download.pytorch.org/whl/cu128\" explicit = true 项目级别的 pyproject.toml dependencies = [ \"torch==2.7.1\", \"torchvision==0.22.1\", \"torchaudio==2.7.1\", ] [tool.uv.sources] torch = [ { index = \"pytorch-cu128\"}, ] torchvision = [ { index = \"pytorch-cu128\"}, ] torchaudio = [ { index = \"pytorch-cu128\"}, ] 然后执行 uv sync 安装。 uv pip 管理老项目 直接指定命令行 的 --index-url 和 --torch-backend uv pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126 --torch-backend=cu126 和用 pip 的方式差不多，区别是会硬链接到集中的缓存，不会重复占用十几份 torch。当然。该有的依赖冲突还是会有的。 关键是装好后就不要更新了","tags":["python"],"description":"沐神都解决不了的……","keywords":["python","包管理","uv"],"date":"2025-07-24T12:12:32.000Z"},{"id":"2025-07-12-compare-css-solutions","title":"踩了一圈 CSS 构建方案的坑","content":"css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……） CSS类复用粒度 我自己把 css 选择器（类）的复用粒度分三个层级。 组件类 粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字 .wrapper .container .list-item 组件化的选择器下面通常有很多条的 css。 功能类 通常是共用的样式或状态，比如 .open .close .light .dark .glass-effect 这个看起来好像和组件类不冲突，但硬说的话组件类其实应该是这样 .container.open { 此处将 .open 的所有样式全覆盖 } .container.close { 此处将 .close 的所有样式全覆盖 } .container.light { 此处将 .light 的所有样式全覆盖 } .container.dark { 此处将 .dark 的所有样式全覆盖 } 组件类的状态严格在组件的 scope 下。功能类则是可以不限 Scope 的复用。 这 CSS 容易混乱的根源。在工程维护角度，功能类是最不敢乱动的类，不知道动了后哪里样式就会出问题。但在设计角度，用功能类复用一些状态又确实很方便，统一设计也好用。比如增加统一的圆角、描边、阴影样式。 功能类的优缺点是一体两面——图像的只有主观的好看与否，没有客观的对错。 原子类 定义海量常用的基础样式类，在 class 上直接写类名就能获得对应效果。就是 tailwind css。 原子类相较于功能类粒度更小，也不会轻易改动 css 属性。 .flex .col-1 .text-sm 方案 通常来说，一个库的样式会着重在一个某一个粒度上。 原生 css 用原生 css 时通常会以 组件化 的粒度为主，带极少的功能类。现在配合 css 变量使用。早期的网页简单，一个 CSS 文件就能搞定全站，设计上并没有考虑项目变得越来越复杂后的实践。 优点 ：性能好，扁平的结构利好小项目。适合写研究新样式。 缺点 ：过于扁平，大量工程化后易屎山，存在样式与 DOM 分离带来的维护混乱。 SCSS 古法预处理器，可能多层嵌套 css，可组合。是 组件化 的粒度。在 CSS.module 出来前，用 SCSS 分割 Scope 挺好用。 优点 ：结构非常清晰 缺点 ： 编译后的选择器很长一串，从浏览器渲染角度，匹配DOM是耗性能的 难以应对复杂项目 DOM 结构的改变，需要考虑扁平化 + 命名，但这样做和原生 CSS 的维护体验也不相上下。 CSS Module CSS Module 是完全 组件化 的粒度。相比起 SCSS 的样式与 DOM 分离，CSS Module 为组件内部样式耦合，组件间样式分离。 优点： 在组件粒度分割合理的情况下，清晰易维护。 缺点 ：依赖预构建，写类名写起来太磨叽了。整体我用得不多没法评价。 const Button = () => { return ( &#x3C;button className={styles.button}> Click me &#x3C;/button> ); }; BootStrap 组件化 为主，少量原子化修饰的预制样式库，拿来即用是不错的。早期 CSS 框架大多是指预制样式，和预构建的库有本质区别。 Tailwind css 完全原子化的神奇之库，通过编译可以有功能类和组件类。它更像是重新定义了 css 语法。 优点 灵活，快，好看 工具链齐全，可以裁剪掉不用的原子类。 缺点 稍微要写复杂一点的样式，DOM 就会被一大堆 class 埋没。 从浏览器渲染角度，匹配、合并大量 CSS 样式是需要更多性能开销的 要做到同种样式的复用，必须组合原子类，变成功能类或组件类，否则维护起来相当麻烦。这似乎违背了用 tailwind css 的初衷，熟悉了 css 的不如直接自己用 css 手撮功能类和组件类。 其实我是 tailwind 黑，嗯。但无法否认开发时确实很快很方便。 function Card({ title, description, imageUrl, imageAlt }) { return ( &#x3C;div className=\"max-w-sm rounded overflow-hidden shadow-lg\"> &#x3C;img className=\"w-full\" src={imageUrl} alt={imageAlt} /> &#x3C;div className=\"px-6 py-4\"> &#x3C;div className=\"font-bold text-xl mb-2\">{title}&#x3C;/div> &#x3C;p className=\"text-gray-700 text-base\">{description}&#x3C;/p> &#x3C;/div> &#x3C;div className=\"px-6 pt-4 pb-2\"> &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#photography&#x3C;/span> &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#travel&#x3C;/span> &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#adventure&#x3C;/span> &#x3C;/div> &#x3C;/div> ); } 原生 css in js 指 JS Object 转译为 CSS。由于写起来太不像 CSS，复杂的功能写起来过于不直观 ，我直接 PASS。 const InlineStyleExample = () => { const myStyle = { color: 'blue', backgroundColor: 'lightgray', padding: '10px', borderRadius: '5px' }; return ( &#x3C;div style={myStyle}> &#x3C;p style={{ fontSize: '18px', fontWeight: 'bold' }}> This text is styled with inline CSS. &#x3C;/p> &#x3C;/div> ); }; Styled-components 组件化 的 CSS in JS 方案，写起来像 CSS 实际是 JS。支持客户端动态修改 CSS 具体属性（其他方案做状态改变主要依靠 selector 的匹配） 优点 ： 灵活好拓展，比如主题管理不仅仅是颜色，还可以是图片资源一类的。 缺点 ： 因为是 JS 转 CSS，服务器编译慢和客户端渲染慢得选一个 React 的 useContext 要被废弃了，而 styled-components 严重依赖此 hook，导致进入了维护状态。JS 框架发展太快了。 import styled from 'styled-components'; // Create a styled button component const StyledButton = styled.button` background-color: blue; font-size: 16px; padding: 10px 20px; border-radius: 5px; &#x26;:hover { background-color: darkblue; } `; function App() { return ( &#x3C;div> &#x3C;StyledButton>Click Me&#x3C;/StyledButton> &#x3C;/div> ); } Linaria 自定义 功能类 的 CSS in js 方案，同时也支持 组件化 写法。生成的是完全静态的 css，样式值的复用靠变量，片段的复用靠 css 生成的类。 优点 ： 是预构建方案，在服务端渲染。和原始的 CSS 写法和思路差不多。 缺点 ： 值复用靠变量，但是由于是 静态 css ，这个并不会变。所以变量插值 其实是常量 。比如下面的 font-size 并不会变化。 const fontSize = 16; const Title = styled.h1` font-size: ${fontSize}px; ` 也就是说，你如果想在客户端随意改变字体，用 context/zustand 这种 runtime 的 fontSize，这样写报错。不过，Linaria 允许你借助 react 的 props 和 styled 组件来实现客户端的值变化。 const Title = styled.h1` font-size: ${props => props.size}px; ` export default function MyComponent() { const fontSize = useAppStore(state => state.fontSize) return &#x3C;Title fontSize={fontSize}>Hello&#x3C;/Title> } 相当于生成 &#x3C;h1 className=\"_title_xyz\" style={{ '--linaria-font-size': `${size}px` }} > 那这和 styled-components 写起来已经差不多了。而且要做主题化的值都得用快要废弃的 useContext API。只不过 linaria 改的 style 属性，styled 是改的 css API。改 style 属性其实已经不能算静态了。 组件间的 样式复用方案 只有原生的 CSS 方案，上述的奇妙客户端插值做不了这个需求。假设，你要做一个主题化的对话框的卡片阴影，只能使用原生 css 类中加原生 css 变量。上述动态改变样式的因为依赖 props，只能使用 styled 的写法，但这样就会把 html 标签了也继承了，不同的样式也无法随意组合。这也是为什么我说 Linaria 是原生 css 的替代，而不是 styled-components 的替代，构建方式就决定他们差得太了远。 基于2，导致你写组件又要检查 styled 又要确认 css 类又要检查 JSX classname 的顺序。如果用组件继承会被迫连 DOM 类型都继承。 使用功能类有点像原子化，又完全不如 tailwind 已经给你预设好一堆东西的效率。写类名和 cssmodule 一样，太磨叽了 我博客本想迁移至此方案，但由于工作量实在巨大而放弃。linaria 主要还是解决了个命名空间冲突的问题，想用得更深入一点就会四不像。 import { css } from '@linaria/core'; const eleStyle = css` color: red; font-size: 3rem; &#x26;:hover { color: blue; } `; function App() { return &#x3C;h1 className={eleStyle}>Hello Linaria!&#x3C;/h1>; } export default App; 构建组建库 每一个 CSS 方案都有对应的构建组件库的实践。 shadcn 是基于 tailwind 构建组件库实践。 CSS 框架选择要素 样式复用 样式组合 动态样式 主题切换 代码提示 自动裁剪 随意重构 渲染性能 实践的统一性 最重要的还是自己的需求。","tags":["CSS"],"description":"前端代码中质量最薄弱的一环","keywords":["CSS","SCSS","Bootstrap","tailwind","styled-components","Linaria"],"date":"2025-07-12T04:49:09.000Z"},{"id":"2025-04-22-techs-about-steam-crack","title":"Steam 假入库是怎么做的","content":"很久以前被淘宝的 Steam 假 CDKey 给坑过，因为价格其实也不便宜，打的正版宣传，其实是盗版，后来感觉太可疑了查了一下确认被坑了。现在突然想起来了解了一下。本文概述是日常语境中的 “Steam假入库”需要的一些步骤，概括起来为五个方面：解锁、下载、入库、DRM、API验证。 下载验证 steam 的下载鉴权流程是 查找账号是否有拥有此游戏，有则显示下载按钮 点击下载后，把游戏软件 Manifest 对应的密钥（DecryptionKey）明文写入一个本地文件 Steam\\config\\config.vdf Steam （原版）根据 config.vdf 中的信息，发送下载请求至 Steam CDN 进行下载 “Steam 解锁” “Steam 假入库” 指的是绕过上述机制。具体而言，如果没有购买游戏，可以： 将按钮变为可下载（至于是伪造请求实现还是逆向 hook 实现，我不知道，都可以，因为甚至不需要变按钮，给个外部的下载按钮也可以） 点击按钮后，从不知名渠道获取一个正版账号的 Manifest（下载清单）和 Decryption Key（下载密码），写入 Steam\\config\\config.vdf Steam（原版）根据 config.vdf ，发送下载请求至 Steam CDN 进行下载 Steam 的下载验证可以说是相当简单，明文本地存密码，CDN 无状态的验证，这么多年没有改过流程，给入库工具空间（虽然说前端的事总有办法 Hack 但也是可以让 Hack 成本变高很多的）。不过 Steam 理念本来就是以平台服务留住玩家的，反倒是扩大了其影响力与营收。 一些名词解释： 解锁：指对没有购买的游戏，“可以显示下载按钮”。和能不能下载没有关系。 下载：Steam 根据 Steam\\config\\config.vdf 的信息下载游戏文件。 入库：指把下载好的游戏，在当前电脑的 Steam 库中显示。 以上过程均不涉及对游戏本身的破解，只是对 Steam 下载过程的破解。也就是，破解的是 Steam，不是游戏。 运行时验证 这里开始才会涉及到游戏破解。 有的 Steam 游戏下载下来后是不用破解的，直接找到游戏目录，点 exe 可以正常游玩（比如星露谷）。只是无法通过原版 Steam 打开，也就只能离线。 有的游戏是无法脱离 Steam 直接运行的。这里涉及两层验证： 加密算法层 这是一层 DRM（数字版权加密保护）。Steam DRM 系统的名称为 SteamStub。SteamStub 的加密有各种的变体，每个游戏使用的不一致。只对 exe 的算法加密，是一个离线的步骤。不涉及 Steam 平台的验证。 网上有一个开源工具叫 Steamless，可以破除 SteamStub 对游戏的 DRM，称为脱壳。但脱壳本身不处理 Steam 在线验证相关，只进行了脱壳的游戏也是无法正常游戏的。 SteamStub DRM 和 Steamworks API 是两个独立层。Steamless 仅移除 SteamStub 加密外壳 ，但游戏代码中与 Steam 平台功能（如成就、云存档、联机）相关的 API 调用（通过 steam_api.dll ）仍会保留。 Steam API 验证 游戏还可能调用 Steam api 进行在线通信，如成就、云存档、联机相关的 API 调用。 这是使用入库工具玩破解游戏可能被红信或封号的根本原因，因为对 API 的调用是发送到 Steam 官方服务器的。在小红书上了解到，有的玩的盗版可以与正版联机，说明 Steam 在联机时并不会验证账号是否拥有该游戏。包括 Steamtools 实现的家庭共享联机，也说明了 Steam 对于是否账号可以进行联机鉴权不足。但只要留有记录就有可能导致被封号，取决于 Steam 什么时候想管理盗版现象。 反之，如果伪造一个 Steam 的服务器，并且替换游戏中的 Steam 相关的动态链接库，如 steam_api.dll ，游戏里所有对 Steam API 的调用被发送到假服务器上，返回一个假的结果。这种工具也已经有了，项目为 goldberg_emulator，简称 GBE。破解版的游戏通常会内置一个这样的虚拟 Steam 环境。 第三方厂商验证 很多大厂的游戏有自己的联机服务器和验证机制、不仅走 Steam API 的验证。这种也是可以通过虚拟环境破解，但没人做，除非专门对这个游戏的所有 API 做逆向。难度比逆向通用的 Steam API 高很多。 Steamtools 是什么 已知 Steamtools 主要是做 解锁 和 入库 。对于会不会破解游戏，网上没有更多的信息。我也不想冒风险尝试使用它。 根据官网的解释，Steamtools 可以离线运行（不如说破解游戏只能是离线运行），是提供了类似 GBE 的验证环境。有没有对 DRM 脱壳不清楚，但个人倾向于有，很多游戏都有 DRM 的保护，除了 SteamStub，还有其他的 DRM 验证方式，不脱壳玩不了。 因此个人推测是，Steamtools 是集 解锁、下载、入库、破解、运行时验证 为一体的工具集。 SteamAutoCrack 是什么 只做 DRM 脱壳和 Steam API 验证。项目在 Github 上，破解后的游戏会运行在 GBE 的环境下。这种方式是完全离线运行的单机。 风险来源 完全脱离 Steam 运行没有风险，只要在线就可能有风险。 假入库阶段的风险主要来自于入库工具对 Steam 请求拦截的覆盖程度不足。例如 Steam 版本更新了，使得 API 和下载流程有变化，而入库工具没有对其做处理，无法完全欺骗下载流程。网上看到假入库的人可能有囤积癖或者是打算做灰产，一次性入库了几十个游戏，直接导致被 SteamCDN 拉黑。 运行时的风险也是来自于在线验证，如果是开着 Steam 玩的破解游戏，没有离线时甚至尝试联机，使得游玩信息发送到了 Steam 的服务器（比如不该有的存档、不该有的联机等等）。 另外，入库工具会侵入式修改 Steam的客户端，直接打开 Steam 可能会有检测文件是否被修改。 Steamtools 提供了三种启动模式，可以随时恢复为原版 Steam 的运行。但淘宝卖的入库工具说不准是什么样的，当年骗我的店家那个用的是早期的 steamtools，使用店家的账号下载游戏后，使用 steamtools 离线运行（本来已经忘记了，努力想想竟然想得起来一点细节）。但现在的店家说不准是什么样的，在 B 站看到说有的是直接修改文件，从此都是盗版Steam 客户端，只能卸载重装。 没有风险的方式：如果你有方式得到 Steam 正版的游戏文件，然后用 SteamAutoCrack 破解，能直接脱离 steam 运行则没有风险。 对于更多的人而言，下载木马是最大的风险。 参考资料 bbs.steamtools论坛 SteamManifestCache wiki SteamLess Readme","tags":["游戏"],"description":"入库不仅仅是入库","keywords":["steamtools","steam-auto-crack","gbe","Steam假入库"],"date":"2025-04-21T19:59:00.000Z"},{"id":"2025-04-19-windows-context-menu","title":"Windows11 右键菜单自定义 - NileSoft Shell","content":"（发现简中圈居然没有人写这个事，写个草稿发别的地方） Windows11 右键菜单问题被诟病已有，网上很多还原为 win10 菜单的教程……但 win10 有 win10 的问题，有用的没用的都往里放，常用的不常用的混在一起。有没有一种方法可以兼顾好看，同时有合理的菜单层级呢？ 有的 —— Nilesoft Shell。可以自定义的 Win11 右键菜单。已经用了两年多了很好用（以至于差点忘了有这个软件）。 下载并安装 下载在官网： https://nilesoft.org/ 安装完后，新菜单应该已经生效了，并且会开机自启。这时候可以点点看，如果感觉效果满意就不用再看下去了。 当然颜狗是不满意的，大部分一级菜单我用不上，我只想保留我常用的，不用的塞到更多选项。如图 挪动菜单层级 如果你是默认安装， C:\\Program Files\\Nilesoft Shell 应该能看见以下的文件结构 Nilesoft Shell/ ├── shell.exe ├── shell.nss ├── imports/ │ ├── modify.nss │ └── ... └── ... 以 .nss 结尾的是配置文件，可以用记事本打开。以下是几个案例： 1. 收纳不常用菜单至 “更多选项” 例如，收纳所有名称里带有 “QQ” 和 “百度” 的菜单项，在 modify.nss 添加如下： modify(mode=mode.multiple find=\"QQ|百度|网盘\" menu=title.more_options) find 中包含的字符串会被匹配，“|”是或。表示匹配“QQ”或“百度”或“网盘”的任意项都会被挪走。 这是主要的挪菜单的方式，我实际上挪了一大堆。 modify(mode=mode.multiple find=\"收藏夹|打印|共享|PowerRename|Microsoft Defender|Change Attributes|File Locksmith|upic|火绒|百度|QQ|Acrobat|Adobe|OneDrive|在沙盒中运行|PicList|旧版 Windows Media Player\" menu=title.more_options) 2. “创建快捷方式”挪到顶层 有人可能看不惯 创建快捷方式 放在了 更多选项 里。要恢复把 modify.nss 中一行注释掉就好。 modify(mode=mode.multiple where=this.id( id.send_to, id.share, // id.create_shortcut, 这行注释掉 id.set_as_desktop_background, id.rotate_left, ... 3. 顶层添加新菜单项 “使用 vscode 打开” 在 shell.nss 中，新起一行添加 item(title='Open with VS Code' image=[\\uE272, #22A7F2] cmd='code' args='\"@sel.path\" &#x26;&#x26; exit' sep='top') 添加的这行可以不在最后，添加的位置决定它在菜单中的位置。我添加在了中间，最后的几个 \"import\" 之间。 要是问为什么我不用 vscode 自带的右键菜单……我的 vscode 装得太早了，那时还没有右键菜单关联，现在也懒得再装了就将就用吧…… 4. 顶层菜单添加新目录 你要是在图片上右键，会发现系统自带有“使用 Windows 画图编辑”“使用照片编辑”“向左旋转”“向右旋转”……我的天，哪个天才设计的，你不知道自家照片 App 打开后能编辑也能旋转吗？（我知道这肯定是两波人开发的但还是想吐槽） 秉持着只挪不删的原则，在“更多选项”前加了个“编辑”目录。以下加在了 shell.nss menu(mode=\"multiple\" title=\"编辑\" image=image.glyph(\"\\uE0A1\")) { } 然后在 modify.nss 里加了 modify(mode=mode.multiple find=\"*编辑|旋转|PDF\" menu=\"编辑\") 这样等于说，编辑和旋转相关都被归到了新的“编辑”目录下。加上 PDF 相关操作挪进去。我没有装 WPS，装了 WPS 也可以把 WPS 挪一个目录。 生效 管理员权限运行安装目录下的 shell.exe ，点 Register 生效 其他 按 shift 后右键菜单，会有一个“Developer” 目录。没错 shift 显示隐藏菜单也可以实现，配置的属性有 vis=key.shift() ，但不是实时变化的所以没有mac 上的好用。除此之外还有喜闻乐见的能配置主题、颜色、图标等……我不管了。 参考 官网的文档很详细，但是非常面向程序员。不过大部分的需求被人在论坛上问过了，也有人在 issue 里问。不会就去论坛翻一下。看不懂英文开翻译，看不懂文档丢给 AI。 文档： https://nilesoft.org/docs 论坛： https://github.com/moudey/Shell/discussions","tags":["Windows"],"description":"颜狗就是得样式和功能性全要，怎么了","keywords":[],"date":"2025-04-18T17:21:04.000Z"},{"id":"2025-01-05-2024-summary","title":"2024 年的总结与分享","content":"印象中之前每年其实都有写去年主要干了什么，看了什么作品。但又忘了都写在了哪里。今年想起来还是在这里写吧。 主要说说看了些什么吧。 实用小技术 无线 iPad 当作电脑副屏 某天突然想躺着用手柄玩电脑的游戏，所以 sunshine + moonlight(iPad) 串流。效果非常不错！ 便携显示屏 后面，我又嫌无线的码率不稳定，组装了个便携显示屏，变成了躺着用电脑副屏……配件全部拼多多的。 显示屏，京东方 NV156FHM N69 驱动版、按键板、软排线 外壳、音响 新的代理协议与客户端 今年对于魔法上网，非常重要的事情就是去年年底 clash-core 删库。不过也正好，促使我看看有没有人设计新的协议。 协议方面尝试了 hysteria2 和 naive，测试下来已经把 hysteria2 当作主力了。顺便读了下 http2 rfc7540 和 http3 rfc 9114 （但现在又忘了！） 客户端试了 singbox ，在 ios 上替代了 shadowrocket，性能好非常多。电脑端 GUI 是典型的后端程序配置的思维，很难用，还是用 clash-meta 系列了。 单机游戏 Getting Over it (掘地求升) 我的天，有生之年我居然打通了这个8年前的破游戏！ 打通的那一瞬间，我感觉觉得自己已经可能面对任何困难无所不能了。但是山顶的聊天室早已空无一人，有一点寂寞。 博德之门3 tga 2023 年度游戏，不好玩。去年买了，今年和 meme 大师与墨墨联机了好几次，还是玩不下去！打架打一局太久了……而且打不好还要 SL……补药啊！（后面没法联机了其实主要是因为我作息太乱了） 双人成行 2021 年度游戏，好玩，这个还是感谢陈 sir 陪我打完了，而且因为他是全成就大师所以我也跟着全成就了。因为我竟然买了两年都没有玩，显得特别可怜…… Tiny Glade 新出的休闲建筑游戏，最不像游戏的游戏。建筑方式新颖，而且好好看哦！ 玩了后做了个视频，竟然被 HR 联系了……差点当诈骗私信…… 动物森友会 到今年才打开这个几年前的游戏。建岛是好玩的，画风也可爱，但因为手游也有在刷，对于刷刷刷的都有点疲惫了。 Halo meme 大师带飞的经典 FPS，有剧情，非常好游戏！我只用跟在后面捡各种好玩的枪就好了（不是） 传送门2 十几年前的解谜神作，好丸！多人模式也是 meme 大师带飞的。 Second Eden-理想箱庭物语 这是个新的 minecraft 深度魔改整合包，基于模拟殖民地 mod。我觉得比很多整合包都要好，考虑了流程、循环、引导，有些 mod 加的解谜结构很好玩。但模拟殖民地本身有 bug，加上流程上其实也不是特别完整，只建了一小半。 零大陆 这是个超老的 Minecraft1.8 原版 RPG 整合包。真的非常震撼能做到这个程度，流程设计、地图设计上超级完整……可惜循环有问题，卡在一个冒险模式下的银河城地下区域了。 模拟地铁 休闲小游戏，也是老游戏了，极简地铁规划，最后发现还是开滴滴比较好。内容对得起价格。也因此和喜欢地铁的朋友有聊些城建游戏。 动物井 (Animal Well) 解谜 + 平台跳跃。太好玩了，这才是真正的 2024 年度游戏！！而且只 33 M，性能也超好！是像素美术但是是很现代的赛博梦幻像素美术，好看的！ 传说之下 (UnderTale) 经典日式 RPG，脑洞超大角色有意思，剧情很温暖。是Meme 依据本人的游戏时长与偏好定制的 steam 礼物……非常喜欢！ 动画&#x26;漫画 葬送的芙莉莲 中世纪魔法动画，难得味这么正，不算是我非常喜欢的类型但能看下去。而且作画的流畅程度真的……太有钱了！整体比较日常，很温馨。 蓝色禁区 Blue Lock 足球番，我原以为我不喜欢看，最后根本停不下来……动画第一季做得实在太好了，但第二季是 PPT，1 分都不想给……漫画非常棒，不愧2024 年的日本漫画销冠。 不过我是其实从其中一对 CP 图决定看，结果看完动画觉得这两人麦太多了……不如好好看球！ 异形舞台 Alien Stage 动画音乐剧，讲的外星人饲养地球人当宠物，看人们在舞台上通过选秀比赛相杀的故事。特点是，一集一个寡妇（夫）……太刀了！ 电影 你想活出怎样的人生 宫崎骏动画电影，我觉得依旧很好看，很温暖。 蓦然回首（Look Back） 藤本树动画电影，讲普通画画人的故事。非常牛美术风格。尽管我不是画画人，也没有很好的画画天赋。但也有一些感受有经历过，日复一日练基础，什么时候都在考虑画画…… 以及藤本树居然开始走治愈系了！ 志愿库 - 存亡之战 怎么突然出现了国庆战争片……这个真的拍得挺好的，算是近年陈凯歌的不那么扑的了。以及我有朱一龙演技滤镜，在超烂低成本不被任何人看好的改编网剧里，因为演技太好而突然红的，真的没得说。 名侦探柯南 - 黑铁的鱼影 和雨疏的年度固定节目，不错的粉丝向主线剧场。真好啊真好十年后还在和她一起看柯南。 音乐 年度歌手还是 Radwimps，基本老歌。上半年没怎么听 年底听 4 块钱的直播，才发现日系真是年年有天才。「晚餐歌」真的很厉害。原来不是我不喜欢听歌了，是没关注到好听的歌了，网易云日推越来越不行了，一直推各种时下 OP ED。 技能相关 游戏，给 MC 服务器写了 彩虹帽子 数据包。想来这其实是第一次和游戏有关的编程，经典入口是帧更新 tick()。 画画，学了平面设计的课，作业也很肝完了，有一些收获。然后又看了些曼奇的网课，素描关系有提升，就是增加了短调子、空间感、体积感的意识。我之前也不是感受不到，而是没觉得差一点明度就会差很多。这是 Ti - Se 画画相比于 Se - Ti 的劣势，需要有理论后才能画得好…… 原神里头一回赶上音游的版本，写了几首比较难的谱面，这个非常满意，是我自己都可以反复玩的！ 专业相关 这随便吧又没人看。 笔记主题没怎么更，我也用得越来越少了 博客有更新，但忘了！ 新写了个服务器的监控页。 论文挣扎着狂补。 有去接触 GPU 相关的，不想只停留在业务 MVC 再 CRUD。但看了发现没需求的话确实用不上。 公司的相关还是不说了……主要是图形学和，久违的 OOP 编程，新的语言 C#，但长得非常通用面向对象，没有太多的入门门槛。不禁感叹外面世界的语言真是五花八门……但要说写界面好用还是声明式的，OOP 写界面特别过程式就，扭曲，痛苦，但无疑性能会更好。","tags":["游戏"],"description":"怎么全在写游戏……","keywords":[],"date":"2025-01-04T17:21:04.000Z"},{"id":"2024-11-13-懒-快节奏与赛博巨婴","title":"懒、快节奏与赛博巨婴","content":"1 今天我想把一张图从 iPad 传到 iPhone 时，突然感觉很麻烦，因为需要打开并解锁，ipad，打开照片，再点击分享，点击AirDrop。 然后猛然意识到，我是不是越来越懒了？ 对于懒与对于快节奏的追求本质上是一回事，都是简化简化再简化。我对简化的追求似乎有无止境的趋势，也喜欢比对市面上的效率工具，但这真的能提高生产力吗？ 从前拿着U盘传照片，会感叹信息化的便利。我学习计算机也想做让生活便利的事情，在更短的时间去体验到更多原本无法体验到的东西。后来用 qq 传照片，也感觉很方便。是什么时候开始连 AirDrop 都嫌弃太麻烦了呢？是不是对于我，只有意念传输才是终点？可那之后又能如何呢？ 2 生活的意义来自于过程，而非终点。而衡量事物价格来自于终点，而非过程。 毫无疑问，工作、劳动力是商品化的，意义与复杂性从不等于价格。不如说以找寻意义的方式寻找工作，很大程度上会面临吃不上饭。 3 从前会写书信，后来能随时短信联系变得好方便，一个月发几十块的短信。再后来即时通讯工具出来，联络更便宜更方便了，可人渐渐变成了24小时 oncall 状态，隔几个小时不看微信就会被说太慢了。大概一天只看两次微信的已经是异端了。 也许和人有关，微信从一个方便联系感情的软件，变成了生产力工具，是随时随地接受需求的怪物。我起初能理解在微信同时加工作的人和亲人，之后变得难以理解，到现在又变得可以理解，感受是大不相同。从前是四海为友，后来是要把社交分开，到现在是感觉其实都是一回事，亲人不会更特别。 当真的想要放松联络时，就会使用其他软件了。为什么 qq 依然在年轻人中流行？其实就是长辈不用。qq 的用户群有特别老的和特别年轻的，中间有明显的断层。 4 国人非常喜欢开发效率类工具，也喜欢记录。近几年新的效率工具，我所知道的绝大部分是国人在开发。可能与老中整体的环境相关。在我记忆中，如果一件事做得不好，就是要反省的，如果一件事做得好但慢，那就是没有效率。「效率」这个词似乎成为了魔咒。 再加上不要自大、时刻谦逊、居安思危等等，于是养成了无法接受任何夸赞的性格。夸就是客套，真夸就是直冒冷汗。嗯，只要还面对着别人，没有一件事是我满意的。满意的东西现在会小心收藏起来，像 led 屏一样，不要轻易就被弄碎了。 5 人类造就科技成长，但又被科技裹挟，造就一个个被高度封装的便利化包裹的巨婴。从逻辑上说，国内早就已经进入赛博朋克，只是社会形态还没有跟上。 这类抽象思考的空虚感令人害怕，时常觉得早已非人。也可能只是我的个人想法。希望脱离宏大叙事，去做出微小的选择。 想画漫画了，草。 写于2024年11月13日03时15分。","tags":[],"description":"科技为了便利，可便利是否有尽头","keywords":[],"date":"2024-11-13T14:55:09.000Z"},{"id":"2024-11-12-把drawio装修为简单美观的白板应用","title":"把 draw.io 装修为简单且现代的白板应用","content":"draw.io 是一个功能丰富的流程图绘制软件。此前写论文时我一直使用这个软件画图。在没有系统性的画图需要，转而变成了有时想要随手画矢量示意图后，这个软件启动交互流程步骤繁琐，我便极少使用它了。但在使用了 tldraw, excalidraw 后，又回到了 draw.io ，才发现这个软件的可定制性其实非常强，完全能满足随手画图的需要。这里记录一下如何把 draw.io 变成一个更适合打开即用的、默认效果更加现代的白板应用。 （草……windows 截图这边缘的黑框好丑啊！） 为什么是 draw.io 先对比一下适合需求的竞品（不想看请跳转下一节）： visio : 收费，而且 mac 上没有。 tldraw , excalidraw : 更适合作为 sdk 使用，作为成品有些过于简单，在易用的同时，想多做一点非流程图的东西又很复杂，中文字体也不契合其默认的手写设计。而且并没有打包为桌面 App，文件关联是个问题。 processon : 要登录 figma : 要用梯子登录 powerpoint: ……我只是想偶尔画个示意图 飞书: 每30天要扫码登录 ……我只是想偶尔画个示意图 adobe illustrator: 没有常用预制样式库，漫长的启动时间，对于没接触过的人学习成本很高。 无边记、goodnotes: 苹果移动端生态 only draw.io 没有上述的问题，但它由于设计之初不是个草图应用，所以： 默认较为重型的 UI 启动先选择储存位置，太慢了 默认组件样式很丑，看起来只适合工控图 有时会感觉曲线箭头很难调，怎么都不流畅 我根据以上三点问题大致说一下如何改进。 更换UI布局 默认的 UI 较为传统的重型设计，熟悉这类UI是相当好用的，但按钮组过多会显得不够轻便。在 其它→主题→外观 中可以更换为其他的主题，有5套可用：经典、极简、简易、草图、atlas。 我个人用得比较多的是「简易」，并且关掉了左侧栏形状库的栏，改为用顶栏，右侧格式栏在顶部有快速按钮展开。 习惯 tldraw、excalidraw 的用户应该还是更适合「草图」主题，绑定了基础形状的快捷键。需要去手动调出格式栏。 更改启动流程 默认情况下，启动时会弹出选择保存位置的框。新建画布时，又会先看到一大串模板的选择题，还得去想命名。但很多时候，随便画图是不需要保存的。 在经典主题下，需要去「其它」→「显示开始画面」上取消勾选。在其它的主题下，则需要去菜单的「设置」→「配置」里取消勾选「显示开始画面」。 配置默认样式 要做到更改默认样式，需要写 JSON 配置。尽管可以在侧栏按「设置为默认样式」，但只能当前打开的窗口生效，刷新、新开文档都会导致默认样式回到最初的样子。 在经典主题下，需要通过 「其它」→「配置」打开，其它主题下，则是「设置」→「配置」。 我的配置已经上传到 gist 。 JSON 写法参考了如下文档： Customise default shape libraries, templates and plugins in draw.io for Confluence Cloud - draw.io Configure the draw.io editor draw.io 的图形分为 vertex（顶点图形） 和 edge（箭头、线段）两类，选中按 ctrl + e 即可查看当前图形应用的样式。 配色与样式设计 整体采用的粗线条粗体，比较契合现代简约又活泼的趋势。edge 采用黑色，与高饱和的 vertex 非常好搭配。 直接抄的无边记的颜色，有的有轻微的改动。不过无边记最印象化的水蓝色没有抄上去。 默认的配色改为了最后一个蓝色。以下配色均可以在右侧的「格式栏」中找到并应用。 关于圆角矩形 现代设计中圆角矩形用得更多。对于圆角的弧度，可以通过属性 Arc Size 去调整。可以点击设置为默认样式，也可以配置到 JSON 里。 如果你使用的「经典」主题，需要自己选择圆角矩形的图形。在「草图」主题下，按 D 就是默认配置好的圆角矩形，相当简单。「简易」主题下的位置如图： 关于曲线设置 曲线设置不对会变得很难调整，一张图说明大多数情况下的曲线操作与设置： 想更换为手写风格？ 在不选中任何东西的情况下，把右侧格式栏的草图勾选上即可，就可以获得类似 excalidraw 的手写风格啦！ 另外，如果没有自定义 JSON， 「草图」主题下的默认样式也是手写风格的。 关于默认字体（附网页用字号推荐） JSON 中这几个字段设置默认字体。我默认英文是 Inter，中文是使用的系统黑体。文字大小我设置为了网页标准 16px。 { \"customFonts\": [ \"Inter\", \"pingfang sc\" ], \"defaultVertexStyle\": { \"fontSize\": 16, \"fontFamily\": \"Inter\" }, \"defaultEdgeStyle\": { \"fontSize\": 16, \"fontFamily\": \"Inter\" } } 另外介绍一下常用网页文字大小的规范，现代的美术设计由于自己屏幕很大，或者对标准视距缩放大小没太多概念，非常容易把字给设置得很小（点名星穹铁道） 16px 为默认正文大小，但由于主要是考虑了希腊字母面积比较小，所以也有的中文网站会设置为 15px。 14px 偏次级小段落、不重要的文字，长时间阅读会累。 13px 为代码常用大小。 12px 已经非常小了，是正常视距下最小可视大小，适合做脚注、引用。 再小的字号不推荐作为内容性文本使用。 关于背景网格 在简易主题中默认关闭的，经典主题中可以通过配置 JSON 为默认关闭。关掉背景网格会显得比较现代化。 { \"defaultGridEnabled\": false, \"defaultPageVisible\": false } 但还是有时可能需要开启网格，那就什么都不选中，右侧栏开启网格就可以了。 其他使用 Tips 导出设置 导出时注意一下缩放。网页标准大小字体为 16px，编辑时画布 100% 缩放下一切正常。但是当导出为位图（jpg, png）时，需要根据你的显示器缩放进行放大，否则文字一定会糊。 我的显示器为 150% 界面缩放，因此需要缩放到 150% 才能大概清晰，如果要让 4k 屏也看得无比清晰，最好导出 200% 缩放，且 dpi 尽量在 180 以上。 另外可以直接框选后右键复制，不一定要导出。 一个文件画多张图 经常会遇到多张同系列图的需求。为此，你可以选择都画在一页上，要用时框选特定范围，右键复制为 png 。这样很适合边聊天边画图发给别人，但也会失去缩放、加白底、加白边等设置。至少你得打个组，把 16px 的文字放大后再复制，以确保结果不会糊。 draw.io 也可以分页，建议是一页一个图，可批量导出。 从 Mermaid 生成图、嵌入 Notion mermaid 是一种画流程图的代码，比较适合不想可视化排列对齐的强迫症。 draw.io 可以在菜单中的「高级」使用 mermaid 生成图，下面的图就是导入 mermaid 生成的。 由于 notion 无法画图，在 notion 我都是用的 mermaid，有点不好看但至少目的达到了。不过最近发现， draw.io 的导出可以选择直接嵌入notion，点开还能进行编辑……实现方式是图像数据全部存放在了链接里……不得不说 draw.io 自主兼容性做得很强，从接入了那么多网盘就可见一斑。 自定义CSS 如果还是觉得 UI 太丑了，在 Configure the draw.io editor 中可以找到自定义 CSS 的部分（但我觉得 UI 排列上还是不错的，这足够了）","tags":[],"description":"装修无止境！","keywords":["draw.io","白板","whiteboard","figma","processon","流程图工具","草图","矢量图"],"date":"2024-11-11T21:19:03.000Z"},{"id":"2023-09-29-windows-system-chinese-fonts-adjustment","title":"Windows 调整之中文字体","content":"以下仅适用于低于 4k 缩放 200% 的显示器 微软雅黑作为随着 Windows7 出现的字体，加上遥遥领先（？）的 ClearType，在当时的 1080p 显示器上十分清晰易读。 但如今的显示器分辨率越来越高，旧版微软雅黑的设计存在着明显的缺陷。 一是其字形设计并不平衡，中宫过大，有的字形可以以难看来形容；二是微软雅黑字形只在 4K 屏 200% 缩放（以上的配置）上有着较好的显示效果。 微软曾经设计过“另一版的微软雅黑”，即 Noble Scarlet，但并没有在正式的系统中使用。这一版字体设计依然中宫偏大，但相对老版收敛了不少，平衡了一些。 另外，如果你不巧像我一样用着 2K 或 2.5K 屏， 在 24寸时，100% 缩放字体比较合适，但与 16 寸 1080p 显示器差不多清晰度，不过屏幕可用空间更大。 在 21 寸时，100% 缩放字体会偏小，比较锻炼眼睛。150% 缩放字体大小比较合适，效果更细腻，但字型会比较怪，且屏幕可用空间与 1080p 相同。 在 16 寸时，150% 缩放字体稍微偏小，效果比较细腻，但非整数倍缩放+ClearType 的加持下，一些像素被吞掉，笔画的间距不平衡，有种“ windows 特有的字被虫噬的美”。 可以看到，上图的 100% 200% 缩放没有字形变形问题，可以说微软雅黑小字优化是考虑的 100% 缩放。100% 缩放显得糊则是因为图片放大放大倍率过高，实际不会有糊，而是有锯齿感。 150% 缩放会由于 clearType 的“锐化”导致字形变化，不知道的还以为换了个字体。如果是125%、175%的缩放，字体变形更加糟糕。 造成缩放问题的原因大概可以用下图进行简要解释： Mac 上的 Retina 渲染相当于 4k 200% 缩放起步。而 windows 下， 2k-2.5k 的屏幕都在 200% 以下的缩放中挣扎。如果软件没有适配高分屏，没有 clearType，强制进行双线性缩放（常见于图片UI），就会显得非常糊。想体验这样的糊，可以下载旧版的原神启动器。 需要准备 Noble Scarlet 替换系统的微软雅黑。由于 Noble Scarlet 是一个未完成的字体，普遍使用的是社区修正版，以下是资源参考。 pcbeta bilibili 系统字体替换工具：搜索 “ 字体替换工具 by 随风飘扬 ”。替换完后重启，否则可能有缩放错误。另外，github 上有一个非侵入式的系统字体替换工具 noMeiryoUI ，可惜换不全 windows 11，只是作为预览不同字体在系统上的效果倒是个很不错的工具。 MacType 改善 ClearType 的虫噬渲染方式带来的不均匀，使用后提升非常非常大。 思源宋体 ：推荐将浏览器的 Serif 字体设置为此字体。默认的宋体真的，不论中文英文，都很丑……只适合打印。 常用正文黑体简述 苹方 苹方是一款设计上很优秀的字体，其间架结构、中宫非常平衡，既兼顾了传统的汉字笔画细节又有规整而现代的几何化，间距合理，阅读起来非常舒适。 但是……苹方的设计缺字重。 在设计上，苹方没有 Heavy 字重（ 参考 ）。而在 流行的 github 苹方字体仓库 中，则是将 Bold 字重映射到了 Heavy，而将原本的Medium 映射到了 bold。虽然这个问题不是苹果设计的导致的，而是一个再次分发时的错误，但致使目前网上能搜索到的第三方仓库的苹方字体整体字重均偏细。 另外，苹方在 2.5K 屏上表现非常糊，苹方问世时已经进入了 Retina 屏的时代，没考虑过在低 PPI 屏幕上的表现（不是4K屏缩放200%都别用）。 第三，苹果设备的显示的西文字体是 San Francisco ，不是苹方。在 细数 Pingfang SC 的七宗罪 中，也提到仅使用苹方导致不同设备字体 fallback 的不一致的问题。而作为系统字体里的其他问题，例如缺失本地化的字型，也是大部分字体所缺乏的，这已经不仅仅是一个字体问题，而是和字体相关的和 UI 技术标准化问题，难以仅通过字体解决。而无比例数字、冒号不垂直居中、没有垂直标点等细节，则都是因为苹果显示标点数字用的 SF 字体，苹方在此类字符上算是基本能用，但缺少多种场景下的细节。 其他资源： Pingfang for windows - Figma 另外，苹方是有版权限制，以下字体除了思源黑体，和大厂的开源黑体，均不可免费商用。 思源黑体系列 思源黑体(Noto sans) 是 google 的开源可商用字体，用于 Android 系统，在开源可商用的的黑体其质量无可替代。 更纱黑体是思源黑体的衍生，修改了西文部分，相比思源黑体上更符合作为 无明显风格特征的系统字体，带 hinting 在 1080p 和 2.5k 下都能保证良好的清晰度。 但是，思源黑体系列设计相比于国产的商用字体并不能算好，有时间架结构比较怪异，字形的细节不太统一，比如“用”字明显矮了一截，整理风格上给人一种不稳定感。同时也不是一个大气的字体，比如口字旁处理对于黑体而言偏小，“用”字矮了一些，但是在宋体设计上，“用”字矮的这一截反而让字体看起来平衡。而一个系列的字体衬线、非衬线的统一感来源于其比例，个人理解为思源/更纱系列是优先考虑宋体的字形，和黑体的比例有一定的结合。整体而言还是宋体的设计更加优秀。 相对而言更纱黑体更适合作为系统字体，有着合理的 hinting。思源黑体是不太适合低 ppi 屏的，它的 Regular 字重看起来像 Bold。 方正兰亭系列（微软雅黑） Noble Scarlet （社区版）常规体是新设计中宫收窄的微软雅黑，而粗体是方正兰亭黑 Pro，因此在加粗时，字体明显会变小一圈。 微软雅黑系列字体在标点处理上很差，最直观的就是全角引号，太像半角的处理方式，很难看出前引号与后引号的区别。其实我在写这一篇文的时候，换了 Typora 的字体，才发现前后引号全打反了…… 方正兰亭黑 Pro 想对于两版微软雅黑都有着更小的中宫，字形设计中正。但也由于稍小了一些，在低 ppi 屏的小字上笔画更容易显得不太均匀，渲染效果不太好。另外使用此字体需要相比于其他所有字体更大的行距，因为其较小的中宫，字间距显得相对宽了。 汉仪旗黑系列 近年来的国产安卓厂商字体都是汉仪旗黑的衍生，代表阿里的普惠体、鸿蒙体、小米的字体、Oppo的字体。 这系列字体间架结构合理，但笔画上更加激进，减弱了起笔与收笔的的传统突出，以追求几何感与现代的科技感。在观感上，这样规矩的方形会使得字体相比方正系列更加圆润，多了现代感但少了汉字的人情味，用于阅读小说时尤其明显。 仅字形而言，作为 UI 是非常不错的。不过 Misans 渲染出来明显偏粗，我没有测试其他同系列字体是否也有这样的问题。 改掉 Windows 的默认中文无衬线字体 很多无法分别修改中英字体的 windows 原生应用，当只设置了英文字体时，显示的中文是新宋体（SimSun），比如 vs studio。原因在于系统里的 Microsoft Sans-serif 字体名，回落到的第一个字体就是新宋体……难以想象微软雅黑出了十多年了还有这样的问题。 解决办法： winkey + R, 输入 regdit，进入 windows注册表 进入 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink 把 Microsoft Sans Serif 的值中 SIMSUN.TTC 那一行去掉。这样默认的无衬线体就会往后 fallback 到系统的微软雅黑上。 把 Segoe UI 的 TAHOMA.TTF,Tahoma 挪到 MSYH.TTC,Microsoft 后面 创建于 2023-09-29 02:25:44 更新于 2024-08-19 01:45:31","tags":["Windows"],"description":"让 windows11 字体更好看的一些设置与字体浅谈","keywords":["Windows工具","软件推荐","Windows调整","Windows设置","字体","字体设置","Noble Scarlet","微软雅黑"],"date":"2024-08-01T10:08:25.000Z"},{"id":"windows-zsh-conf","title":"Windows 命令行相关配置之 msys2+zsh+zi","content":"长久以来，遇到 bash 脚本会临时切 git-bash 中的 bash。由于用的语言都有自己的包管理器，倒也一直够用。但是最近涉及到一些 c++，由 git-bash 提供的最小化环境东西缺得太多，几乎不能当个日常 shell 用，也没有 pacman 包管理，最后决定还是单独安装 msys2。 git-bash 和 msys2 同时安装不会冲突。msys2 是独立的 home 目录，而 git-bash 是与 windows 当前用户通用的。我本来想卸载 git-bash，但由于我现在还是用 powershell，最终发现 git-bash 不能卸载。一是 posh-git 只支持 git-bash 的 git；其次是，astro-nvim 中的一些插件需要 git.exe 在环境变量下，使用 alias 链接的 git 不行，而手动加环境变量会把 git 以外的程序也加进去，造成 msys2 的工具与 powershell 本身工具的冲突。 想来想去，决定保留 git-bash 到最小化的状态，当成 powershell 的插件用。unix-like shell 以及相应的包管理还是 msys2。 安装 msys2 见 https://www.msys2.org/ 。安装过程没什么好说的，唯一要注意的在于安装目录的权限必须是当前用户可以完全控制，否则后续各种包的安装都会有一大堆问题。如果因为强迫症安装到 Program Files 下，则需要手动添加当前用户的权限。 软链接问题 windows 的软链接本来也是个很麻烦的问题。到 msys2 下，还多了一个软链接方式兼容问题。msys2 默认是 ln -s 是复制，要用 windows 风格的软链接，可以改安装目录下的各种 .ini 文件中的配置。 MSYS=\"winsymlinks:lnk\" zsh + zi zsh 的安装 pacman -S zsh 老实说个人觉得和 linux 上的 zsh 相比还是差了一大截，用起来和 bash 感觉差不多。只是 zsh 插件管理的选择比较多 zi 的安装 关于 zsh 插件管理，之前在 git-bash 上我也安装了 oh-my-zsh，但是环境原因，遇到的 bug 着实太多，基本不用。另外，最大的问题是启动太慢，每次启动长达 10 秒。我分析了一下初始化脚本的执行时长，发现拖慢速度的罪魁祸首是初始化命令补全（就不能异步吗啊！）当然用 mac 时 omz 也有点慢，但显然没有 msys2 里这么离谱。 下午吐槽这个事情后，Antarx 说他换 zi 了。我试了下，确实很快，从没超过3s，令人偷税。 zi 的安装： https://wiki.zshell.dev/docs/getting_started/installation 安装过程最好在 msys2 的 GUI 终端下进行，因为需要登录的默认目录是在 home 的当前用户下。但这里又有另一个问题 —— msys2 不带 git。如果系统有另外安装 git，想复用，可以 cmd 启动 zsh，不指定启动的目录，指定继承环境变量。 C:\\\\msys64\\\\msys2_shell.cmd -defterm -no-start -ucrt64 -use-full-path -shell zsh zi 的配置与插件 安装Wiki 在不断更新，检查最新版的安装方法。 安装好后， .zshrc 里添加如下，写好重启 zsh 即可。 $ vi ~/.zshrc # zsh setopt AUTO_PUSHD export CLICOLOR=1 export LSCOLORS=ExGxFxdaCxDaDahbadeche zstyle ':completion:*' list-colors \"${(@s.:.)LS_COLORS}\" alias ls='ls --color=auto' alias la='la --color=auto' # zi typeset -A ZI ZI[BIN_DIR]=\"${HOME}/.zi/bin\" source \"${ZI[BIN_DIR]}/zi.zsh\" autoload -Uz _zi (( ${+_comps} )) &#x26;&#x26; _comps[zi]=_zi # source &#x3C;(curl -sL init.zshell.dev); zzinit # 插件 # 提前运行一次 zi ice pick\"async.zsh\" src\"pure.zsh\" zi light sindresorhus/pure zi light agkozak/zsh-z # 不能用 eval \"$(zoxide init zsh)\" 会冲突 zi snippet OMZP::git zi light zsh-users/zsh-completions # 提前运行一次 zi ice wait lucid atload'_zsh_autosuggest_start' zi light zsh-users/zsh-autosuggestions # 提前运行一次 zi ice wait lucid atinit='zpcompinit' zi light zdharma/fast-syntax-highlighting Windows Terminal 设置 在设置里改 json，加相应的 profile。可以使用 -use-full-path 继承 windows 系统的环境变量。 { \"commandline\": \"C:\\\\msys64\\\\msys2_shell.cmd -defterm -here -no-start -ucrt64 -use-full-path -shell zsh\", \"guid\": \"{c420e0af-28d9-4742-a6b8-83d5fcf424e9}\", \"icon\": \"C:\\\\msys64\\\\ucrt64.ico\", \"name\": \"msys2 zsh\", \"startingDirectory\": \"%USERPROFILE%\" } Vscode Terminal 设置 \"terminal.integrated.profiles.windows\": { \"MSYS2 zsh\": { \"path\": \"C:\\\\msys64\\\\msys2_shell.cmd\", \"args\": [\"-defterm\",\"-here\",\"-no-start\",\"-ucrt64\",\"-use-full-path\",\"-shell\",\"zsh\"], \"env\": { \"MSYSTEM\": \"UCRT64\" }, \"overrideName\": true }, }, Mintty 设置 Mintty 是 msys2 里默认的终端 GUI，默认 shell 是 bash。修改 mingw64.ini 为如下内容。 MSYS=winsymlinks:lnk MSYS2_PATH_TYPE=inherit MSYSTEM=UCRT64 SHELL=/usr/bin/zsh npm设置 如果有使用 npm 进行包管理，继承自环境变量的 npm 补全时会报错。需要设置为 $ npm config edit script-shell=C:\\msys64\\usr\\bin\\bash.exe shell=C:\\msys64\\msys2\\usr\\bin\\bash.exe # 重要 $ npm config list conda 设置 如果有使用 conda 进行 python 开发，继承自环境变量的 conda 默认初始化脚本也有问题……从 Github 上查到的解决方法…… # >>> conda initialize >>> # !! Contents within this block are managed by 'conda init' !! if [ -f '/c/Users/me/miniconda3/Scripts/conda.exe' ]; then #eval \"$('/c/Users/me/miniconda3/Scripts/conda.exe' 'shell.zsh' 'hook')\" eval \"$('/c/Users/me/miniconda3/Scripts/conda.exe' 'shell.zsh' 'hook' | sed -e 's/\"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$@\"/\"$CONDA_EXE\" $_CE_M $_CE_CONDA \"$@\" | tr -d \\x27\\\\r\\x27/g')\" fi # &#x3C;&#x3C;&#x3C; conda initialize &#x3C;&#x3C;&#x3C; ssh配置共用 如果有多个 ssh 账户的密钥，最好是软链接一下配置目录。注意需要前面的修改软链接方式，否则还是去资源管理器手动软链接吧。 ln -s /c/Users/me/.ssh ~/.ssh 参考 msys2-for-win https://sdl.moe/post/zsh-conf/","tags":["Windows"],"description":"","keywords":["Windows命令行","Windows调整，Windows设置","powershell","msys2","zshell"],"date":"2024-03-15T12:35:37.000Z"},{"id":"2024-02-29_像素的一生","title":"笔记 - 像素的一生","content":"内容来自于 2018 年谷歌的一个视频。原视频不长但内容很多，非常值得一看。Chrome 的渲染机制是在不断变化的。 笔记原存于 Logseq，如果有类似于，“见CSS/图层”一类的语句，为笔记内超链接。相关概念需自行了解。 📚 资料 b站视频 - 2018 英文slides 思否文章 渲染流程 ：web content → magic(rendering) → pixels 1. Web content 最常见的 HTML + CSS + Javascript API 还有图片、视频、音频、web assembly、WebGL、Canvas、PDF等等 2. 渲染 渲染是在一个 sandbox 进行的。渲染引擎 Blink 是渲染代码的一个子集。 操作系统渲染 API：OpenGL，DirectX(Windows), vulkan。包含 textures shaders 等等。 2.1 渲染目标 把 web content 渲染为 openGL 的调用 为更新渲染建立起对应的数据结构 2.2 基本渲染流程 渲染流程太复杂，会被分为几个阶段进行数据结构的转换 不是每一次更新渲染，都要走全部的流程。相关看 浏览器/渲染原理 中的回流与重绘。 HTML to DOM 解析 HTML 为 DOM 树。DOM树的作用有两个，一个表示文档结构，二是暴露 API 给 Javascript，由 V8 JS引擎进行 API 绑定。 CSS to ComputedStyle CSS 转换为 StyleRule 集，每个 StyleRule 包含 CSSSelector 和 CSSPropertyValue。流程如图 根据 css 样式规则，计算出每个 DOM 元素样式属性的最终值，存储于 ComputedStyle 对象模型中，是一个 style properties 与 values 的超大映射。这个过程被称为 Style Resolution。 ComputedStyle 对象已经暴露给了 JS。使用 getComputedStyle(element)['padding-top'] 即可获取。在 Dev tools 的 Elements 中的 Computed 选项卡的值就是依据此 对象来的。 Layout Stage 例子： Web 最基础的 Block Flow 布局，需要计算出 Block 的 x、y、width、height。 由于 Block 自适应高度，需要根据内容的尺寸，找到文字换行的地方，以计算每个 Block 的高度。 每一个 Block 的矩形有多种边界（在CSS/盒模型中说得很清楚）。内容 overflow 时，需要计算两个矩形，一个是 实际内容区域 ，一个是 能显示出的内容的区域 。如果内容可滚动，还要计算 滚动边界 和 滚动条边界 。 Document 的根节点本身就是 overflow 且可滚动的。 Layout Objects 也树结构存在，几乎与 DOM 是一对一，但并非总是如此。比如伪元素、浮动元素。 在 style 计算后会构建一个没有填入任何数据的 Layout Tree 。 更新布局 的本质就是遍历 layout tree 并向里面填充所有数据。 Slides里说目前没有把 Layout Stage 的输入输出区分开，但没细说，只是说下个版本会改。放个图 Paint to display item lists 做类似于在指定坐标内画一个红色的矩形这样的动作。代码结构上 ，是 LayoutObject 有一个 Paint 方法。去调用更底层的 Paint API。 此阶段生成“作画步骤”，还没有真的画出像素 。步骤是可以重放的。至于为什么这样做，之后再说（然而之后并没有说）。 Paint 是从 z-index 最大到最小进行的，而不是 DOM 的前后顺序。而两个并列的层叠上下文时，后覆盖前。在一个 CSS/层叠上下文 内，按层叠上下文的堆叠规则绘制（z轴的层叠规则），如图 Rasterization 栅格化 将 Display Item（位于 CC Layer 中，之后说）中记录的 Paint 操作转化为 位图 (bitmap)。 raster bitmap 通常保存于 GPU 内存中，被 OpenGL Texture Object 引用。GPU 不仅可以保存 bitmap，也可以生成 bitmap。叫 accelerated rasterization 。 此时像素纹理已经生成到内存，但还是没有画到屏幕上。 栅格化通过 SKIA 库 生成对 OpenGL 的调用。SKIA 提供了一系列对硬件的抽象。具体而言，PaintOps 会调用 SKIA 中的 SkCanvas 对象。 由于渲染过程是在 sandbox 进行的， 不能产生系统调用，OpenGL 调用是通过 command buffer 塞进另一个进程 GPU Process 执行的。GPU Process 接受到绘制命令后通过 GL API 去产生真正的 GL 调用。 使用 GPU process 隔离渲染进程除了渲染进程有沙盒机制外，OpenGL 可能也不太稳定或者是有漏洞。GPU Process 可以做一些保护措施。 GL API 来源于系统动态库 libGLESv2.so 。但是 windows 中来自于 Google 的 ANGLE 库 libglesv2.dll ，因为 Windows 上渲染不是用的 OpenGL，而是 DirectX API。ANGLE 库可以翻译 OpenGL 调用为 DirectX 调用。 3. 图层合成 3.1 帧与动画 每一帧是当前 Web 内容的完整呈现。 动画是连续的帧。针对第一部分提到的 style、layout、paint、raster，浏览器都做了跟踪失效的处理，只重绘改变的部分，其他部分复用。 3.2 合成线程 一个单独的渲染线程，减少 JS 主线程的其他操作和渲染之间 block。 图层 给合成线程渲染。比如 video 和 gif 在单独的图层，还有 transform3D, will-change 等 css 属性也会新建图层进行处理。 合成线程也需要处理交互。能处理的先合成线程处理（比如滚动），处理不了的就进主线程。 Layer Tree （CC Layer Tree） 图层也是以树结构存在，前序遍历。 有的图层的存在不是绘制，而是图层效果，比如剪贴蒙版、滤镜。 图层的合成位于 CC (Chronium compositor) namspace, 所以代码里有很多 cc::layer 。 如果一个 Layout Object 没有指定单独的 layer(比如没有 will-change 属性)，就会被绘制到父 layer 的图层。 Paint Layer 是要被分到 CC LayerTree 的。这就是CSS/层叠上下文与CSS/图层之间的关系。 3.3 compositioning update 在上一章的流程中，没有讲到合成这步，实际要加上。因为合成不是必须的，但合成步骤能优化渲染。 未来，创建图层的工作会放到 paint 之后（slimming paint） commit 提交一次合成。这里合成线程与主线程都存在 layer tree，需要同步合成线程与主线程的状态。 3.4 Tilling 在 rastering 阶段，把 CC layer 分块成 tile。 tile 是 raster 的最小单位 ，在专门的 raster 线程 进行栅格化。 合成线程有一个 tile manager 安排 tile 优先级。 不同分辨率的 tile 策略是不同的。 3.5 Drawing 不同 tile 合成为 Quad 。Quad 引用内存中的 raster output，封装在合成进程中，再提交到浏览器进程。浏览器动画帧的 帧 概念就是 Quad。 不同 commit 有先后顺序，需要从 pending 激活 再绘制。 3.6 Display 浏览器进程将 Quad 展示到屏幕上的过程。位于 Viz 组件中，调用 OpenGL 绘制 GPU 进程中的 Quad 资源，和 rastering 的 GL call 一样。 大部分平台的显示合成输出是双倍缓冲（有过游戏画面撕裂经验的应该对这有概念），quad 是在后台缓冲器（GPU的还是Viz？）中绘制的，用 swap 命令让后台的 quad 到前台展示。 4. 总结 Blink 引擎严格执行了主线程的步骤。但由于要实现 Web 平台化，是有一些合成线程的权限的。 其他 渲染器和浏览器都用到了 GPU，都有向GPU进程的IPC通道。 如果想让滚动的交互产生的动画不在主线程而在合成线程执行，需要强制 will-transform 分层","tags":["前端"],"description":"浏览器渲染原理","keywords":["浏览器，渲染，回流，重绘"],"date":"2024-02-29T15:45:11.000Z"},{"id":"白嫖怪的经验","title":"白嫖怪的经验","content":"作为一个合格的白嫖怪，列举一些个人用过的免费/低价云服务。 注：不要滥用，白嫖在很多时候都是违反 TOS（服务条款）的。 依据项目结构，主要分类为： 免费域名购买 静态前端托管 api 服务托管 数据库服务托管 服务器购买 GPU 平台（AI） 域名相关 由于国内存在对热门国外服务 ban 域名的情况，先持有个人域名是有必要的。有免费的，付费域名也不贵。但要注意国内域名要走备案，而备案又要求买国内的服务器，这不符合白嫖的认知。所以域名只看国外。 Freenom 可注册免费域名。1 个域名免费 1 年，续费要钱，1 年后想继续免费需要注册新域名。不适合长期持有。通常用于一些不想被人发现的临时服务。 Namecheap 6 位纯数字 + xyz 域名，一年只要 1 刀，个人开发值得拥有。只要不抢热门，域名普遍不贵。 Cloudflare 著名的慈善 CDN 机构（不是）。在 CF 买域名要钱，但可以转入域名，并进行免费 DNS 解析，免费的防火墙和访问控制，免费的数据统计，免费的 SSL…… 我个人非常喜欢 CF 的 dashboard，很直接。对域名进行管理，从输入网址开始只需要点三步，登录（切页面）=> 选域名 => 选功能，全程只切了两个页面。 对比一下阿里云。点登录按钮（切页面）=> 登录（切页面）=> 点控制台（切页面）=> 选域名控制台 => 选域名列表 => 选管理（切页面）。 静态资源托管 Github pages 静态网页托管。hexo + github pages。静态博客，经典搭配，原汁原味。 不过被墙得厉害，即使没有墙，域名也被国内浏览器屏蔽。 Jsdelivr 静态资源托管。Github 的加速网站。很多人拿来当图床。也容易被屏蔽。相当于把 github 当 cms 用，所以管理文件没有那么好用。 如果是目的不是用于开发，是明确违反了 TOS 的，只是量小的话没有人管罢了。Github 本身也不是拿来存二进制的。 Vercel 静态网页托管（其实可以不静态）。特点是国内 ping 值低，自动绑免费的 SSL。不过有一段时间 vercel 的 ip 也是被墙了的。所有没有在国内备案的服务都不保证直连的可访问性，特别是在量比较大的情况下。 Cloudflare pages 静态前端页面部署，类似 Vercel，优点大概是比 vercel 更难被墙。 网盘，OSS 嗯……网盘的资源，怎么能不算资源呢？ 不过，要获取网盘资源的直链，至少要经过两层的 API，延迟相当高。而且国内的服务防滥用机制相当严格（国内带宽贵啊） 但有一个好处……现在网盘普遍在卷内容管理系统 (CMS)，面向用户的产品，管理文件比 OSS 好用。主要稳定性在 API 上。 Alist 网盘列表程序 文档必看，这是一个集合了阿里云盘、百度网盘、Onedrive 等的网盘列表程序，利用各个网盘的 API，对各个网盘资源直接下载。看文档直接了解有什么服务可以白嫖，可以白嫖到什么程度。我在这照抄一下常用的不走服务器流量时的网盘： 百度网盘：可直接下载 20M 以内的文件，限速。 阿里云盘：可下载所有文件，分享的链接限速，自己的网盘不限速。 Onedrive：可下载所有文件，不限速，但在国外。有 API 调用上限。 当然，Alist 本身还是要有服务器的，但还有 paas 可以白嫖。 BackBlaze 对象存储，有一定的免费额度，cloudflare CDN 下行流量免费，可以说是个人白嫖图床最优选吧。知道这个是因为 rclone。 API 托管 主要列举 PaaS 平台。 Vercel 没错又是 Vercel。Vercel 还可以托管 Node.js 和 Python 脚本等等，拿来托管小的 API 服务是非常适合的。比如 Waline 。 支持的语言：nodejs、php、python、ruby、go 纯读取的 API 只用 Vercel 就可以了。如果需要上传下载动态内容，使用 Vercel + 任意数据库就可以，大部分网页应用的本质就是 CRUD。 Vercel 的免费版 有限制 ，对于个人站点来讲绰绰有余的限制。付费不便宜。 Fly.io 有很小的免费额度。曾经用过，长期无访问会休眠。休眠不删数据。 Heroku 曾经白嫖界的王者，现在没有免费的实例了，只有 Github 学生包还有免费。会休眠，据说现在会删数据。 国内平台边缘计算 阿里云函数计算，腾讯云函数计算，都不是很贵。用边缘函数当服务主要是麻烦在不同平台的适配上。还有，国内走公网流量计费，也不适合大带宽的服务。 数据库，BaaS BaaS 这里主要是指是数据库加上部分的后端服务，比如以 restful api 的方式访问数据库，而不是对数据库服务建立连接后写 sql。Headless CMS 也是一种 BaaS。 LeanCloud 开发版有一点免费额度。 Supabase 有 10G 免费额度。实例需要每周至少一触发，目前在用。知道的人不多，国内的薅羊毛大军没有进发到这。 Firabase 有一点点免费额度。 总体用得不多，可以看文章结尾的参考。 低价服务器 常逛 hostloc 会知道几个被大量滥用、不保证在线率、随时可能跑路的商家。主打一个买了买不了吃亏，买了买不了上当。个人用来做实验倒是挺适合吧，多买几个，白嫖一个靠谱的 API 重定向做一下负载均衡还算也 OK。 racknerd 12 刀 1 年的小服务器，普遍 DC 02 机房三网直连。 virmach 价格同上。有日本的机房，速度啥的挺好的。我是第一批迁过去的，传家宝系列，至今 10 刀一年。但发生过严重宕机，unavailable 了两天。 greencloud 没用过，有一年独服很便宜倒是，记得一年才 22 刀。好像日本和 virmach 是一个机房，和 virmach 一起宕机。 AI 服务 Colab github 很多项目在这白嫖 demo，跑跑小项目用可以，实例不保存环境，大模型启动很慢。可以充钱，充钱后可能抽到 A100（我抽到过 233） autodl 收费但便宜，分钟级动态租用，环境给得非常方便，接入国内网盘符合国内环境，有时候要抢实例。 huggingface 有免费的 cpu space，充钱用 gpu。 Kaggle 有一点免费的 gpu 时间，体验用。 参考 ☁️ 一些免费的云资源 Cloudflare or Vercel——网站托管与函数计算服务选择 tzhangchi/awesome-free-saas: an awesome list of free SaaS (software as a service) for you. 愉快的白嫖 Backblaze 的 10G 对象存储 - Hub | ldo.one 发现我的语言完全丧失了中文原有的简洁性，Sad。","tags":["服务器"],"description":"降本增效？嗯？","keywords":["Serverless","无服务器","PaaS","免费域名"],"date":"2023-12-29T14:09:15.000Z"},{"id":"2023-11-29-windows-shell-configuration","title":"Windows 命令行相关配置","content":"常用 shell 一直以来 windows 的命令行方案都很多，个人感觉都有不太好用的点，怎么配置也是仁者见仁智者见智的一个事情。先总结一下常用shell 方案 powershell 官方shell，各种工具库支持最全，缺点自带的命令太长，以至于完全没有日常使用的想法。 msys2 windows 上的类 unix 环境，基于现代 Cygwin (POSIX兼容层) 和 MinGW-w64（工具包）。确实像 unix，一般命令可以无缝迁移。缺点是兼容性，需要手动配置很多东西，比如是否继承 windows 环境变量，不继承的话不想维护两份环境，继承了又容易冲突。 git bash msys2 阉割版，无包管理，多了 git。 wsl 完全的 Linux 子系统，但太占内存。 方案选择 我需求 常用命令必须是类 unix 命令 有包管理器，各类命令行工具配置友好且兼容性不错。 不要太占内存 结果发现这就是经典的三圈相交，没有任何一个常用方案能满足以上要求。 最后，我决定用 powershell。除了第一条外都满足。后面两条属于难以解决的硬伤，而第一条可以编写脚本，将常用的命令模拟。 powershell 配置流程 包含工具包、终端美化。 Install the latest Powershell Core Install git-bash for basic bash and git tools Install Windows Terminal and open Powershell Install PSReadLine Install starship with Winget , Don't use scoop(too slow). Install gsudo for softlink Install eza for listing open $PROFILE in powershell, append the contents of Microsoft.PowerShell_profile.ps1 大致介绍一下用途。 git-bash，一系列类 unix 工具，git 一类的 Windows Terminal，微软的终端。我拒绝终端用 electron 去套的…… PSReadLine，改变一系列 powershell 的行为。比如复制粘贴的快捷键。可惜在 vscode 里会没用，只能右键粘贴。 oh-my-posh，美化。需要用 Winget 或者自己 Setup 安装。不要让 Scoop 装，找环境变量这一步能把启动速度拖慢1s。这个可以用 starship 或者 posh-git 替代。不过都挺慢的。 gsudo，提权，类似 unix 的 sudo。可能运行时会被杀软报毒，需要加入信任区。 eza，2024年了，终于有了一个像样的 ls 替代…… powershell 的用户配置文件输入 $PROFILE 就能找到。 我的配置文件上传到了 Microsoft.PowerShell_profile.ps1 。需要挂代理打开。配置文件包含 ls ln open grep which 等命令模拟。powershell 的缩写默认支持了 mv cat rm 等命令，配合起来日常基本够用。 终端代理 我在配置文件中设置了 proxy 和 unproxy 函数，以快速设置与取消终端的代理连接。自己改下端口就能用。因为我自己习惯上不开系统代理，都是软件内的 http 连接。 # Proxy Togglers function proxy { $portInUse = netstat -ano | findstr \"LISTENING\" | findstr \"7890\" $portInUse2 = netstat -ano | findstr \"LISTENING\" | findstr \"10808\" if ($portInUse -ne $null) { $env:HTTP_PROXY = \"socks5://127.0.0.1:7890\" $env:HTTPS_PROXY = \"socks5://127.0.0.1:7890\" Write-Host \"Proxy set to socks port 7890\" } elseif ($portInUse2 -ne $null) { $env:HTTP_PROXY = \"socks5://127.0.0.1:10808\" $env:HTTPS_PROXY = \"socks5://127.0.0.1:10808\" Write-Host \"Proxy set to socks port 10808\" } else { $env:HTTP_PROXY = \"socks5://127.0.0.1:1080\" $env:HTTPS_PROXY = \"socks5://127.0.0.1:1080\" Write-Host \"Proxy set to socks port \" } } function unproxy { $env:HTTP_PROXY = \"\" $env:HTTPS_PROXY = \"\" } 其他常用工具 winget：自带的包管理器，命令行工具都是这个装的。部分用的 scoop，非常少。还有的直接用的官网 setup。 nvim：命令行编辑器，vim 的替代品。我用的是发行版 AstroNvim。之前也有自己折腾插件，太懒得维护了，算了。 nodejs：JS 环境，nvim 的插件要用，开发也要用 zoxide：快速跳转目录。最有用的功能没有之一。类似 unix 的 autojump Terminal-Icons：ls 命令加 icon，还能解决 ls 不高亮的问题。但是，颜色很丑。但是，我不也想再配置了，配置真的心好累。 ripgrep：类似 grep 的用法。我在模拟 grep 命令时只是单纯替换成了 findstr，真的 grep 建议用 ripgrep (rg) 替代。nvim 的 telescope 一些插件也会用到。 安装脚本汇总： winget install conda winget install neovim git clone --depth 1 https://github.com/AstroNvim/AstroNvim ~/.config/nvim winget install gerardog.gsudo winget install OpenJS.NodeJSLTS Install-Module -Name Terminal-Icons -Repository PSGallery; Import-Module -Name Terminal-Icons # z-jump winget install zoxide # z-jump, see https://github.com/ajeetdsouza/zoxide winget install BurntSushi.ripgrep.MSVC # grep 的完全替代品 ZSH 有关 zsh 相关的配置，我放在了 Windows 命令行相关配置之 msys2+zsh+zi 。","tags":["Windows"],"description":"","keywords":["Windows命令行","Windows调整，Windows设置","powershell"],"date":"2023-11-28T20:07:06.000Z"},{"id":"thoughts-about-wubi-im","title":"大概是关于五笔打字更慢的一点碎碎念？","content":"每次看到打字的视频，总是会有人说五笔是最快的。五笔我打了八年。突发奇想去测试了一下五笔打字的输入速度，结果在我意料之内——在不刻意飙手速（以不被室友打）的情况下，大概是 60 字/min，全拼大概是 70 字/min。 虽然拼音我现在已经非常不熟练了，但速度还是比五笔快。而五笔在日常使用也并没有感觉到有什么不顺畅的地方，为什么测速还是会更慢呢？ 五笔更慢的原因 网上说五笔打得更快大多是指「看打下的极限速度」。这里有两个条件，一个是看打，一个是极限。 看打和听打 看打，指看着一段文字打出来，在早期没有各种扫描技术时，录文件就是这样的纯手工录入方式。 看打有利于五笔的拆字输入，而且不论一个人的普通话是否标准，只要认字都能使用。早期学者非常多会看字但念不准的。 早期输入法（智能 ABC）没有云计算，也没有词库，几乎一个字一个字蹦出来，非常非常慢。我小学拼音打冰灯用尽全力的记录也就 55 字/min，不算快的但也不算慢了。但现在五笔随意打初见就 70 字/min，途中还有好几个字不会拆的。想想在当时的那个环境，只靠打单字和少量词组，就能达到百字每分，是多么牛逼的一件事。 但在日常打字的时候，大部分人纯聊天，更多是使用的听打，想到什么说什么，就算口中没有真的发出声音。这明显是利于拼音打字的。另外，拼音打字的韵母键位非常固定，像 ing 这样的三字母韵母，打起来非常连贯，在这瞬间可以一秒按 8 个键，任何人打字多一点都能做到。真正意义上想说什么打什么。 我的名字拼音一共有 (10-15) 个字母，可以在 1.5 秒内打完全拼。拼音的输入速度完全不慢，重码问题也几乎靠技术解决了。在纠错、词库、上下文联想早就发展起来的情况下，五笔在日常使用上真的没有什么优势。 极限速度？ 这就是一个老生常谈的问题了———学习成本。 如果仅仅靠日常打字，五笔要多久，拆字的顺畅程度可以达到打拼音一年的水平？ 我的答案是：除非刻意练习，否则永远达不到。拆字顺畅，不会卡住自己的表达，是一个需要长期刻意练习的技能。 听起来可能有点夸张，但事实如此。 我在日常使用时，对于常用字，五笔输入也已经是条件反射，不太去想字形，和拼音差距也不大。但是测速文章就是另一回事了。各种领域的名词、人名等，总有你不适应的那一款（五笔大佬请无视）。不会拆时那个感觉真的难受，一分钟打一个字。 比如「凿个洞」「凹凸不平」「藏族」一类的词，对于拼音都非常简单且没有重码。但对于五笔，不是常用词且难拆，测速文里这类词很多。我有一个长长的清单，随时记录这类难以练到的字。 注意，以上的前提是「日常打字」。这里可能会有人对「日常」有一点误解，需要再澄清一下，日常不等于简单，而是「日常生活交流中的常用语言」。比如「藏族」，小学生都会念，还会写，但不日常。 五笔变小众的原因正在于高昂的学习成本，有没有不那么痛的学习方法吗？ 有。我自己一向不是死记硬背型的人，基本是用什么学什么直接开干。日语没背五十音图，靠记了一首歌词入门，五笔也没有背码表，看了原理后，一个区一个区地打一级简码二级简码入门。遇到不会的就查，会的就越来越多。 但是不那么痛的学习方法问题就是上面所说的，仅靠日常打字，想在遇到任何情况下都拆字顺畅，永远也不可能（记忆超群的五笔大佬当我没说）。 那个「不熟悉的列表」，我专门打了也有七八遍了，里面的所有字能顺利拆出来了，但每个字还是要花时间反应。 同学妈妈打了几十年五笔工作，也只是在她的专业领域得心应手，换到不熟悉的领域同样卡壳。不要看贴子说打得越久越熟悉，这个年头没有几个人是为了打字而打字的，打字说是表达，是个有应用场景的事，有场景就有范围限定，有范围限定就有上限。你平时能练到的字，就这么多。 诚然，五笔的极限是很快，但为此需要付出的刻意练习，并不值得，除非你喜欢。 软件问题 86 版编码是经典的五笔编码，但我现在使用的 98 版五笔，因为有一天实在不能忍受 86 版那个莫名其妙的笔顺了，还有一些为了降低重码而设置的不合理末笔码。 但是后来我发现，有很长一段时间，我都在把 98 版的字根表和 86 版弄混——我在学 86 版五笔时从来没有去背过字根表，都是靠肌肉记忆，肌肉和脑袋打架，于是混乱了。 另外，对于不会拆的字，想不起来的字，我会使用拼音反查。自从 ios 有 98 五笔后我就在使用苹果的输入法，因为可以接第三方键盘，还可以输入 emoji。但我反查了很长一段时间后才发现，苹果的编码，可以说是有巨量的错误，把 86 和 98 版混到了一起，一字完全不同的两码什么的，有时候打 86 版的拆法也能出字，反查编码的时候更是灾难。我对 98 版的拆字方式长期处于一种混乱状态。 所以在初期 输入法推荐 需求 基本词库+方便的自造词功能 精确的拼音反查 打重复字和 z 键特殊符号 良好的中英混输 可以方便地输入日期 我觉得还不错的： windows 冰凌五笔，默认设置基本不用改，除了空码需要上屏编码用来中英混输。还有 shift + 空格的快捷键最好是关掉。加自造词非常方便 mac 上清歌五笔，中英之间支持加空格，加自造词非常方便 rime 98五笔，自己再魔改版。我觉得可以满足大部分需要，除了特殊符号不是 z 键没有提示。这个输入法现在是备用来查拆字的，是的，直接是显示的字根而不是编码。 为什么我还要用五笔 话说回来，既然五笔打得没有拼音快，还费脑子，为什么我还要用五笔呢？ 一是，当习惯了不重码后，很难再接受重码的输入法。不论是不是日常用语，99% 的情况下五笔都不需要选字，不需要翻列表。你可以轻易打出「艹」和「卄」，同时也不会影响你正常打「草」。 当然，拆不出字时也会很难受。 二是，永远不需要联网，隐私问题。 三是，好的输入法设计真的好。当时知道 z 键万能键打特殊符号原来这么好用时简直惊呆了。自从用了五笔，我从来都没有使用 -> 打箭头过，从来都是 →。希腊字母、带圈数字、拼音音标也非常好打。当朋友提醒我写的 logseq theme 没有连字箭头时，我才发现压根没有注意到原来 logseq 后来加入了连字字体。 好困😴 睡觉","tags":[],"description":"","keywords":["98五笔","五笔输入"],"date":"2023-11-16T17:59:21.000Z"},{"id":"2023-11-11-typescript-generatic-type-proble-ts2322","title":"关于 typescript 泛型中返回值类型约束的问题","content":"最近遇到这么一个需求。 定义一个函数接口，要求其返回值类型是 type A 的任意超集。 于是我按直觉写下了： type A = { a: string } type FuncA = &#x3C;T extends A>() => T const f: FuncA = () => { return { a: \"ok\" } } 人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。 这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错： Type '() => A' is not assignable to type 'FuncA'. Type 'A' is not assignable to type 'T'. 'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322) 这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如 function foo(){ return \"1\" } // 自动推断出函数的具体签名为 () => string 那为什么上面的报错例子，不能做这样的推断呢？ type A = { a: string } type FuncA = &#x3C;T extends A>() => T const f: FuncA = () => { return { a: \"ok\" } } /* 推断出具体的签名类似于 () => { a: string; [name: string]: any } */ 也就是说，a 是必选属性，其他属性全是 optional。 （先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。） 当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？ 好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个…… 我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？ 在 typescript 的 github issue 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下： 如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 ()=>{} ，没有prop 属性。 但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样： type A = () => void; type B = () => void; // 类型签名为 &#x3C;T extends A | B>(value: T) => T 的实现 function f1&#x3C;T extends A | B>(value: T): T { return () => {}; // 推断出 T 此时是 typeof ()=>{}，也就是 ()=>{} } let f: any= ()=>{} f.prop = \"haha\" f1(f) // 这里传参报错，因为 typeof f 和 typeof ()=>{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错 当然上面的例子返回值类型已经定了是 typeof ()=>{} ，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。 什么是 subtype？T extends A，T 就是 A 的 subtype 这又引发了另一个问题：这和函数重载有什么区别？ 当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 A 。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。 但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。 如果要解决开头的问题，大概是以下三个思路： 定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 [name: string]: any 。 考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。 根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样 type Extend&#x3C;T extends object> = { [name: string]: any } &#x26; { [K in keyof T]: T[K] } type A = {a: string} type FuncA = () => Extend&#x3C;A> const f: FuncA = () => { return { a: \"ok\", b:\"extra\"} } f().a // a is string f().b // b is any 总之，在目前的 typescript 中， 返回值类型不能是泛型 。 当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。 现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。 说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。 还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。 可能没用的参考： typescript - How to fix TS2322: \"could be instantiated with a different subtype of constraint 'object'\"? - Stack Overflow Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript","tags":["typescript"],"description":"","keywords":["typescript","ts","generic type","ts2322，泛型约束"],"date":"2023-11-11T14:26:09.000Z"},{"id":"2023-10-09-the-little-prince-review","title":"重读《小王子》","content":"《小王子》在不同年龄阶段都看过，中译和原著也都读过，当时只是觉得有趣。但尝试自己写故事后，才惊觉其实所有的有趣都是是作者的刻意表达。 仅仅以生活中的“有趣”与“想象力”写出的故事远远不够，别人看起来并没有你认为的那么有趣，内核是空洞的。 人在成年人后，所经历的一切容易让笔下故事的发展陷入自身所见所闻，很难写出孩子般质朴的想象，无法逃离现实的束缚。 举个例子，如果你的故事需要一个超现实的“天体引力”进行推动，你会用怎样的方式让这样的力产生？ 我搜集了很多宇宙的资料，试图从中找到什么想法。但事实上我并不是想写硬科幻，也没人想在简短的剧情中读一大堆物理考据。 我对此一筹莫展，觉得怎样都编不出一个合理的解释……最后决定拉出上帝作为隐喻，上帝按自己心意去裁定天体引力。听起来很离谱吧，就好像是小孩子的瞎想，仅仅是“上帝裁定天体引力”不也是一具无意义空壳吗？但如果将这个设定赋予别的象征，就不再是无意义的。或者说，我其实是想象征什么，才拉出一个离谱的上帝。不过这个处理我也并不满意，但一时想不到更好的方法。 幻想的意义不在于幻想本身，而是幻想对故事带来的推动。感到有趣的事在深入思考后也不仅是罕见、超现实的表象，它会带来的新体验，又或者：“喜剧的内核是悲剧”。 今天复看《小王子》，试图从写故事的角度去理解，作者在下笔时是带着怎样的想法与心情呢？或是单纯是觉得有趣吗？怎么想出这些光怪陆离的可爱小故事？我是一个强逻辑性的Ne人，这样的思考也许能提高一下Ni的水平，带来一些不一样的启发。 第1章 介绍“我”与“大人”之间的区别。 “我”在成为大人后 ，依然有着孩子般的心灵。如果不是这样，后文的“我”将是一个很难理解小王子的大人。体现这一点是“蛇吞象”与“帽子”的故事（作者真的很会想）。大人看东西只关注现实，不现实的事情对于大人毫无意义。 第2-7章 介绍小王子的由来。 “我”困在沙漠中时遇到来自另一个星球的小王子，一个礼貌的、有点忧伤的小王子。小王子想要我画一只绵羊给他，但挑三拣四，最后对一只藏在箱子里看不见的小绵羊表示满意，还觉得小羊在箱子里睡着了。 为什么想到在这里安排这么一只奇怪的绵羊，如果仅仅想有趣，那安排一只会走钢丝的山羊不行吗？读到最后才隐隐有了答案——美丽的事物往往是不被看见的，这也许是“箱子里的羊”的动机。 第6章的写小王子星球上的猴面包树。从编剧的角度，不描写羊吃什么食物也无伤故事发展，但写了，还写的是特别具体也不常见的猴面包树，大概是有什么想法在里面的。猴面包树是会无限扩张的、不好的东西，但这和小王子的生活有什么关系呢，也就是多了一些并不让人开心的日常打扫。 我不认为这里是象征自私的欲望、野心，小王子的星球上没有出现这类元素的必要性，含义也并不太深刻，在后续别的星球遇到更合理。后来看知乎上感觉有一个（我认为）挺靠谱的说法： 作者发表时正值二战期间，作者是一名法国人，国土沦丧旅居纽约。旅居纽约的法国人又分成戴高乐派和维希派，他想劝告两派捐弃前嫌共同对敌，却遭到两派的夹攻，非常无奈，这三棵灌木正是代表法西斯的德国、意大利和日本。 破坏这份宁静的、疯长的、夺取人生存空间的猴面包树。 然后引出了对于小王子最重要的玫瑰花。作者是先想到绵羊再编出的玫瑰花，还是本来就想写玫瑰花与小王子的故事、再编出绵羊？如果以先写大纲让剧情先行的角度，我偏向于后者。无论以何种方式开始，绵羊和玫瑰花的情节是精妙契合的。情节的前后衔接一向不是一个简单的事情，如果先写剧情可能人物 ooc，如果先写人物可能会想不出后续，好多长篇就是这么坑掉的…… 这部分里还有一些别的情节，比如说谈到小王子的星球叫做行星 B612 时，讽刺了大人们喜欢以衣冠取人，关注外在与代号，不关注人的本质。 小王子的星球上还有两座活火山一座死火山，非常有趣的脑洞，对剧情发展没什么用但并不觉得无聊，气质很符合小王子的星球（氛围渲染也是有必要的？）。小王子有一天最多看了43次日落，后文对不同星球的日落次数描写对比起来也非常有趣。至此基本表现出了小王子日常生活。 第8-9章 玫瑰花与小王子的相处这两章浪漫温柔，明显以人物情感先行，对话自然发生。剧情上没有太多刻意安排。有刻意安排的剧情是小王子最后一时冲动生了玫瑰花的气，离星出走。虽说是生气了，但看起来还是十分的文艺……整个文笔的基调就是这样的，very童话。 第10-15章 离星出走章节。不同星球上住着不同的奇怪大人，写得非常直白。后面有许多章节都会显得较为独立且直白，是娓娓道来的日常故事。 第10章：有理性但放不下权威架子的大人。 第11章：爱慕虚荣的大人。 第12章：永远在犯同样错误的酒鬼。非常短，像四格漫画一样，但闭环的对白好有趣。 第13章：除了钱和财产再脑子也容不下别的东西的商人。一些人看到什么东西就觉得是自己的，什么也不做就想据为己有，像是在讽刺资本主义的起源嗯…… 第14章：守规矩的、不知变通的打工人。观看一千多次日落这个吐槽也很有趣，像是人物先行写出来的。 第15章：不出门的地理学家。看到好多模板的影子：不深入基层的高高在上的 leader、掉书袋不实践的人、把别人的成果据为己有的人、不切实际的甲方。地理学家知道地球，但连自己的星球上有没有大洋和火山都不知道，却觉得理所当然。 第16-19章 小王子来地球的见闻。 第16章介绍地球。 第17章小王子来到地球寻找人类，第一个遇见的毒蛇是为以后小王子回家埋下的伏笔（好残忍）。 第18章向花问路的写作视角很有趣。以花的视角，人没有根，所以被风送走了。 第19章的回声有点类似空镜的作用？我不理解，但隐约觉得好像是有用的，好可爱。 第20-21章 算是主线章节（？）很多玫瑰的花圃，小王子最初知道自己的玫瑰在外形上不是独一无二的后，很伤心。但小狐狸的出现又让他明白了 正是因为小王子在玫瑰身上花费的时间，才使得玫瑰变得如此珍贵。因此单她一朵，就胜过了这世间所有。 此外小狐狸还教会了他仪式感。 第22-23章 永远在向往别处，行色匆匆，忽视脚下风景的人。 永远在节省时间，追求效率的现代人。 第24-25章 沙漠里的井水，突出主题的两章，和星星上的玫瑰花一样。这个情节的设置和作者的自身经历有关，对于没有经历过的人而言难以复刻。 “沙漠美丽，因为沙漠的某处隐藏着一口井。” “房子也好，星星、沙漠也好，美化他们的东西，是肉眼看不见的。” 第26-27章 小王子通过死亡回去了，“我”不舍。这两章人物先行，对白比较重要。 总体感想是，这是一本给成年人读的童话。我清楚记得我小学时看到第一章，只觉得这是一个有点可爱的怪孩子。到高中时，可以感受到文笔有童话的美好，但并不太理解作者要表达什么。大学时看原著也没有懂，纯学英文去了。直到现在才对里面的情节有所体会。小王子的“童真”是人在成长过程中需要慢慢获得的，是成年人的反思，在小时候的记忆中类似的想法我从未存在过。小时候反而会现实得多，真正的小孩子有着更原始更本能的残酷。 语文考试总是在问“作者在这一段想要表达什么”，小时候总觉得有时候是出题想太多。现在觉得，不是的，但也不应该有标准答案。刻意设计的剧作可以解释，很多人带着心情自然而然书写而成的东西，自己也是无法准确剖析的。剖析自己对每个人都是困难的，何况是一纸之隔的他人呢。","tags":[],"description":"","keywords":["小王子","世界名著","童话","读后感","书评"],"date":"2023-10-09T05:56:57.000Z"},{"id":"2023-09-26-minecraft-settings-for-v1-20","title":"Minecraft v1.20.1 常用设置","content":"更新： 1.20.1 版本 mod 列表 在 Minecraft 1.20 版本光照引擎被大幅改写，使得帧数提升，模组的数量似乎又多了起来。另外在 fabric 发展起来以后，mod的社区生态有了很大的变化，有很多老牌模组有了更新的替代。现在记录一下实现常用的基本功能需要的模组与修改设置。 我使用的 hmcl 启动器，在其中进行模组下载可显示模组间的依赖情况。以下内容在 1.20.1 中完全兼容，且项目均在维护中。 1. Mods MC 是一款肝度明显过高的游戏。mod 的选用主要是为了： 使画面养眼 降低肝度，同时少引入额外的快捷键 优化细节使用体验 使用以 fabric-api 构建的模组。 1.1 渲染类 Sodium: 渲染优化之神，许多模组的前置 Sodium-extra: 渲染优化之神的扩展，相应 GUI 为reeses sodium options Lithium: 原版机制的算法改进 Iris: Sodium 加光影 Custom Entity Models: 自定义实体模型，增强对 optifine 材质包的支持 Continuity: 无缝纹理，安装后需要启用相应的材质包。对第三方材质包支持一般，主要和 optifine 的格式还是不一样。 Indium: 许多模组的前置，提供 Fabric Rendering API的支持 1.2 功能类 modmenu: 显示所有模组和相应的设置页面（如果有的话） carpet: 单人生存必备，可使用命令放置假人以常加载区块刷红石 tweakeroo: 一系列微调的小功能。主要使用 freecamera（灵魂出窍）以获得更好的摄影视角，zoom 开启类似 optifine 的按 c 视角放大，handrestock 可自动补货手里的工具、方块 JourneyMap: 小地图，降肝度必备。Xae 的小地图也不错，两者都需要设置一下显示的东西，默认会非常多，我只开启了玩家、时间、坐标。关闭了网格显示和生物显示。 Invertory Profile Next: 高版本的 R 键背包整理（但被我改成 Z 键整理，R 键通常是 JEI 查看合成表）。自动补充工具、连续合成、捡物品时默认扔到背包中，以及在打开箱子时使用滚轮移动物品。关掉快破损时替换工具。 Carry on：手里没有东西时， shift+右键 搬运箱子，降低装饰的肝度。 JEI + EMI + 通用拼音搜索: 物品搜索，查看合成配方、查看方块用途，EMI 增加了 查看合成树 、切换可合成物品。合成树我觉得非常非常有用…… imblock: 输入法冲突修复 Panda's falling tree：砍树时树会倒下，降低砍树的肝度。 Leawind's Third Person: 更好的第三视角。这算是第一个可以日常使用的第三视角模组，挖方块瞄准都很方便。日常的垂直平滑 0.5 以上，不然爬山能晕死。 better combat: 动作战斗优化，攻速和攻击范围都有反馈了。 Litematica：投影。辅助红石机械建造，也算是一种降生存建筑的肝度。使用相当简单，一根木棍，control+滚动切换模式，快捷键进菜单。最难的其实是收集足够多的预置模型。但这个模组，要抢 Map 的 M 键……键位需要大改。 Hey Wiki: 在指向物品时按 h 键查询wiki。在物品越来越多的高版本具有一些引导作用。 1.3 新物品 Gliders：类似塞尔达的滑翔伞，防摔。在空中按空格展开滑翔。使用方式和大部分游戏一致。只是要占一个盔甲位。动画做得很不错。 Waystones：传送石碑，后期物品，降低交通的肝度。如果用地图作弊路径点传送就不需要这个东西了，但理想的玩法还是地图只是用来看的，让传送石碑在地图上显示（需要前期多刷小黑），只能传送石碑处，禁止任意传送。传送石不是个好设计，MC背包不能放下更多东西了。除非有单纯扩容用的背包模组。 travelersbackpack：背包模组，终于有了 fabric 版。虽然 mojang 一直很谨慎地加入新的方块，但似乎从未考虑过方块越来越多时的背包使用问题。再者模组整合包也因为方块种类数爆炸的问题增加背包模组。在 1.12 版本时，背包容量是刚好够的。个人并不是很喜欢背包的设计。 2. 设置 画面尺寸: 1920*1080@60fps，窗口化 视场角: 85 鼠标灵敏度: 75 模拟距离：8 渲染距离：12 2.1 快捷键修改 总体的键位映射图如下。深绿色为原版的功能。橘色为Mod功能，蓝色为创造模式功能。键位分为直接按键、组合键、修饰键（长按）。MC 原版只能定义直接按键，组合键与修饰键在复杂的 mod 中用得多，并且会覆盖原版的直接按键。 游戏主界面 首先把 ctrl 改到 capslock 键位，方便疾跑。系统全局 powertoys 改的（吐槽一万句control的键位） 长按 tab ，滚轮切换物品栏。在tweakroo 的「工具」中开启 hotbarscroll，再在 tweakroo 的「快捷键」中把 hotbarscroll 的快捷键设置为 Tab。 v : 切换第三人称视角(visual)，很常用的功能。原本是f5，实在太远了 f4 : Leawind's Third Person 第三人称视角相机调位置。同时关掉左右切换。点按左右，长按居中 f5 : 灵魂出窍，在 tweakroo 的 freecamera 中设定 c : 望远镜，在 tweakroo 的 zoomactivate 中设定 t : 路标点传送管理(transport)。聊天改 enter 键 x : 锦致装饰-箭袋 m : 显示 jouneymap 大地图和设定。Journey map 的其他快捷键全关掉。 n Litematica 投影菜单 h Hey Wiki 查询指向的物品 Wiki shift+右键 空手时搬运箱子，carry on 自带。 特定工具下的修饰键： 木棍工具 ~ Litematica 木棍工具修饰键，改变区域大小 n+space Litematica 木棍工具模式5下放置投影 预留键位： g 圆盘菜单 ~ 特定工具修饰键，比如连锁挖矿 b 背包(backpack) j FTB任务书(journal) 左alt 创造模式下，建筑模组 axiom 用 alt 切换专用物品栏。 合成台、箱子UI r: REI 查看光标下物品的合成方式 u: REI 查看光标下物品的用途 ctrl + 左键点击REI的物品，移动物品到合成台 z: 一键整理。在 IPN 的设置中修改。 使用滚轮以在背包和箱子间移动物品，按shift移动整组 3. 光影 BSL v8.2.04，默认配置High，把 Camera 中的 Bloom 关闭，把 Atmosphere 中的 fog 调到 0，开启 lighting 中的handDynamicLight。抗锯齿的TAA随便开不开，取决于风扇响不响 Complementary Reimagined，配置 medium，high 会开启材质的反射运算量明显变大。夜晚也比较亮，适合生存。 itt 3.0，更适合搭配了写实系材质的建筑，风格最写实的 shader 没有之一。不适合生存。 4. 材质 任意矿物发光材质。比如 New Glowing Ores 。主要是因为 BSL 光影没有矿物发光，所以要加一个材质以确保有 fallback。 彩虹像素 ，非常优秀的免费猛男材质包，原版风但更精致。有很多更可爱的附加包。 5. 创造模式附加 5.1 Mod Axiom 高版本环境必备，可以创建实体方块随意拉伸模型，相当好用。 effortLess structure 快速建造几何体。原 effortless buidling。 lotweaks 自定义材质轮盘 wordedit 经典创世神 快捷键 tab : effortLess structure 轮盘。 r : lotweaks 轮盘，和手中方块有关。会禁用丢东西（但创造模式本来就不用丢东西除了篝火灭火，何不用 Axiom 的调试棒？） 左 alt ： Axiom 的大菜单","tags":["Minecraft"],"description":"","keywords":["Minecraft","fabric","常用设置","mod"],"date":"2023-09-25T18:38:09.000Z"},{"id":"2023-08-30-windows-tweak-and-enhancement","title":"Windows 调整之基础功能与常用插件","content":"自从感觉内存硬盘越来越不够用，以及对老黄的显卡需求，从 mac 换成了多年不见的 windows11 。做了非常多的调整，至现在基本稳定，记录下来以供参考。 基本调整与基础功能增强 右键菜单 使用 shell ，恢复被藏到“更多选项”中的的右键菜单项，同时保持 win11 的设计风格。并且带有用 vscode 打开和用 windows Terminal 打开。虽然说 Windows Terminal 自己也有一个“用终端打开”，但那个有 Bug，打开的目录会被两个程序同时占用句柄，导致无法对目录本身进行操作。 批量重命名 使用 Powertoys 中的 PowerRename，可选中多个文件后右键批量重命名，整理素材时太有用了。大致与 mac 的多文件重命名相同。缺点是不能改成 同名称 + 编号 。但系统自带的重命名恰好只能同名编号。Powertoys 有很多别的小工具，但都不够好用，按需关掉。 快速预览 使用 QL-Win/QuickLook ，选中文件后按空格直接预览，再按空格关闭。对于看各种后缀的文本文件、zip 压缩包目录结构非常有用。也用了 mac 后没法割舍的一个功能。前面说的 Powertoys 也有，但快捷键一定要加 ctrl（真的难按），功能更少，图片不能显示大小，无法定制。 文件快速搜索 使用 Everything ，我大部分使用场景是在卸载程序后，清除残留的下载数据与用户数据。 快速启动/全局搜索 使用 Listary 优化合集 hellzerg/optimizer 微调 windows 的合集程序，包括禁止系统更新、改 hosts 文件刷新 DNS、移除开机启动项、添加自定义右键菜单等。 历史剪贴板 ：在 设置→系统→剪贴板 中启用。 屏幕颜色配置文件(ICC Profile) 在 设置→屏幕→显示配置文件 中，换成对应屏幕的sRGB文件。否则对于广色域屏幕，某些不读 ICC Profile 的照片查看器会出现色彩过饱和的情况。 输入法 微软输入法需要改成回车时键入英文，否则会清空，不方便中英混输。不过作为一个五笔用户，我现在使用的是基于 Rime 的 98五笔输入法 和 我的配置 。 因为微软输入法 shift 加 空格会标点变全角，而这个功能在中英混输时非常容易触发，还不能改掉，实在太弱智了 关闭顶部自动布局 关闭 系统→多任务处理→贴靠窗口 。此功能乍一看非常贴心，实则非常容易阻碍鼠标精准排列窗口，尤其是想把上沿拉到顶部时。不建议使用鼠标时开启，更适合手指操控设备。 多线程下载器 使用 aria2 ，在网上抄了一个配置文件，并且让 chatgpt 写了一个开机自启脚本。面板使用的是 Chrome 插件 Aria2 Explorer ，考虑到都是在浏览器中下载，没必要使用独立的客户端 App。 与手机互传文件 （折腾但稳定版） 使用 alist 进行磁盘目录映射，并且使用 DDNS-Go 动态绑定本机的 ipv6 地址到公网。手机上将相应的 alist 页面添加到主屏幕，便可在该页面互传文件。好处是能走局域网，速度快，不同网络环境下可用，可远程传输等等。依然让 chatgpt 写脚本将两个程序加入开机启动。 硬件调整 硬件信息监测 使用 hwinfo 的实时监测数据作为硬件调整的基准 功耗/风扇转速调整 使用 g-helper 调整日常使用的风扇曲线。我买的幻16，作为全能本，出厂的奥创调教特别垃，首发时还有bug。它的三种模式 静音模式风扇完全不转，经常温度突然飙升很吵地转一会儿 性能模式开什么都以游戏本的方式转，对我来说挺吵的 增强模式的声音不是给人用的。 如果用windows默认电源管理方案的话，似乎和程序资源占用有关，即使只有60度也给转上4000转。打个小游戏真的不配这么吵…… 后面用g-helper关闭睿频，功耗限制35w。测下来开原神默认高画质 1080p 稳定在CPU 65度，风扇3500转，不卡。这代 GPU 的散热反而问题不大，至少玩原神不会超过60度。然后测试了带光影的 Minecraft 1.20.1。MC 对 CPU 的要求更高，不过单机的话，不刻意刷红石，35w也够了，一般在25w左右，温度还是差不多的65度，全程电压没有超过1V，降压对于控温还是很有用的。奥创之所以动不动就吵就是因为一开性能模式，什么都不干电压给到1.8V……没必要，真的没必要。 日常使用场景下，好像也就编译比较耗CPU，其他时候都用不到很好的CPU性能。图形处理还是占GPU更多。音乐制作一类的也是耗CPU但也还好，但更耗内存硬盘。 音频调整 Equalizer APO 调全局声音的均衡，需要搭配 Autoeq 仓库中说的 peace 插件使用（现在好像直接叫autoeq.app）。耳机发烧友的必备。注意蓝牙耳机无法使用卷积eq。 内录用虚拟声卡： VBCABLE_Driver 网上有很多教程，为轻量级内录解决方案。另外如果系统带有 xbox，用 xbox 的录制视频是默认走的内录。 降低 Midi 键盘延迟 键盘连接电脑练琴，无独立声卡时，可用 ASIO4ALL 降低延迟。效果显著。缺点是 ASIO 是设备独占的，比如宿主软件使用 ASIO 到耳机，那看 b 站视频就只能外放（或者别的耳机/音响）。","tags":["Windows"],"description":"","keywords":["Windows工具","软件推荐","Windows调整，Windows设置，插件"],"date":"2023-08-30T01:42:20.000Z"},{"id":"20230822-Super_resolution_models_and_tools","title":"图像超分辨率工具推荐","content":"推特 ，现在叫 X.com，是我的桌面壁纸来源，但是推特的图压缩得非常糊，喜欢的动画人基本也只传 1080p 图，导致壁纸糊上加糊。因此需要使用 AI 放大模型进行图像处理。 放大效果外链预览： Comparison 细节对比： 文章分为三个部分： 图像处理工具 AI 图像放大模型 如何使用 图像处理工具 1. chaiNNer 一个无代码的图像处理自动化工具，可以实现批量改大小、调色、压缩、拼接等等等。同时也支持用 AI 对图像放大，也能接入 Stable Diffusion 的工作节点，上限非常高。缺点没有内置模板，即便是很小的功能（比如文件批量重命名）都需要自己创建。 应用内置使用文档，不过不看文档也能一眼知道怎么用。 只有英文，没有中文。 传送门： chaiNNer 2. imagestool 对于单张图和 gif 的常见处理小工具合集，网页打开即用，完全本地运行无隐私问题。特点是非常易用，支持小批量处理，支持 pipline，也就是说如果想在调整大小后转换格式再压缩，不需要每一步都上传下载图片，可以处理完每一步直接选下一步，只下载最终的处理结果。 传送门： imagestool AI 图像放大模型 超分辨率成像(Super-Resolution，简称 SR) 是一种提高图像分辨率的技术，通俗的叫法就是图像放大。如果你曾经使用过 Photoshop 对小图进行放大，会发现放大后的边缘总是非常模糊，并且用锐化等操作无法弥补，这是传统方法的在图像放大上的缺陷。 但是神经网络（Neural Networks，简称NN）的出现对图像放大的效果带来了极大的提升，几年前就已经有不少 AI 图像放大的应用，但最近两年的模型效果尤其好。下面介绍几个现阶段应用上比较火的模型。 1. SwinIR 2021年基于 Transformer 的图像超分辨率模型，放大任何图片的效果都非常好。风格偏锐利且干净，且参数少，处理速度快。此模型分为 3 类，经典图像超分辨率（Classical image SR）、轻量级图像超分辨率（Lightweight image SR）、真实世界图像超分辨率（Real-world image SR）。 下载链接： Release · JingyunLiang/SwinIR 可下载的版本很多，不知道选哪个的就选 001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth ，这个为4倍放大的模型，也是 Stable Diffusion 的 SwinIR 预置模型。 2. Real-ESRGAN 2021年的经典图像超分辨率模型，这论文出来后大家疯狂在它基础上卷，基于 ESRGAN 改进的模型和论文非常非常多。不过最初的版本也已经足够好用。 下载链接： Releases · xinntao/Real-ESRGAN 依旧版本很多，不知道下哪个的下载 RealESRNet_x4plus.pth 即可。 3. 4x-AnimeSharp 基于 ESRGAN 架构的动漫类放大， 可能由于训练集选得好 ，在众多动漫类放大中它可以很好地处理景深，其他的Anime模型多少在景深部分会有一些清晰过度的问题，包括著名的 RealESRGAN 动漫模型 下载链接： AnimeSharp - OpenModelDB OpenModelDB.info 上有更多的微调模型，可以试试。总体来说，AI 放大的图像质量目前来说还是乍一看可以，涉及商用美术的话质量仍然不过关。 如果商用美术能过关，岂不是能画糊图然后丢AI出高精图了。 作为壁纸放大非常合适，即便是补充的细节不能推敲，但把像素精度补齐到屏幕分辨率带来的视觉提升也是非常大的。4k 壁纸就是比 1080p 看起来舒服。 如何使用 使用 chaiNNer 时可照抄下图结构，使用 4x-AnimeSharp 模型放大原图、重命名图片并保存。 如果使用的是 stable-diffusion-webui ，Extra Network 选项卡中也有预置模型，可以使用 SwinIR 和 ESRGAN。 可能有用的资料： 4x-AnimeSharp Interactive Visual Comparison of Upscaling Models PS：强烈建议无代码应用都开发个 template market……不要做一堆功能摆那里就自由发挥了啊诶！当发现要什么工作流很难做时就会感知到这些无代码 App 的问题所在了……在实际应用场景中很烂！很难做！说的就是comfyui……","tags":["AI","经验"],"description":"AI图像放大模型+工具推荐","keywords":["AI，图像处理，图像放大，超分辨率，CV","SR"],"date":"2023-08-22T14:20:54.000Z"},{"id":"2023-02-20-stable-diffusion-AI-experience","title":"Stable Diffusion AI 绘画的实用经验与总结","content":"2023-03-03：待大量补充和修订。 进阶经验，非科普。分为五个部分：模型选择，分辨率调整，采样方法，ControlNet，Lora概述。 此文章涉及多平台发布，由于生成类 AI 的争议，文中无外链推荐。 一、模型选择 模型影响构图和笔触和色彩，决定成图的平均水平。社区经常都在换流行的模型，还是根据需求定，huggingface 和 civitai 上很多。 二次元目前主流三家 Anything Orange Counterfeit 。 目前有不少混合了 2D 和 3D 的 2.5D 模型，用来出 cos 的，个人不喜欢。 下图模型为 pastel-mix，图片画质已严重压缩（看不见则需要开代理，如果你用的 Innoreader 手机版阅读此文，大概率被放头图了） 模型精度选择 fp-16(2G)，fp-32(4G)，full(7G) 用于生产没有肉眼可见的区别。full 主要是训练用的。fp16 生产够用了，快，占用小。 bf-16(2G) 相对 fp-16 会损失一小部分细节，不推荐，会发布 bf-16 版本的模型也较少。 VAE权重网络 影响色彩，主观效果是增加饱和度（比修图软件饱和度增强好太多）。目前流行的 VAE 就两个，一个 Waifu 的一个 Anything 的，很多带 vae 模型都是用的这两个改了个名字。 下图为 mix-pro-v3-fp16 模型，叠加了其配套的 WD vae 的 效果。 Prompt prompt（提示词）是玄学范围。不同模型的 prompt 词库不一，目前主流的词库有两个 适用 SD v1.x 及其衍生模型的 lexica 适用二次元模型的 Danbooru。 对于二次元模型，Prompt 指定物体，调整动作、指定颜色比较容易。取决于模型的泛化能力。 Prompt 难以精确控制画风，所以尽管上限非常高，但主流越来越不倾向于用大量 Prompt 叠 buf，转成微调模型以达成精确需求。 在两个月前关于 Prompt 研究的文档就已经非常多了，这里不做推荐，因为不看文档，直接翻译成英文大概率是有效的。 文生图与图生图 文生图与图生图本质上没有什么不同，文生图只是将图片输入换成了一张随机的噪声图。 二、分辨率 不同模型在生成时有最佳的分辨率，大部分都在 512px 左右，不超过 1024px。 提高分辨率不仅是单纯放大图片，AI 能够用模型细化图片。 图生图 img2img(图生图) 大部分时候被用来衍生，但是其效果最好的是将 txt2img 的低分辨率图放大（用同一个seed）。 在 web-ui 中，仅缩放(just-resize)为无 AI 的放大算法处理。 AI 放大使用的 Latent 方法即将被归入 Upscaler，也就是下面说的 Hires fix。 Hires fix Hires fix（高清修复）的作用是用 AI 从小图生成高分辨率图，处理用得好可以提高大幅提高图片上限。upscaler（放大器）可选几种放大方法，其中的 Latent 就是 SD 的画图方法，文生图与图生图均是这个方法。 在 web-ui 中， 默认只有 txt2img 可用，因为 img2img 本身就可以做图片放大。另外，有专门的 upscaler 选项卡。 使用 Latent upscaler (图生图) 放大到高分辨率图涉及局部重绘，部分模型支持较好，如 Pastel。但在 512 px 完成度就很高的模型上通常没有效果，或者更差（比如炫彩厚涂），这种用 GAN 类 Upscaler 直接放大比较好。 值得注意的是 web-ui 的 Hires fix 有两版算法，目前 txt2img 是新版， img2img是旧版，效果有一些小差别，很难比较好坏。 三、采样方法 Sampler（采样方法） 决定笔触和结构的稳定性。常用的有： Euler a 是一个规整稳定的采样方法，出的图较平滑 DDIM 是一个过程不算稳定的采样方法，通常看起来比 Euler a 细节更多 DPM++ 2M Karas，最近在用的，过程稳定但有细节 有部分 Sampler 对高分辨率（1024px 以上）支持不好。 四、 ControlNet ControlNet 目前是一个需要额外安装的插件，可以用于给线稿上色并细化，或从草图细化。 你的草图可以决定的是： 60%-100% 的线条位置（构图） 主要色块位置。需要搭配图生图，并且色块越碎越好，需要提前做好整体的光影效果。因为 大部分 AI 只会画整，会画碎的比较少（Pastel 会画碎）。 细化风格（画风）由模型决定，不由你的草稿决定。模型风格对于画风影响非常关键。Prompt 也可以影响画风。 细化内容（画的具体是什么）由 Prompt 、草稿、模型共同决定，调整 CFG、Denoise 、 ControlNet 的 Weight 可改变三者比例。 下图为自己的较草的线稿使用 ControlNet 与 Anything V3.0 上色： （这个东西出名是因为某博说 ControlNet 初衷是洗稿……之前 Pixiv 也出过线稿上色的 AI，只是效果好和不好的差别，怎么没人说是搭配 PS 的线稿提取功能洗稿） 五、Lora Lora 是一种训练小模型的方法，可以在 15 张图以上生成稳定的单个角色图。 已有大量角色图积累的流水线漫画苦力会比较省事，搭配 ControlNet 可生成固定姿势，或者使用线稿稳定地上色。但对于连续动作的细微差别不太行，细节演出表现依旧需要依赖线稿，或手动重绘 训练过程分为裁剪、自动打标、训练，最终生成约 100M 左右的 Lora 网络。Web-ui 已自带。 写在后面 风格迁移渐渐成熟了，过拟合的问题在逐渐减少。减少过拟合的最终解决思路，还是把端到端的网络，按需求拆成了人为可控的 pipline。个人认为 AI 如果真的要作为工具，模块化的 pipline 是终点。 直接出成图的是对已有作品的模拟，抽抽卡，融入不到创意的工作流。 但是在发展好之前，地球可能已经枯竭了。","tags":["AI"],"description":"AI 画画现状","keywords":["AI绘画","stable-diffusion","AI绘图","AI画画"],"date":"2023-02-20T16:00:00.000Z"},{"id":"dontstarvetogether-linux-server","title":"部署饥荒联机版Linux服务器","content":"此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。 为什么要部署Linux服务器？因为玩到后面，只要一联机连主机都卡，闲得想试 这个中文教程 讲了native steam版的安装方法，包括了Cent OS缺少的库，坑全踩了一遍写得十分详细。官方文档实在太拉，基本就是没有文档，像跨平台缺库这种事情也没有解决，没有脚本。不过教程中对于网络环境问题与mod的配置方法提得不多。 我这里使用的是 Docker版本 。优点是 国内的云平台对于Dockerhub的加速后走内网流量，不使用公网流量下载镜像。而且国内的服务器公网下载速度堪忧。 Docker版本的文档写得对用户友好，易上手 文件管理集中，比较方便。原版服务器的mod和存档是分开放的 也有一些在国内环境下比较要命的缺点 网络环境原因，无法下载创意工坊mod。最近靠改 hosts 也不行了。 如果想开代理下载，docker容器开代理（设置环境变量）非常麻烦，具体来讲 如果每次开关代理都创建一个新的容器，Steam和游戏文件的更新都得再触发一次，又消耗流量又慢 如果动态修改容器的配置文件，docker需要重启才能生效，所有docker服务都得宕机一会儿 准备 一台至少2G内存的服务器 使用ssh连接服务器、传输并管理文件的技能 Docker的安装 由于涉及到Docker镜像和Dockerhub加速的问题，具体安装步骤建议看docker的文档和各个云平台。 我使用的腾讯云，见 安装 Docker 并配置镜像加速源 ，大约花费2分钟。 服务器防火墙设置 需要放行 10999，11000，12346，12347 这四个端口的UDP流量。 在国内云平台的控制台-防火墙中，放行服务器的这四个端口 如果服务器上iptables有流量拦截，也需要放行 饥荒服务器镜像的启动 mkdir ${HOME}/Klei # 创建存放数据有文件夹 # 拉取镜像并在前台启动 # 由于Steam要更新，根据网络环境可能要等比较久的时间 # 如果实在无法连接，再考虑给容器挂个代理下载。但总体不建议容器挂代理，因为我不清楚挂代理后steam是连接到服务器的游戏端口还是连到代理的端口上去了，取消容器的代理也非常麻烦。 docker run --name dst -v ${HOME}/Klei:/data -p 10999-11000:10999-11000/udp -p 12346-12347:12346-12347/udp -it jamesits/dst-server:latest 以上命令执行期间，可以去准备一下游戏存档和Mod相关文件。 准备游戏存档和Mod 我使用的Mac，饥荒的游戏文件相关目录位于 # 游戏存档 SAVE_DIR=\"~/Documents/Klei/DoNotStarveTogether/324927772/Cluster_1\" # mod下载目录 MODS_DIR=\"~/Library/Application Support/Steam/steamapps/common/Don't Starve Together/dontstarve_steam.app/Contents/mods\" # cd $SAVE_DIR # 进入存档目录 windows可以在饥荒游戏内点数据打开游戏存档，并在Steam中查看游戏的安装目录。 准备存档信息 点开 饥荒的账号 ，记下 Klei User ID 。如果没有就注册一个。 然后，新建 adminlist.txt ，并写入你的 Klei User ID。 $ vim adminlist.txt # 写入以下内容 你的Klei User ID 点开 自建饥荒服务器的页面 ，新建一个服务器，记下生成的Server Token，其他不用管。 然后，新建 cluster_token.txt ，并写入Server Token。 $ vim cluster_token.txt # 写入以下内容 你的Server Token 准备mods 不开mod的可以跳过这一步。 由于国内环境没法下载mod，需要把对应的mod文件复制过来。我为了方便就全复制了 cp -r \"$MODS_DIR\" mods 先查看一下目前的存档开了哪些mod。 $ cat Master/modoverrides.lua # 开启的mod return { [\"workshop-1172839635\"]={ configuration_options={ icebox_freeze=\"0.5\" }, enabled=true }, [\"workshop-1294206358\"]={ configuration_options={ }, enabled=true }, } 然后，编辑 mods/dedicated_server_mods_setup.lua 文件，写入上面的mod编号 $ vim mods/dedicated_server_mods_setup.lua # 写入以下内容 ServerModSetup(\"workshop-1294206358\") ServerModSetup(\"workshop-1595631294\") 至此，游戏存档和mods就准备好了。 转移游戏存档和Mods至服务器 上传游戏存档到服务器。打包和上传文件我一般使用GUI操作，用命令行的话是这样 cd ~/Documents/Klei/DoNotStarveTogether/324927772/ tar -cvf Cluster_1.tar.gz Cluster_1 scp Cluster_1.tar.gz root@myserver:/Klei/ 如果之前的服务器连接还在，等无新日志输出后使用control+c退出容器。如果已断开连接，重新用ssh登录服务器。 然后可以看到在服务器的 ~/Klei/DoNotStarveTogether 中有了一个 Cluster_1 存档。 转移游戏存档时，需要注意有两种情况（来自 文档 ） 第一种情况是，如果自己的存档开启了洞穴，把自己的存档覆盖过去即可。 rm -rf Cluster_1 tar -xvf Cluster_1.tar.gz 第二种情况是，自己的存档没有开启洞穴，需要 在自己的电脑中，存档的上一级有个 client_save 。复制下面的除了 session 外的所有文件到服务器的 Cluster_1/save 。 自己存档中的 Cluster_1/save/session 需要删除，其他文件可以直接覆盖 存档覆盖完毕后，启动容器 docker start -a dst # 如果最后输出了 Sim Pause 就代表 OK 了，按 ctrl + c 退出，容器继续后台运行 我第一次装Mod启动时发生了一个莫名其妙的 Segmentation fault ，程序退出了，但是第二次启动就好了。搜了一下 相关issue ，完全相同的情况，也是CentOS，偶尔发生，难稳定复现。 游玩 之前自己的存档叫什么名字就搜什么名字，加入就完事，好好玩吧w 参考资料： jamesits/dst-server docker-dst-server issue 饥荒独立服务器入门级快速搭建 Guides/Don't Starve Together Dedicated Servers - Fandom","tags":["服务器"],"description":"此文为 Docker 版饥荒联机版服务器在 CentOS 下的部署教程。","keywords":["游戏","服务器","Linux","Docker","摸鱼","饥荒联机版"],"date":"2022-12-27T16:00:00.000Z"},{"id":"记一道题排列组合题解","title":"记一道题排列组合题解","content":"难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。 题目 题来自 tg 里玩 ai 的小水群，很多人第一眼是想全排列剪枝……阶乘的复杂度得瞎了。 不过看到求方案数，帮人面试时被动态规划虐过的直觉在告诉我，凡事让写方案数不枚举方案的，很可能能写动态规划。 于是从动态规划的方面想去了。 关于素数 这个题有一个非常奇怪的地方，就是要和为素数。我不禁想，和为素数是对解题方法有什么加成吗？ （其实因为我最初看走眼了，以为是子集里所有数为素数，且和为素数，还以为素数和有什么定理） 素数的特殊点在于乘法分解，至于加法上与一般数有什么不同，以凡人视角未曾听说。并且这题还并不限于子集中取用什么数。 综上，和为素数对解题方法不仅没有什么加成，反而是多了个如何判断一个数是不是素数的问题。 至于如何判断素数，在 Leetcode 204，略，也没什么很省时间的方法，就是筛，不算简单。 子集动态规划 既然素数对于解题思路没有加成，就按一般数处理，很快写出了下面的思路： 一维dp中存下和为当前数的方案数 遍历更新dp，把新数n拆分成已有数+余数，按余数从大到小（已有数从小到大），把所有已有数的拆分方案加起来，再+1，即可得到当前数的子集数。 需要注意的是，为了保证不重复，也就是保证子集序列递增，已有数不会超过n/2（余数不会小于n/2） 更新dp时，也要计算新数n是否为质数，是的话把其子集数加入最终结果（算质数见leetcode 204） 由于取值范围1-2000，最大和为1000^2，100w，也是dp要遍历的次数。 下面的图是在解释什么叫“遍历但不用枚举子集”时写的，也是上述dp的步骤。 发题人仔细看了，并且手动枚举了10个数后，指出，我这会漏掉10=1+2+3+4。（后面自己发现这样还漏了145和235，后面越漏越多） 仔细回顾了一下之前的思路，发现我的问题出在递增的判断上。我当时认为保证递增序列，只要保证已有数小于余数就行，所以余数>2/n。 但不是的，比如n=10时，已有数为6，余数为4，6拆分为1+2+3就行，1234还是序列递增的。6拆分为2+4、1+5就不行。 归根结底就是我只把余数算了较大的一半，因为余数较大的一半肯定能保证序列递增。如果不想漏情况，余数要全部遍历，但怎么保证序列递增呢？比如6+4，如何只拆到1+2+3+4，不算1+5+4和2+4+4呢？ 于是更新了一下递增的条件： 已有数的拆分的子序列最大数小于余数，则拆分方案合法 再更新dp时余数范围： 余数从n取到1，分别计算子集数后再sum。 这样可以保证思路没问题了，但这个“已有数的拆分的子序列最大数小于余数”，明显当前dp只统计了子集数，根本不知道各个子集中具体最大数的情况。因此，我改成了个二维dp，含义和过程如下图： 简单总结一下，整个问题我简化到了求“和为 n 的子集数”，并利用二维动规从 1 求到 n。 n 是不是素数单独算的。 并且发现，其实更新每一行时，都是把上一行为止的方阵以“/”方向45度拆开，mask掉右边部分，按行求和后，从右往左地写进下一行，还能用gpu加个速（不是）。 另一种解法 发题人在看了我的新方案后，说在上面看到了类似杨辉三角之类的东西。并且得出了另一个方案： 和为 n 的子集组合数，为多项式 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1) 的 x^n 项系数 （我本来没理解，是死缠烂打地问才知道他在说什么） 仔细一想真的是这个理， x^n 对应的多项式系数就是排列组合到 n 的所有方案数了，也天然没有重复用数的问题。怎么想到的，神。 所以现在问题是：怎么求 (x^n+1)(x^(n-1)+1)(x^(n-2)+1)…(x+1)的多项式系数。 （当时已经不想动脑了，又是死缠烂打地问） 其实迭代就能算，因为 F(n) = x^n • F(n-1) + F(n-1)，对应系数直接挪位置后复制粘贴再相加就好了。 空间复杂度 这里有点难以定义 n 具体指哪个，默认 n = 2000 。 我的解法是要 1000^4 的空间去存方案数，矩阵中有很多地方是空的，有点浪费。 后者的解法要1000^2 空间去存多项式系数。省很多。 时间复杂度 以我的动规方法，时间复杂度为在 O(n^6)，准确说是O(n^2(n^2+1)(2n^2+1)/6)，因为要算到 (n/2)^2，且内部还有已填矩阵按行遍历。 以后者的的解法，时间复杂度为 O(n^3)，因为多项式的 n 需要到 (n/2)^2。 线性筛到 (n/2)^2 的素数, 时间复杂度为 O(n^2)。 总得来说还是数学好的强啊。 另外还有一个人非让我看完一个 30 分钟的高斯素数判断法，结果我一直在想 dp，搞得他怨念深重 hh","tags":["数学"],"description":"难得在网上遇到有认真在做题的人，在此表示深深的感谢。另外个人不太会写题解类的文，权当一个记事了。","keywords":["数学","算法"],"date":"2022-11-17T16:00:00.000Z"},{"id":"rust-closure-and-ownership","title":"理解 Rust 闭包与环境变量所有权","content":"本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。 阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。 什么是 Rust 的闭包 Rust 中的闭包是 一种函数 。与 Rust 普通函数不同，它可以 捕获函数外部的变量并使用 。 基本语法： |参数列表| {函数体} fn main() { let x = 1; let sum = |y: i32| { x + y }; // 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y println!(\"{}\", sum(99)); // 输出 100 let sum2 = |y :i32| x + y + 1; // 也可以省略花括号 println!(\"{}\", sum2(99)); // 输出 101 } 说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 let x = 1; ，为闭包外部的变量。 像 x 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“ 环境变量 ”。 闭包中环境变量的所有权 有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式 所有权 move（默认行为）。 可变借用，形式为 &#x26;mut param 不可变借用 ，形式为 &#x26;param 上述为 rust 所有权基础知识，不再赘述。 普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 捕获当前环境变量 的功能。 捕获当前环境变量 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作： 所有权 move 可变借用 不可变借用 具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。 回顾上面的例子，对于环境变量 x ，首先排除了所有权 move。 let x = 1; let sum = |y: i32| { x + y }; // 使用了 x println!(\"{}\", sum(99)); // 输出 100 let sum2 = |y :i32| x + y + 1; // 再次使用了 x println!(\"{}\", sum2(99)); // 输出 101 说明： x 在 sum1 中使用后，还能在 sum2 中再次使用，说明 x 所有权没有 move。 实际上，上述例子的 x 在闭包中是作为 不可变借用 使用的， 因为这个闭包实现了 Fn trait 。 闭包的三种 traits 闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。 三种 traits 如下（划重点，请背下来）： FnOnce ：表示此闭包调用时会获取环境变量所有权（ 所有权 move )。因此取名 FnOnce ，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。 FnMut ：表示此闭包调用时会对环境变量进行 可变借用 ，可能会修改环境变量 Fn ： 表示此闭包调用时会对环境变量进行 不可变借用 ，不会修改环境变量 并且， 一个闭包可以同时实现多个 traits 。比如实现了 Fn 的闭包也一定实现了 FnOnce （后续解释）。 上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问： “实现了 Fn 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 FnOnce ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？” 但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 FnOnce （所有权 move） ，但并没有调用 FnOnce 的 call 函数，而是调用了 Fn (不可变借用) 的 call 函数。 pub trait Fn&#x3C;Args> : FnMut&#x3C;Args> { extern \"rust-call\" fn call(&#x26;self, args: Args) -> Self::Output; } pub trait FnMut&#x3C;Args> : FnOnce&#x3C;Args> { extern \"rust-call\" fn call_mut(&#x26;mut self, args: Args) -> Self::Output; } pub trait FnOnce&#x3C;Args> { type Output; extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output; } 分析：如果 FnOnce 的 call 函数被调用，则直接传入了 self ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 Fn 的 call 函数传入的是不可变借用 &#x26;self 。 并且会发现， Fn 的前提是实现了 FnMut , FnMut 的前提是实现了 FnOnce 。 从继承关系来讲： Fn 继承 FnMut 继承 FnOnce 从访问变量的权限范围来讲： Fn &#x3C; FnMut &#x3C; FnOnce 也可以说， 闭包就算实现了 FnOnce 也不一定会用到所有权 move，因为可能还实现了 Fn ，那么环境变量的所有权会按 Fn 处理 。 由于上述继承关系，如果定义一个普通函数，参数需要传入 FnOnce ，实际上也可以传入 Fn 。 fn fn_once&#x3C;F>(func: F) where F: FnOnce(usize) -> bool, // 传入闭包 { println!(\"{}\", func(3)); } fn main() { let x = vec![1, 2, 3]; let closure = |z|{z == x.len()}; // 此闭包实现了 Fn、 FnMut 和 FnOnce fn_once(closure); // Fn 可传入标注为 FnOnce 的参数 println!(\"{:?}\", x); // x 还能用，所有权没转移 let closure2 = move |z|{z == x.len()}; // 此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部 fn_once(closure2); // 传入 FnOnce println!(\"{:?}\", x); // 报错，x 已经没了 } 说明：fn_once 需要接收 FnOnce 的闭包作为参数，但传入 Fn 也是合理的，编译器也会按照 Fn 的调用方式处理为不可变借用，并不会因为标注着 FnOnce 而变成所有权 move。 闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅 闭包实现三种 traits 上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。 闭包实现 traits 是 隐式 的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。 实现 FnOnce 所有的闭包都自动实现了 FnOnce 。不用特别做什么。 但更普遍的情况是，定义闭包时会顺带实现 Fn 或者 FnMut 。如果想要只实现 FnOnce ，不要实现另外两个，需要用 move 。这个关键字会强制转移所有权，使闭包无法满足 FnMut 和 Fn 的条件。 例：只实现了 FnOnce 的闭包 fn main() { let x = [1,2,3]; let closure2 = move |z|{z == x.len()}; // 只实现了 FnOnce，所有权转移 closure2(2); println!(\"{:?}\", x); // 报错，x 所有权被转移 } 实现 FnMut 在闭包中修改外部变量，即实现了 FnMut （自然也实现了 FnOnce ），同时没有实现 Fn 。 fn main() { let mut x = vec![1,2,3]; let mut closure = ||{x.push(4);}; // 修改了外部的 x, 实现了 FnMut， x 所有权没有转移 closure(); println!(\"{:?}\", x); } 实现 Fn 在闭包中访问外部变量，不做任何修改，即实现了 Fn （自然也实现了 FnMut 和 FnOnce ）。 fn main() { let s = String::new(); let update_string = || println!(\"{}\",s); // 访问外部的 s, 实现了 Fn exec(update_string); exec1(update_string); exec2(update_string); } fn exec&#x3C;F: FnOnce()>(f: F) { // Fn 也可以传到 FnOnce 类型 f() // 调用的是 Fn，所有权不会转移 } fn exec1&#x3C;F: FnMut()>(mut f: F) { // Fn 也可以传到 FnMut 类型 f() } fn exec2&#x3C;F: Fn()>(f: F) { f() } 闭包自身的所有权 上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？ 答案是， Fn 是 Copy， FnMut 和 FnOnce 是所有权 Move。 fn main() { let x = vec![1,2,3]; let closure = |z:usize|{ z == x.len()}; // 实现了 Fn outter(closure); // 通过 outter(closure); // 通过 let closure2 = |z:usize|{ x.push(4);z == x.len()}; // 实现了 FnMut outter(closure2); // 通过 outter(closure2); // 报错, closure2 的所有权已被转移 } fn outter&#x3C;T>(mut func: T) where T: FnMut(usize) -> bool { // Fn 可以传到 FnMut 标注的参数上 let a = func; } 这是非常合理的，对应着 Rust 借用的规则 在同一时间点，对于同一个变量， 要么 只能有一个可变借用(FnMut)， 要么 只能有 多个不可变借用 (Fn)。 至于 FnOnce ，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。 一些建议 如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。 另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。 如果仍然难懂，可评论提出，后续改进。","tags":["Rust"],"description":"B站反查用户弹幕小记","keywords":["Rust","闭包","Closure","所有权"],"date":"2022-06-13T16:00:00.000Z"},{"id":"PPT母版的制作与使用方法","title":"PPT母版的制作与使用方法","content":"由于我需要批量编辑 PPT 的样式，但 PPT 没有组件化样式的概念，所以开始学习用母版。虽然之前也用过，但始终不明白 PPT 的迷之逻辑，有时候是调整了母版但不生效，或者调整了局部结果别的地方也被影响了……今天才大概明白了一点（还是 Figma 和 Sketch 的逻辑好懂……）所以从我的角度说一下对 PPT 的模版理解。 这个问题明显视频解释更好，但不太想做视频（躺）因为每次做视频前写大纲都要写好久…… 图源 Github，图片不显示挂代理 Please。 概念解释（母版/版式/主题） 打开母版 母版的入口在“视图”→“幻灯片母版”。Mac 上的快捷键是 command + alt + 1 。 什么是母版和版式 母版，是 PPT “主题” 的一部分，可以对多张幻灯片的排版进行统一的修改。 我们日常制作的 PPT，都会基于一个母版（虽然很多人不去用）。在后面的内容中，对于日常制作的 PPT，我会称为“PPT 内容”。 一个正常的母版包含着一个“ 幻灯片母版 ”和多个“ 版式 ”。 样式继承 “ 版式 ” 会继承 “ 幻灯片母版 ”（以下简称为 母版 ）中的一些元素的样式（包括位置、字体、大小、颜色等）。也就是说，只要更改 母版 里的样式， 版式 也会自动更新。 所以是哪些元素可以被继承呢？在菜单栏里的“母版版式”中，有五个选项分别是 标题 正文 日期和时间 页脚 页码 以上就是所有样式可以被继承的元素。是的，你在母版上 只有这五个元素的样式可以被继承 。你可以尝试在“主题”选项中打开任何一个母版，会发现所有母版都是这五个元素。你无法擅自增加其他可以被继承的元素。 并且以上显示的每个元素在母版上都只能设置一种样式，**你无法同时给标题设置两种样式。**也就是说，如果你有设置 一级标题 + 二级标题 样式的需求，你无法通过设置 母版 上的样式实现二级标题。你只能通过 版式 去设置二级标题。 另外 背景 也可以被继承，但它属于在正式的 PPT 内容中不可编辑的元素。 如何编辑元素样式 选中元素，在“开始”选项里编辑即可。 通常情况下，母版的排版需要设置得尽可能通用，之后的每个版式都将以母版为基准进行编辑。母版本身并不能直接被 PPT 内容所使用，做 PPT 能选择使用的只有继承了母版样式的 版式 。 版式如何继承母版 继承标题样式 选择一个版式（或点“插入版式”），给菜单里的“标题”打上勾。 需要注意的是，如果你在“开始”里添加一个文本框，移动到标题的位置，并不会被 PPT 识别成标题。从外面粘进来的文本框也一样，只会被识别为“一个普通的文本框”。之后批量更新标题的样式时，也并不会被更新。 所以在版式中设置正确设置标题的方法只有这一个——给标题打上勾。 想设置二级标题怎么办？ 母版没有二级标题，只能用下面说的占位符实现。 继承正文样式 继承正文的正确方法，是点击上一节图中的“插入占位符” ，有好几个选项，一般选内容就可以了。 此占位符生成的文本框的样式和 母版 中完全一致。如果说 母版 的样式是全局变量， 版式 中再次修改的样式就是局部变量。 对于 修改过的部分 ，母版里对正文的更新不会导致版式中的正文更新。比如： 母版中的正文字号是 20px 版式中的正文字号不变，但是给加粗了 修改母版中的正文字号为 22px 版式中的正文字号变成 22px，但仍然加粗。 ❗️注意：不要从“开始”里新建文本框！也不要从母版界面外粘贴进来！ 原因同上，非占位符生成的文本框，对其样式的修改并不会真正改到“正文”的样式。使用的时候就会发现了，更新版式了但 PPT 内容样式完全没更新……这种情况就是因为版式中的文本框不是占位符生成的 所以如何实现二级标题？ 添加一个占位符 添加文本样式 继承日期和时间、页脚、页码 在版式中，给“页脚”打上勾，以上三者的样式都会被继承。 使用版式 退出“幻灯片母版”模式。在正常 PPT 内容的模式下，菜单栏“开始”中有个“版式”选项。在侧边栏选中一页（或多页） PPT，点击相应版式即可应用。 如果你原来的 PPT 内容不是依靠版式中的“占位框”排版，而是靠手动创建的文本框，那直接应用版式是不会修改你原来的内容的。 换言之，如果想要达到批量、统一的排版效果，需要尽可能地应用版式给出的占位框，而不是手动创建的文本框。 在“ 版式 ”选项下面一个“ 重置 ”，意思是重置到当前版式初始的样式。 比如，版式中的文字样式设置的是纯文本，而 PPT 内容里修改为列表。点击“ 重置 ”会使得列表项消失，再次成为纯文本。 刷新修改后版式 版式修改后，有时候并不会自动应用到 PPT 内容上去，这种情况通常发生于在 PPT 内容中对占位框的位置、大小等等进行了调整。 比如在 PPT 内容中调整过的占位框位置，将不再随着版式更新。如果需要复位（让占位框位置能随着版式更新），可以再应用一次版式。 正在使用的版式 对于被用到了 PPT 内容上的版式，只有一个建议： 不要随便删除版式里的元素！ 这会导致已经被应用了版式的内容格式被清除……你需要去重新应用版式。 写在后面的吐槽：排版这种事情 Layout + 组件化 不香吗！PPT 的样式复用实在太局限了。看祖传的 PPT 排版看得我脑壳疼，每一页的小标题位置都不一样，字体也是用得乱七八糟的。排版的四原则，“亲密”“对齐”“对比”“重复”，每一项都很重要。但一项都不满足这是怎么做到的！强迫症（伪）哭晕在厕所。 其实还是祖传的习惯问题。比如 Word，小时候我也是有过一段时间空格排版居中……现在谁还空格排版居中，我见一个打一个（狗头）","tags":["教程"],"description":"","keywords":["powerpoint","母版"],"date":"2021-11-11T16:00:00.000Z"},{"id":"pure-function","title":"纯函数与算法","content":"自从接触了纯函数，刷算法题刷得举步维艰。 什么是纯函数：同样的传入参数，一定可以得到相同的输出 纯函数又被称为无副作用的函数，不会改变外部的状态。 比如在 JS 中，array.slice()对数组的切片，返回的是一个新的数组，为纯函数。 相对的，array.splice()对数组的插入与删除是对于原数组操作，不是纯函数。 纯函数的意义，在于保证 不会对函数外部的状态有隐式的修改 。这在大型的、遍地都是状态的系统中非常重要。如果不保证纯函数，多个函数内部去修改了同一外部状态，容易出现意想不到的 Bug。 图的邻接矩阵定义 let map = { point: ['V0', 'V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7'], side: [ [0, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0], ] } 图深度遍历的非纯函数实现 // DFS 深度优先遍历，从 第 index 个节点开始. visited 记录已访问的节点，全局共用一个 visited function DFStraverse(index: number = 0, visited = [map.point[0]]) { if (visited.length === map.point.length) { console.log(visited.toString()) return } map.side[index].forEach((isSide, targetv) => { if (isSide &#x26;&#x26; !visited.includes(map.point[targetv])) { visited.push(map.point[targetv]) DFStraverse(targetv, visited) } }) } 以上代码的问题： map 定义在了外部，和别的函数共用 visited 是全局共用同一个，但却每次都要作为参数传入，逻辑上既不合也没有必要。并且作为函数参数（而不是全局变量），每次都对 visited 作了修改。这里还好，因为要的就是修改后的 visited（实际上是全局的 visited）。但如果题目是一个回溯问题，就需要管理 visited 的状态，在修改了之后，递归出栈时还得改回来。 图深度遍历的纯函数实现 // DFS 深度优先遍历，从 第 index 个节点开始. visited 记录已访问的节点，全局共用一个 visited // 纯函数实现 function DFStraverse(index: number, map: { point: string[], side: number[][] }) { const visited = [map.point[index]] function traverse(index: number) { // 终止条件 if (visited.length === map.point.length) { console.log(visited.toString()) return } map.side[index].forEach((isSide, targetv) => { if (isSide &#x26;&#x26; !visited.includes(map.point[targetv])) { visited.push(map.point[targetv]) traverse(targetv) } }) } traverse(index) } 使用闭包，把共用的 visited 固定为状态。内部再定义函数作递归。 map 也作为外层的参数传入，里面不去修改。 状态其实在各种算法里挺重要的。不少空间换时间的极限操作都要用到。 算法注定是“不纯”的，能做的也不过是用闭包来保存状态。有时候觉得，纯不纯的也没有这么重要。","tags":["算法"],"description":"自从接触了纯函数，刷算法题刷得举步维艰。","keywords":["纯函数","算法"],"date":"2021-09-24T16:00:00.000Z"},{"id":"github-hosttools","title":"Github hosts 更新脚本(MAC)","content":"此工具已更新至 Github 。 安装卸载脚本 自动定时运行 平时不占内存，运行时几乎不占内存 原文如下： 最近 Github 墙得越来越厉害了。写了个 Shell 工具，连不上的时候就更新一下。可以配合 Alfred 使用。 使用的 host 源来自 这里 。其实用 SwitchHosts 更新也行，但我真的讨厌 Electron App……麻了，现在听个歌写个笔记 1个多 G 的内存就没了。 也可以用写成定时程序后台运行，加个 LaunchDaemon 文件就行，但，我不会打包 Mac App……文件这么散着分发也太 emmm，而且别人装起来也麻烦…… 麻烦归麻烦还是要写的…… 文件和说明已经上传到 Github 。 下面这个文件保存取名为 hoststool 赋予执行权限 chmod +x hoststool 。如果为了执行起来方便，可以放进环境变量的目录（比如/usr/local/bin） 然后就可以使用 hoststool -u 更新 host 了，运行结果会发系统通知。之前可以自己看看 hosts 内容有没有问题。这是有几率失败的，因为用的 gittee 的 host 源，经常会提示文件疑似违规……这种时候再请求一次就好了，第二次就不违规了。我也不知道为什么。 （定时任务的部分在后面） #!/bin/bash showHelp() { echo \"-u [source_url] update github hosts. You can specify a custom host source\" echo \"-b backup /etc/hosts to /etc/hosts.backup\" echo \"-r recover hosts.backup to hosts\" echo \"-f list files in /etc which contains \\\"hosts\\\"\" } # ====== Main ===== if [ $# -eq 0 ]; then showHelp;exit 0;fi # CONF download_dir=\"$HOME/etc/hoststool\" github_hosts=\"https://gitee.com/yuchi-shentang/GithubHosts/raw/main/hosts.txt\" if [ ! -d \"$download_dir\" ]; then mkdir -p $download_dir fi case \"$1\" in -f) ls /etc | grep hosts; exit 0;; -b) sudo cp /etc/hosts /etc/hosts.backup; exit 0;; -r) sudo cp /etc/hosts.backup /etc/hosts; exit 0;; -u) if [ $2 ]; then github_hosts=$2;fi curl -o ${download_dir}/hosts ${github_hosts}; if [ $? -ne 0 ]; then echo \"[ERROR] 获取远程 host 出错，请尝试更换 source 或检查 download_dir 读写权限\" osascript -e 'display notification \"获取远程 host 出错，请尝试更换 source\" with title \"hoststool\"' exit 1 fi # Validate host content length lines=$(awk '{print NR}' ${download_dir}/hosts | tail -n1) if [ $lines -lt 10 ] then echo '[ERRO] 远程 Github Hosts 无效（Gitee源不稳定），通常重试即可' osascript -e 'display notification \"远程 Github Hosts 无效（Gitee源不稳定），通常重试即可\" with title \"hoststool\"' rm ${download_dir}/hosts exit 1 fi # Remove old content begin=$(sed -n '/# ==== Github Start ====/=' /etc/hosts | awk 'NR==1{print}') end=$(sed -n '/# ==== Github End ====/=' /etc/hosts | awk 'END{print}') echo \"Removing old hosts. Start at line \\\"${begin}\\\", End at line \\\"${end}\\\"\" cat /etc/hosts | sed \"${begin},${end}d\" > ${download_dir}/hosts.tmp if [ $? -ne 0 ]; then ## Trip Failed echo \"[INFO] 当前 Host中 无旧的 Github Host 标记可清除\" else ## Trip Succeed, move result echo \"[INFO] 清除旧的 Github Host 标记\" sudo cp /etc/hosts /etc/hosts.backup &#x26;&#x26; sudo cp ${download_dir}/hosts.tmp /etc/hosts; fi # Add new hosts sudo bash -c \"echo '# ==== Github Start ====' >> /etc/hosts\" # Add github host if [ $? -ne 0 ]; then echo \"[ERROR] 无root权限，请尝试运行脚本手动输入密码\" osascript -e 'display notification \"无root权限，请尝试运行脚本手动输入密码\" with title \"hoststool\"' rm ${download_dir}/hosts.tmp rm ${download_dir}/hosts exit 1; fi sudo bash -c \"echo \\\"# Updated at $(date)\\\" >> /etc/hosts\" # Add github host sudo bash -c \"cat ${download_dir}/hosts >> /etc/hosts\"; sudo bash -c \"echo '# ==== Github End ====' >> /etc/hosts\" rm ${download_dir}/hosts.tmp rm ${download_dir}/hosts echo \"[INFO] Github Hosts 块更新于 $(date)\" osascript -e 'display notification \"Github Hosts 已更新\" with title \"hoststool\"' exit 0;; -h|--help) showHelp; exit 0;; *) echo \"Unknown command\"; showHelp; exit 1;; esac 定时 保存以下文件为 hoststool.plist 。 &#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?> &#x3C;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> &#x3C;plist version=\"1.0\"> &#x3C;dict> &#x3C;key>Label&#x3C;/key>&#x3C;string>hoststool&#x3C;/string> &#x3C;key>ProgramArguments&#x3C;/key> &#x3C;array> &#x3C;string>/usr/local/bin/hoststool&#x3C;/string> &#x3C;string>-u&#x3C;/string> &#x3C;/array> &#x3C;key>RunAtLoad&#x3C;/key> &#x3C;true/> &#x3C;key>StartInterval&#x3C;/key> &#x3C;integer>3600&#x3C;/integer> &#x3C;key>StandardOutPath&#x3C;/key> &#x3C;string>/Library/Logs/hoststool.log&#x3C;/string> &#x3C;key>StandardErrorPath&#x3C;/key> &#x3C;string>/Library/Logs/hoststool.log&#x3C;/string> &#x3C;/dict> &#x3C;/plist> 把 /usr/local/bin ，改成你存放脚本的路径。 时间间隔为 3600 秒，可以自己修改。 然后执行 $ sudo cp hoststool.plist /Library/LaunchDaemons $ sudo chown root:admin /Library/LaunchDaemons/hoststool.plist $ sudo launchctl load -w /Library/LaunchDaemons/hoststool.plist 执行完就会立刻运行一次脚本。由于定时任务是 root 用户不是个人用户，不会有通知，可以去 Console 看 log。","tags":["科学上网"],"description":"Github hosts 更新脚本(MAC)","keywords":["Github","hosts","更新","脚本","Mac"],"date":"2021-08-06T16:00:00.000Z"},{"id":"网盘目录程序比较","title":"网盘目录程序比较","content":"比较一下私人网盘有关的程序 cloudreve onemanager zfile nextcloud 1. Cloudreve 是个网盘程序，意思是在服务器上运行这个程序你就能成为了千度网盘的老板，可以拥有很多注册会员，还可以给他们收费，从此发家致富(bushi)。 需要服务器和域名 文档不全，社区还行，使用方法社区找 是真的网盘，不是网盘列表程序，适合建站用，One Drive个人帐号不能用。 没事记得备份 (不知道换服务器时迁移数据麻不麻烦，反正可以用Docker) 2. One-manager 网盘列表程序，阿里云或者 Onedrive 的网盘里的文件列出来，便于集中分享。单纯是个人分享站。 serverless，不需要服务器和域名，可白嫖资本家的服务 README 即文档，issue 即社区。README写得像随便记的笔记，好在也不复杂都有引导 功能很多，除了基础的分享、预览、下载功能，可以上传重命名等进行管理(但是界面不好看导致体验并不好)。不依靠程序设定，而是把网盘里的文件作为功能性文件，挺方便的，再次部署时不用迁移任何数据 可以预览的文件格式很多，没什么bug 界面比较丑，前台可以换主题。但好看的功能不全，后台不能换主题(强行要换也是可以但可能功能不全)。 3. zfile 是网盘列表程序，同 One Manager。 需要服务器和域名。但看情况也许可以 Serverless ？不清楚Java 有文档，README说得很清楚，不用一脸懵逼找社区 功能不多，基础的分享、预览、下载功能，前端好，交互体验好 文件预览有Bug，OneDrive的视频流经常加载不出来，FLV会一直加载失败。但，好看是真的 开发者是98年的(暴击) 4. nextcloud 个人网盘程序，和Cloudreve一个性质的。很多插件，交互是最好的，也比较耗资源，适合家里获团队用。 external storage 装起来复杂，不好白嫖资本家。","tags":["服务器"],"description":"比较一下私人网盘有关的程序","keywords":["自建网盘","网盘目录","onedrive","alist"],"date":"2021-05-25T16:00:00.000Z"},{"id":"hslrecord","title":"m3u8直播流实时录屏小记","content":"最近由于发现自己想回看的直播会被剪镜头，所以下定决心以后要学会录屏。但本人有强迫症，一般的录屏软件满足不了我的需要，主要是： 会录出鼠标操作、网络卡顿、水印等影响观感的画面 由于显示器和录屏软件的和原视频帧数可能不同步的问题，非常容易造成画面卡顿 体积远大于原视频，二压后画质失真重 通常来讲，能拿直播时的视频流就别真的屏幕录制。本来视频分段就都在缓存里，应该是有比较容易实现的办法做到实时保存的才对。 本文主要分为以下三个部分 m3u8简介 保存视频分段与合并 DRM 版权保护问题 m3u8简介 目前的各大流媒体平台视频（不管是直播还是回放）大多都会把视频切片为很小一段，长度可能10s左右，通常是.ts后缀的文件。而这一堆.ts文件的索引文件为m3u8文件。 一个通常的m3u8文件是如下格式 #EXTM3U #EXT-X-VERSION:3 #EXT-X-TARGETDURATION:10 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.000000, #EXT-X-PRIVINF:FILESIZE=3192240 https://website/xxx-00001.ts #EXTINF:10.000000, #EXT-X-PRIVINF:FILESIZE=3206904 https://website/xxx-00002.ts #EXTINF:10.000000, #EXT-X-PRIVINF:FILESIZE=2576164 https://website/xxx-00003.ts 也就是说，如果我们实时保存流媒体平台的视频，正常情况下，会保存一个.m3u8索引文件，和一堆.ts文件。有了这些文件我们可以直接使用支持m3u8的播放器（如IINA、VLC）进行播放。 m3u8是 HLS(HTTP Live Stream) HTTP直播流格式的基础。 保存视频分段与合并为MP4 工具准备： ffmpeg ：强大的命令行视频处理工具，网上有很多安装教程，这里不重复 Chrome插件-猫抓 ：资源嗅探插件，下载需要科学上网 一个多线程的下载器（为了下载速度更快），如 aria2，网上有很多教程，这里不重复 一个支持 使用正则表达式批量替换文字 的txt编辑器，如sublime、vscode 以上方法会比较硬核，傻瓜式的方法可只准备下面这一个 Chrome插件-Stream Recorder ：傻瓜式HLS一键保存插件，下载需要科学上网 方法一：下载所有分段并合并（稍硬核） 首先打开一个视频网站，这里以优酷的综艺为例。 打开后点击右上角的猫抓插件，会看到一个m3u8文件，和一堆ts文件。 首先我们可以先点下载按钮下载到本地 .m3u8 文件。 猫抓插件提供了对m3u8的解析，点击文件旁的放大镜就可以看见。 复制所有的内容，放到支持多线程的下载器里下载。 下载完成后，先整理一下本地的文件目录成如下 （为了看起来更清晰，以上各个文件名我已修改） 然后修改m3u8文件。我这里使用的编辑器是vs code。 m3u8文件里的原链接是这样的： https://valipl-vip.cp31.ott.cibntv.net/67756D6080932713CF4E/0300609724C6163EBF1C35DAC076221D-4673-49D8-A932-70FA-00001.ts?ccode=0502&#x26;duration=6237&#x26;expire=18000&#x26;psid=28ae2c9bf869cf6f9ae28c814098b5fe43346&#x26;ups_client_netip=3b4081be&#x26;ups_ts=1620641730&#x26;ups_userid=300380294&#x26;utid=Xd0WGHofZhACAXtwDp2%2BGj22&#x26;vid=XNTE0MDg5MTgyOA&#x26;sm=1&#x26;operate_type=1&#x26;dre=u38&#x26;si=78&#x26;eo=0&#x26;dst=1&#x26;iv=1&#x26;s=cbcad844c5894d209b9f&#x26;type=mp4hd3v3&#x26;bc=2&#x26;hotvt=1&#x26;t=d91e686d230165f&#x26;cug=1&#x26;rid=20000000DC17B06335EBB96917703D4A6B2DA12102000000&#x26;vkey=B84707ca23f9e5899f9b0b9d97e4d1851 非常的长。我们首先要做的，是去掉每一行 ? 之后的所有字符。使用正则表达式批量替换，在查询里输入 \\?.*?\\n ，替换为 \\n 。注意要勾选正则表达式的符号。 然后要替换的是 https://... 内容，替换为本地的文件路径，让最后的剩下文件名指向本地的文件。 替换后的.m3u8文件是这样的 此时可以使用支持m3u8的播放器打开m3u8文件，观看是视频能否正常播放。 能正常播放后，使用ffmpeg合并为mp4，不用转码速度就很快 ffmpeg -i index.m3u8 -vcodec copy -acodec copy output.mp4 完成 缺点 对于回放的完整视频文件，通常会提供m3u8索引文件，但对于直播通常是没有m3u8索引的。这时候依然可以按上述方法下载所有分段，用ffmpeg进行合并。 但是直播时无法一次获取到所有ts的链接，而是边播边给。就算猫抓能批量复制链接，但为了防止直播时出什么意外（比如浏览器无响应了、突然断电），看一会儿就得存，无法好好享受直播，最后上千个文件的列表，也变得很麻烦。 使用 Stream-Recorder插件 傻瓜式保存 上一个方法的所有步骤，其实都能用这个插件搞定 Chrome插件-Stream Recorder ：傻瓜式HLS一键保存插件，下载需要科学上网 使用上也很简单。视频播放开始后，点击这个按钮就行了，自动保存视频分段，同时合并为一个mp4。 简单介绍一下，这个插件主要有三个模式 Live：实时获取直播时的ts分段，可以没有索引文件自动合并 HLS：看回放时获取ts分段，可以没有索引文件自动合并。但是像B站这种用m4s非标准HLS的似乎用不了。 Capture：实时获取正在播放的HLS，直播回放均可，大部分视频格式都能用，兼容性最好。缺点是真的要一直播着。 也就是直播时使用Live抓取或Capture录屏，且可以自动合并视频音频，相当于直播时边看边存。 看回放时使用HLS或Capture保存视频。 DRM 版权保护问题 并不是所有的m3u8视频都能这么下载，有的经过了DRM(Digital rights management)的保护。这样的视频下载下来也是无法直接合并的。 有版权保护的视频，使用猫抓查看m3u8解析时，可以发现这么一行 Stream Recorder 也不支持加密视频的下载。 解密不在讨论范围内（我也不会），总得来说还是尽量支持正版。 PS：目前风气真的太严了，如果不是发现片段被删减，也不会想到去研究怎么录屏。既然花了钱买了相应的单场直播，也说明了会提供回放，要求拥有一个和直播时相同的回放个人觉得并不过分。最终给一个删减版，感觉这服务有些不值得，即便直播和录屏混剪都得给剪出来一个完整的版本。","tags":["经验"],"description":"","keywords":["web","m3u8","hsl","扒视频"],"date":"2021-05-11T16:00:00.000Z"},{"id":"记录一次被骗388巨款的经历","title":"记一次被骗388巨款的经历","content":"我原本以为是只是一场诱导式的恶意营销，细想来竟是一个彻头彻尾的楚门的世界。 1 拉人 昨天下午我逛商场时，一个短发美女姐姐叫住我说，他们的造型店在搞活动，有一个嘉宾来做一天发型设计，邀请剪短发的路人去体验。 由于我长相小，经常会成为骗子的下手对象，也明白这样就是诱导消费，换做从前都是装聋。然而许久没有出门，昨天脑子进水，想看看是什么花样。 我说我没钱，我才上大学，很穷。 美女姐姐说，一百多剪一次也贵吗？ 我：贵。 美女姐姐说，没事，你不能成为我们的潜在客户也没关系，我们发型师做设计是免费的，剪不剪由你决定。不剪也没事，你就听一听设计理念，今后一定会有所启发。 又 battle 了几轮，我想那就去吧。然后果不其然，美女姐姐一路带出门，带路到了商店的背面的路对面，比较偏僻没什么车，马路上全是隔着的围栏。 我看这地儿明显不对劲，说您先走，我回去了。美女姐姐说来都来了，去看看吧。 在路上，这位美女一直在说我头发塌，后面剪断层了。我寻思着都活过了两轮，所有人都是说我头发炸的，好不容易拉直打薄才到了刚刚好的水平，这还是第一次有人说我头发塌。 美女又问我你对自己的发型满意吗，哪里剪的。我说我很满意，40块剪的，很帅。 美女说，他可以让你的发型更上一层楼。 2 油腻 进去是一家造型中心的装饰，装修一般，东西有些乱，在做头发的顾客只有一个，但人还显得挺多的。 一个身高不到170体重看起来180的Tony让我坐下，满脸堆笑，伸出手握手说： “您好，您贵姓？” “我姓林。”（假名） “我叫星x，是今天来这的嘉宾，您可以叫我星哥。” 然后 Tony 分析起我的头发，说我头发的重量感都在耳旁，顶部太塌，头骨太平，和那位美女的说法如出一辙。“为了设计更符合您的脸型，可不可你请你把口罩摘下来呢？” 我觉得这算是个正常需求。摘下了口罩。然后…… Tony ：“你今天打了高光吗？” “没有。”（这人看不出我没化妆？） “那你鼻子天生这么立体吗？” 我：“光打得好吧。” （你有眼疾吗？） “你知道你五官最吸引我的部位是哪里吗？” 我说不知道。 Tony笑了下，“是你的嘴唇。” ……………艹 Tony：“我应该今天应该好好收拾一下，主要是平时接待的都是30多岁的客户，没想到，可以遇见你。” 我无语了，这人有病。理发店Tony大多喜欢套人近乎，这种程度的还是头一次。长得帅的是撩，长得丑的是性骚扰。 3 洗发小哥 Tony说让我冲一下头发，看看发型发量和剪裁。 洗头小哥问，你是哪儿人，我说我是四川的。洗头小哥立刻说了句（貌似是）四川话。 我说您也四川的吗？ 小哥：“我是云南的，在北京北漂。你知道我们这位嘉宾的价钱吗？” 我说不知道。 “这位嘉宾和很多明星艺人合作过，平时剪一次头要588。” 我：“我是学生，没钱。” 小哥：“你可以好好和他谈一下，应该学生的话能更低一点。” 小哥还向我打探了一下我最贵的理发消费是多少。 4 装x 回到梳妆台，Tony向我展示他手机，锁屏密码直接在我眼皮底下输入的。屏幕是他和关晓彤的合照，黑色的背景，国民闺女在照片上像在T台上一样有范，Tony穿着黑西装。相册里还有和高圆圆的合照，两照片风格差不多。当时时间太短没看细节。后来想想，这是P的，我也不是没见过明星的私下合照，哪有私下合照背景纯黑、这么正式和完美的。 Tony说，他平时是做培训的，也给明星艺人做造型。顾客受众一般都是30多岁的，会员费很贵，要两千。我表明我没钱，付不起，不是他的顾客。他说不是也没关系，你就先听听，你觉得可以了再考虑，要是你做得不满意我也不收你钱。 然后Tony又开始说我头发塌了，说有办法让发根蓬松维持四五个月不用去理发店，也能拉长上庭比例。我容易对没见过的东西有兴趣，也想看看是怎么发根蓬松法，再说我确实上庭稍微偏短，觉得可以试试。事后我总结了一下，只想要骗一次钱的人，说四五个月也肯定是忽悠人的。 我问Tony多少钱，Tony说我平时都是500起步，这次给你488。 我表示还是太贵了。Tony又说学生价的话，我可以给你388。然后又开始展示他的手机里看起来高端的东西，表示388真的很便宜。我勉强接受了。 Tony说：“我给你这么个优惠价”，然后俯下身轻轻在我耳边说，“一会儿你要好好想想怎么报答我。” （先别急着吐，后面还有） 5 x骚扰 Tony开始聊老家是哪，我说四川的。他说成都吗，春熙路他去过一段时间，妹子都很不错。“当时我在那一天就干三件事，你知道是什么吗？” 我：……不知道 Tony：“喝酒，上网，泡妞。” Tony：“你知道为什么我愿意给你做这个头发吗？” 我非常无语，我觉得他真的需要个捧哏。 Tony俯下身，到我耳边悄悄说：“因为我还挺喜欢南方姑娘的。” ……我有点恨我是个面瘫脸。 Tony拔下箍头发用的铁丝，上面缠着红色绒布，说给你变个魔术你信不信。 我抬头看了他一眼，然后他把那个铁丝缠绕成红戒指的形状，把我手拉过去戴我食指上。 我无了个大语，说：“这就是你泡妞的方式吗？” Tony一把把铁丝拔下来，“什么泡妞的方式，我在说这是手艺人呢，编得挺好吧，我还专门看了你手指的宽度做的。” 我：“手艺人做什么不好，做戒指，不正经。” Tony：“嘿，她还说我不正经？以后不给你剪头发了。” （希望看到这你还没有吐） 问到学校，问我多大了，大几。我说我在读研。 Tony：研究生没有工资吗 我：有是有，一个月四百 Tony：这么少啊？感觉在学校收获了什么 我：没什么收获 Tony：收获了男朋友也算 我：好吧，收获了男朋友 Tony：挺好啊，解决了大事。你男朋友不给你提供你经济上的资助吗？ 我：没有，我们各管各的。 Tony：要不我按你的标准给你介绍一个男朋友？ 我：？这不太好吧 Tony：男性朋友 我：？这也不好吧 Tony：你不接受异性朋友？ 我：对 6 关于钱 无一例外，推销就是让人花尽可能多的钱。而我之所以叫它骗钱，而非诱导消费，是因为完全超过了一般诱导消费的手段与范畴。 这个理发店有人专门负责陪聊天，陪聊小哥自称在德云社干过一段时间，老家是四川达州（怎么不是云南就是四川）。他主要负责宣传 “高端私人定制” 的概念。这应该是利用社会心理学的范畴了，但口才明显不比美女姐姐和Tony，可以说是很烂，说服不了我这种穷逼逻辑思维者。再说我一向对私人定制、高级vip等模式不看好，我一向认为商品化流水线化压低价格的形式才是最能说服大众购买其产品的。 我也很直接地说我这种人就是小白鼠，你们就是学着怎么解剖小白鼠的人。陪聊小哥解释说，我们和客户的关系更像是朋友，真心诚意为客户在服务。 然后又轮到Tony上场了。这个时候 Tony已经没有x骚扰了，重心全在钱上。因为我明显表示对发型不满意了，他开始宣传起了企业的靠谱性，打开了宣传册子。 “我们这个店在全国都有连锁，2013年开始就有店了，在北京、天津……” 我看了看，这个册子上店的名字和招牌不一样。事后再看大众点评，上面的名字又不一样。 我问Tony你不是被请来的嘉宾吗，他说自己在这个店有股份。 接着 Tony 又开始说办卡的事，给我看朋友圈的宣传，类似于“限定的诱惑”和饥饿营销，比如“今天可预约一位vip”。我说我对vip不感兴趣。 然后Tony又给我看了看微信列表，每个人都是名字+会员价的备注，比如 “金妮可 30000”。说会员卡谁都可以用， 但不接待男性顾客 。然后又和我说2000就能成为vip，他对不同价格的vip都是一个态度。我再次说我穷学生没钱。他说你把你的表当了都能剪好几次头发了。 他说的表是我手上戴的天梭表，因为太贵了我带了快10年了，自己动手换了一次表带换了三次电池。于是我说我表可以带10年，造型一年就过时了。 Tony又说我真的很想把你发展为顾客，学生价1000就行。我还是说没钱。他又说，1000让你三次烫染两次。我依旧说没钱，因为我是真没钱。 Tony说：“你没有花呗吗？” 我：“之前有过，我已经关了” Tony说：“额度多少？” 我：“不记得，我不会超前消费的” 之后也问了我好几次花呗，使劲想让我用花呗。 我说我穷的时候，提到了一下我这个月剪了三次头了。他问怎么剪这么多次。我说，被忽悠的呗。 Tony：“嘿，说得我忽悠了你似的，我就给你剪这一次，以后不给你剪了，说真的我不缺客户。” 天啦，我该说这人演得太投入，还是该说他太自信？ 在结帐的时候，我微信已经没钱了，抱怨了一下最近花得太多，只能用卡结账了。Tony明显顿了一下，什么卡？是信用卡吗？（因为信用卡负债状态跑路了商户也收不到钱） 后来记账时发现，结算页面没有此店的名字和标识，只有一个“美容美发中心”。 7 关于发型 Tony：“要是你回去同学看到了，就说我剪了一下，别说是做发根。” 我没明白怎么没头没尾来了这么一句，这能有啥不好说的。现在想来，是怕骗局被揭穿吧。 途中还来了一个妹子剪头。这个妹子的发型很迷，白色的头发，顶部特别高和头骨的比例完全不协调（我突然觉得我看骨相识人也不错）。当时Tony确认了一下，“这人是顾客吗？”然后让我等3分钟，看他展示什么叫3分钟剪完一个头发。我不知道这里的顾客是什么黑话。不过他剪的头发层次高得太离谱了，和妹子脸不配，太土了，审美实在不行。 现在觉得，这个顾客也可能是演员，带顶假发上场的。 至于我的发型，又变蓬了像狗熊。我剪完就去买个夹子夹塌了。朋友听了之后说你也是个奇葩，别人都要头发蓬，你要头发塌。 总结 这个事作为写报道的素材真的非常不错。流行元素兼备，社会心理诱导话术、普信男问题、骗钱流程展示得很齐全，是一场精心策划后的全店大型骗局体验店，就是楚门的世界一样，整个环境、公司、Tony的照片、微信列表、公司宣传册，全是精心策划过的，没有一个人是真的。手段很典型，流程固定。美女负责拉人，Tony（主演人）负责展示“专业”分析能力让人“上道”，然后洗头小哥负责一次抬预期价，Tony 负责展示自己贵又忙，二次抬预期价，再给优惠价。途中不停打探你的经济状况以看办卡最多能收你多少钱，询问烫染和妆造意向，顺带言语性骚扰和暗示。最后证明此店的连锁真实性和规模庞大，再让人办卡。 另外这个诈骗集团应该不只有一个地点，因为他们问过我住哪，和我讲最近的连锁店是哪，那个地方应该也很偏僻，没有我熟悉的地标，我也记不住。另外，他说烫发根全北京只有两家能做，还把另一家的名字说出来了，推测也应该是同伙（谁会主动推荐自己的竞争对手），但我也没记住。如果要深入调查，应该会是个人不少的组织，干的事也不只表面理发这么简单。整个流程策划也挺全面的，绝非一时半会儿兴起的骗子能办出来的。 但希望主演人可以改进一下，对一般女性能有点常识，用力过猛了。群演的年纪普遍偏小，就按规矩说话不怎么能自由发挥，需要再练下演技。 对于我这种容易被忽悠的人，解决方法也很简单，足够穷就不会被骗钱了。 PS：我觉得我写得好开心…………","tags":["生活"],"description":"年少无知系列","keywords":[],"date":"2021-04-18T16:00:00.000Z"},{"id":"看看是谁在D我","title":"看看是谁在D我","content":"自从部署了服务器，一直都觉得访问量不太正常。但我也仅仅是对IP做了防护，CDN防火墙也没怎么设置。 直到最近觉得，天天访问上万，唯一IP数却一千不到，cache率更是一直都在1%以下。决定看看是哪些人（IP）干的事，服务器实在不值得。 查看ip访问行为 web服务器使用的nginx，由于CDN的关系，nginx需要有http-realip的模块才能查看CDN前的ip。找了不少资料就只觉得这个文章不错，废话少过程清晰，还很贴心给了生成脚本。 CloudFlare CDN下Nginx正确获取真实IP教程 配置完成后运行了一段时间。先统计下当前的log文件前10名的访问量和相应ip： $ cat access.log | awk '{print $1}'| sort -n | uniq -c | sort -n -r | head -10 979 103.242.119.217 285 1.163.108.18 204 18.166.211.38 176 184.170.243.198 154 66.98.113.44 149 40.65.134.91 116 2400:8902::f03c:92ff:fe7b:5f02 113 113.71.61.213 92 185.245.1.151 80 107.148.250.111 第一名， 103.242.119.217 ，979次？这多得也太夸张了？！ 好吧，来看看这个ip在干什么。 $ cat access.log | grep 103.242.119.217 | tail -n 20 103.242.119.217 - - [10/Dec/2020:08:54:41 +0000] \"GET /WWW/phpMyAdmin/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:41 +0000] \"GET /phpMyAdmln/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:41 +0000] \"GET /phpMyAdmin_ai/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:41 +0000] \"GET /__phpMyAdmin/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:42 +0000] \"GET /program/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:42 +0000] \"GET /shopdb/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:42 +0000] \"GET /phppma/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:42 +0000] \"GET /phpmy/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:43 +0000] \"GET /mysql/admin/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:43 +0000] \"GET /mysql/dbadmin/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:43 +0000] \"GET /mysql/sqlmanager/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:43 +0000] \"GET /mysql/mysqlmanager/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:44 +0000] \"GET /wp-content/plugins/portable-phpmyadmin/wp-pma-mod/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:44 +0000] \"GET /sqladmin/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" 103.242.119.217 - - [10/Dec/2020:08:54:44 +0000] \"GET /sql/index.php HTTP/1.1\" 404 178 \"-\" \"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\" ... …………尼玛，恶意扫描啊！扫描常用路由啊碰运气啊！人干事？ 但估计这种恶意扫描的也是日抛ip，ban也没什么意义。只能设置limit rate了。 看看第二名在干什么。 $ cat access.log | grep 1.163.108.18 | tail -n 10 1.163.108.18 - - [10/Dec/2020:10:15:38 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:16:36 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:17:36 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:18:31 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:19:32 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:20:35 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:21:30 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:22:34 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:23:36 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 1.163.108.18 - - [10/Dec/2020:10:24:32 +0000] \"GET /clash/config HTTP/1.1\" 200 4978 \"-\" \"ClashforWindows/0.13.1\" 这应该是个用户吧，但你这更新就更新吧，每分钟更新一次？能不能积点德？（哽塞.jpg） 消耗流量都是其次，也并没有多出很多。但我不喜欢泡沫和虚高的数值，也讨厌因为不用付出成本所以极其浪费资源的做法，于我而言就像房间堆满了垃圾。看起来好像有很多东西，实际上什么也没有。 要是我这种心态，创业肯定找不到风投，很快就倒闭。 这些IP ban了也不太好……开个Challenge吧。 顺带一提，默认配置文件的更新间隔早就给取消了。取消的原因倒不是怕被D，当时还完全没想过会租服务器，只是单纯的因为程序会有各种意想不到的BUG，时不时出现全NULL，连之前能用的都没有了……自动更新太容易挂掉，于是取消了自动更新。 然后继续看，从第2名到第8名都是这种行为。我说呢，今天从浏览器进入的配置文件的页面一直无法加载，但服务端不管怎么请求都没有问题，最后不得已换成了一个静态文件。敢情就是你们搞没的？ 再加上gin的静态cache本身就不太稳。之前使用css的时候基本运行3天就外链请求不出来了，最后也是用nginx挂的静态文件。 第7名到第10名，很明显，同类程序的爬虫。Duang地一下请求几个一般人不用的链接。对于这些爬虫我觉得倒还行，请求频率并不会太高。但非常不喜欢直接伸手全爬别人爬好的，这是极其恶劣的生态与shame的想法。爬虫的理想的状态是网状分布式的部署，而不是树。 防护措施 由于挂了 CloudFlare，iptables 自然没什么用，还容易不小心把 CF 的 IP ban 掉（虽然在发现这一点之前我折腾了快一下午的 iptables ）。直接去配置CF的防火墙。 我需要应对的情况主要就这一个： 一分钟更新一次配置文件的ip，给他们一个小小的JS Chanllenge （突然有点后悔写了JS Chanllenge的破解是什么回事……） 但是啊，这些ip还是不少活人的，长期都Chanllenge没有必要。而且我也不能天天都像今天这么看log，实在是消耗时间，消耗时间就是生命。 而 Nginx 和 CloudFlare 的rate limit 都是防止CC，限制的每秒或者每分钟的请求数。但这恰恰是我不能做的，默认的配置文件的写法1s内会请求十几次，多请求几次就一分钟就几十次了（配置文件该改改了）。我需要处理的是过于规律且相对频繁的请求，而非CC。 于是连夜写了个分析log的程序，主要是以下功能： 根据请求间隔的规律判断是否为需要处理的ip 特征： 请求间隔过于规律，比如每分钟一次、每分钟两次等等。有容错率。 不计算大于 threshold 分钟的间隔与等于0分钟的间隔。 排除 CloudFlare 子网下的IP。CloudFlare 的 ip 网段在线获取。 使用 CloudFlare Api 更新 JS Chanllenge 的 filter，给需要过滤的 ip 加上 Challenge 然后用 cron 定时执行。常驻后台没必要，也没想做实时监控。 把恶意 IP 和常见的 IP 过滤掉后，最新的就只剩下 CloudFlare 的请求了，终于干净了……但好寂寞啊…………看来是真的没什么活人用呢。 一天后 今天的Requests数是17435。 Unique Request是1188。 Challenge挑战的Request数是，8200（微笑脸）。 你妹啊，Bot一样的自动更新占了快一半啊！摔！ 而且每次防火墙每次更新过滤的ip都是那么40个左右，Challenge通过率是0.5%。 40ip个会不会有点多？是不是程序有问题？我开始也这么想过，但我自己也设置有定时更新，还设置了三份，都没见把我自己ban掉。 累了，感觉不再爱了。","tags":["运维","经验"],"description":"自从部署了服务器，一直都觉得访问量不太正常。但我也仅仅是对IP做了防护，CDN防火墙也没怎么设置。","keywords":["运维","Linux","nginx"],"date":"2020-12-11T16:00:00.000Z"},{"id":"关于指针与Golang的结构体","title":"关于指针与Golang的结构体","content":"之前在学C++的时候，指针的用法就困惑了很久。后来有了计算机体系结构基础后，再加上Golang的一些说明，就突然明白了，之前为什么不理解指针。纠结的点在哪里。 指针的概念 (学的语言太多语法有些混了，看个意思就好，代码是四不像并不可以运行) 地址 ：一个变量在内存中的存储形式是 地址 + value ，地址是在指内存中的地址。 比如 int a = 3 ，意思是变量 a 在内存中有一个地址， 这个地址储存的 value 为 3 。 指针 (pointer) ：是一种变量， 它的 value 仍然是一个地址 。常用 * 定义指针变量。 比如 int *b = &#x26;a ，意思是 指针变量 b 在内存中有一个地址， 这个地址储存的 value 为 a 的地址 。 在使用变量（而不是声明或定义变量）时， &#x26; 为取地址符。对应的还有一个 * 为取内容符。比如 int a = 3 int *b = &#x26;a // 将 a 的地址作为 b 的 value print(b) // 输出 b 的 value，结果为一个地址，等于 a 的地址(&#x26;a) print(*b) //将 b 的 value 作为地址，输出地址中存的值，结果为 3 上面仅是个人的概念解释，尽量少地引入新概念。以上概念有更通俗的叫法。 比如 int *b = &#x26;a ，通常会叫做“变量 b 持有 a 的引用”。个人觉得虽然直观，但对于初学者并不友好。首先，“变量 b”就没有说清楚指针变量的特殊性。然后“a 的引用”，倒是说清楚什么叫做 a 的引用啊……尤其是一些语言没有指针的概念，但引用是随处可见的（比如 Javascript 的 Object 类型） Golang Struct 与 指针的访问 其实让我明白的只是因为 Go tour 中的两句话： Struct fields can be accessed through a struct pointer. 结构体字段可以使用结构体指针获取。 To access the field X of a struct when we have the struct pointer p we could write (*p).X . However, that notation is cumbersome, so the language permits us instead to write just p.X , without the explicit dereference. 结构体指针访问字段本来应该写成 (*p).x ，但是由于这么写太蠢了，所以允许直接写成 p.x 。 也就是说，如果见到类似 T.x 的结构体访问，T有可能是结构体本身，也可能是指针……需要自行区分。仅此而已。 而我之前一直以为 T 只能是结构体本身= =，所以对于指针一直头大…… 但由于存在指针这种特殊的访问方式，在结构体的组合与接口实现中会有一些想不到的情况： 定义了一个接口Interface，方法有Intera()，Interb() type Interface interface{ Intera() Interb() } 定义了一个结构体Base，用结构体指针的方式实现了Intera() type Base struct {} func (b *Base) Intera() {} 定义了一个结构体Extend，匿名组合了Base，用正常结构体的方式实现了Interb() type Extend struct { Base } func (e Extend) Interb() {} 这个时候，请问有谁实现了Interface？ 答案是： Base 和 Extend 本身都没有实现 Interface 。但是上述代码中完全没有出现的 * Extend（Extend的指针）实现了Interface 。 为什么呢？虽然 、* Extend 并没有实现第二个方法，但 Extend 实现了，所以 ***Extend **是也是可以直接访问第二个方法的（参考上面的(*p).x的解释）。 而* Base 实现了第一个方法（Base没有实现），而 Extend 组合了 Base 。因此第一个方法可以也通过 * Extend 访问（Extend无法访问）。 所以* Extend 两个方法都能访问，因此实现了Interface。而 **Extend **只能访问第二个方法，因此没有实现Interface。 然后日常使用 Extend 的时候，为了能使用Interface的方法，需要使用 * Extend ： interfacelist := make([]Interface, 0) interfacelist = append(interfacelist, &#x26;Extend{}) // 因为是指针实现Interface，需要传入地址 e = interfacelist[0] 在 goland 对 e 按下 F1 时，只会显示，这是个 Interface，不会告诉你这是 * Extend 。如果不是自己从头写的代码，你可能很久都无法发现，是个指针类型实现了 Interface。你必须在层层组合中，找到是哪一层（这里是Base）让 Extend 变成了 Interface 的指针实现。 对 e 的 type assertion 也应该这么写： e_ptr = e.(*Extend) // 从Interface类型返回一个Extend类型的指针 e_ptr.Base // 等于(*e_ptr).Base","tags":["Golang"],"description":"关于指针与Golang的结构体","keywords":["Mac","shell","自动化","脚本"],"date":"2020-11-26T16:00:00.000Z"},{"id":"Mac上如何开机与关机时自动运行Shell脚本","title":"Mac上如何开机与关机时自动运行Shell脚本","content":"网上讲如何开机运行脚本的很多，但我有关机时关闭远程服务的需求。于是上外网查了一下如何在关机时执行一段脚本。 新建一个shell文件 这个shell中包含了你需要开机关机时运行的脚本。 #!/bin/bash function shutdown() { # 关机用的脚本放这里 exit 0 } function startup() { # 开机用的脚本放这里 tail -f /dev/null &#x26; wait $! } trap shutdown SIGTERM trap shutdown SIGKILL startup; 以上文件我取名为launchdeamon，赋予了当前用户的执行权限。 chmod 755 launchdaemon 新建plist文件 为了让launchdeamon能在开机时自动运行，需要编写一个相应plist文件，使用launctl做到开机启动。关于launchctl和plist的作用，请先查看这篇文章： Mac执行定时任务之launchctl 。 plist文件的内容如下： &#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?> &#x3C;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"> &#x3C;plist version=\"1.0\"> &#x3C;dict> &#x3C;key>Label&#x3C;/key>&#x3C;string>boot-shutdown&#x3C;/string> &#x3C;key>ProgramArguments&#x3C;/key> &#x3C;array> &#x3C;string>$SCRIPT_PATH/launchdaemon&#x3C;/string> &#x3C;/array> &#x3C;key>RunAtLoad&#x3C;/key> &#x3C;true/> &#x3C;key>StandardOutPath&#x3C;/key> &#x3C;string>$LOG_PATH/boot-shutdown.log&#x3C;/string> &#x3C;key>StandardErrorPath&#x3C;/key> &#x3C;string>$PLOG_PATH/boot-shutdown.err&#x3C;/string> &#x3C;/dict> &#x3C;/plist> plist文件以键值对的形式存储信息。以上文件的字段解释： Label ：标签，也就是运行该plist显示的名字。这里为boot-shutdown ProgramArguments ： array 里可以存放多个需要运行程序。这里的 $SCRIPT_PATH 请自己修改。 RunAtLoad ：开机自启，为 true StandardOutPath ：打印标准输出到某个文件，方便查看程序后台运行的结果， $LOG_PATH 自行修改。 StandardErrorPath ：打印标准错误到某个文件，同上。 以上文件我取名为 boot-shutdown-script.plist 。 由于shell脚本的执行权限是当前用户，以上文件需要放入当前用户的开机启动文件夹，即为 ~/Library/LaunchAgents 。 然后将plist文件加入开启启动： launchctl load ~/Library/LaunchAgents/boot-shutdown-script.plist 此时重启后，可以使用以下命令查看脚本运行状态 launchctl list | grep boot 输出为 438 0 boot-shutdown 第一个是pid。第二个为状态码，为0说明正常运行中。 参考： Run a script only at shutdown (not log off or restart) on Mac OS X","tags":["shell"],"description":"","keywords":["Mac","shell","自动化","脚本"],"date":"2020-11-23T16:00:00.000Z"},{"id":"关于Golang程序的内存占用过大的问题","title":"关于Golang程序的内存占用过大的问题","content":"之前看Mastering Go 2nd Edition，说到Golang的垃圾回收机制，说垃圾回收器(GC)每5分钟会调用一次。然而我观察服务器内存占用时，发现程序后的空闲器5分钟后，使用top查看内存占用并没有减少，大小是200M。因此开始怀疑起了是否有内存泄漏问题。 然而在使用pprof分析后，发现其报告的常驻内存占用只有10M，inuse_objects相对更多，也不过40M。goroutine没有泄漏，makeslice确实调用得非常多，但也仅仅是当时占用一下内存后来都释放了。有时候会有空闲的TCP连接，最后也被关闭了。可疑的代码都检查了一遍，最后认为只可能给内存造成压力但不应该内存泄漏。所以top查看的200M是怎么来的？ 在我再也挖不出任何可能性时，直到看到这篇文章，经历几乎一模一样。并且写得非常清楚有逻辑，以至于我没有想再完整记录一遍我的经历的想法。这篇文章甚至详细到了解释每一步的pprof的操作和术语，调试过程非常值得学习。 How we tracked down (what seemed like) a memory leak in one of our Go microservices 最后结论就是， 没有内存泄漏 。Golang的垃圾回收机制在1.12后变了，不再是5分钟机制(每5分钟发送 MADV_DONTNEED 信号)，而变成Go会告诉系统有空闲的内存可以回收(发送 MADV_FREE 信号)，但什么时候把内存还给系统是需要系统决定。如果系统内存一直有空闲就可能一直不会还系统，导致top显示出的内存占用一直很大。 文章中还指出，如果想用之前那样的5分钟回收机制，运行时可以加上flag GODEBUG=madvdontneed=1 。像之前那样使用 runtime.GC 与 runtime/debug 中的 FreeOSMemory 都没有效果，也就是不会发送 MADV_DONTNEED 信号。 后来我也去查看了服务器的内存情况，发现，在一个小时后（程序这期间一直是空闲状态），内存终于降了100M，变得和之间相同了。确实是没有内存泄漏，纯属服务器闲的。 知道这一点后我的内存洁癖也算是消失了。因为一直非常讨厌高内存占用的应用，觉得是没有优化好。现在看来，这也能有泡沫，反倒是没事就去清一下内存没有必要，重新申请又是额外的开销。从前的（静态）语言确实需要程序员手动管理内存，而go语言在这一点上又帮程序员做了。 “手动强迫系统释放内存的行为都是耍流氓。”","tags":["Golang","后端"],"description":"","keywords":["Golang","垃圾回收","内存"],"date":"2020-11-19T16:00:00.000Z"},{"id":"gwf-law","title":"关于GFW的法律相关定罪之“非法获取计算机系统数据、非法控制计算机信息系统罪”","content":"关于GFW的法律定罪之“非法获取计算机系统数据、非法控制计算机信息系统罪”。 之前看“不能使用该名称”的GFW定罪系列文章，阐述了司法实践中对于计算机概念不清晰导致的问题，觉得非常学术，逻辑上真的很有道理。所有回避攻击的手段怎么就变成入侵计算机或者非法访问网站了呢？ 但最近在阅读Clash的源码时，突然开始觉得，“非法获取计算机系统数据、非法控制计算机信息系统罪”对于节点的提供者或许是成立的。 《中华人民共和国刑法》第285五条第2款 违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制 下面说说为何觉得成立。 包括Clash在内，所有翻墙软件都具有两个部分，一个被称为outbound，为将加密后的数据发送至远程服务器（或接收数据）。outbound的常用协议为常见的ss、ssr等等。这个部分没有上述罪名的问题。 另一个部分称为inbound，此部分接管计算机系统的tcp请求(通常使用http或socks5)，将计算机系统原本应直接发送到服务器的流量接管到翻墙软件中。此系“非法获取计算机信息系统数据”的可能 在获取inbound传入的传输数据之后，使用outbound指定的协议，与proxy服务器建立加密的连接，通过节点服务器发送流量。而节点服务器接管流量并返回到用户端时，传输的数据同样要使用软件的inbound写入浏览器。此系“非法控制计算机信息系统”的可能。 不论如何，“获取计算机信息系统中传输的数据”是肯定无法避免的。此时的问题在于：1.是否违反国家规定（非法性）这一点非常口袋了，又要回到信道上。2.获取数据的客体并非是人，而是计算机程序，虽然程序的制作者并没有获取任何数据，但节点的提供者是可以的，很好的例子就是机场面板里可以显示用户最近使用的IP。 对于翻墙软件的制作者而言，如果上述对于节点提供者的“非法获取计算机信息系统数据、非法控制计算机信息系统罪”成立，则“提供侵入、非法控制计算机信息系统的程序、工具罪”也相应成立。 当然，这一切的前提，都建立在“非法性”的基础上。什么样的技术用于做什么合法没有规定。最受争议的“非法信道”在司法实践中也一直脱离了法律中“物理信道”的解释，涵盖了非物理信道，可以称其为口袋之源。 参考： 提供侵入、非法控制计算机信息系统的程序、工具罪 非法获取计算机信息系统数据、非法控制计算机信息系统罪","tags":["GFW","科学上网"],"description":"一些法律研究","keywords":["GFW","法律"],"date":"2020-11-06T16:00:00.000Z"},{"id":"GlobalProtect启动退出脚本(MAC)","title":"GlobalProtect启动退出脚本(MAC)","content":"mac上的Global Protect近似于流氓软件，但迫于学校要求不得不用。于是写了个shell脚本。 参考： Mac 退出与卸载 GlobalProtect if [ $# -eq 0 ]; then exit 0;fi case \"$1\" in -h|--help) echo \"-l launch\"; echo \"-k kill\"; echo \"-as launch and set autostart\"; echo \"-uas kill and unset autostart\"; echo \"-h help\"; exit 0;; -k) launchctl unload /Library/LaunchAgents/com.paloaltonetworks.gp.pangp*;exit 0;; -l) launchctl load /Library/LaunchAgents/com.paloaltonetworks.gp.pangp*;exit 0;; -uas) launchctl unload -w /Library/LaunchAgents/com.paloaltonetworks.gp.pangp*;exit 0;; -as) launchctl load -w /Library/LaunchAgents/com.paloaltonetworks.gp.pangp*;exit 0;; esac 在/usr/local/bin下新建文件，输入以上内容，并赋予执行权限即可。","tags":["开源项目"],"description":"","keywords":["GlobalProtect","shell脚本"],"date":"2020-03-26T16:00:00.000Z"},{"id":"都挺好","title":"都挺好","content":"自我发泄罢了。 1 最近有部剧在三次元很火，叫都挺好。姚晨在里面主演了个从困苦中长大的女孩，在什么都不好下的情况下逆风翻盘，过上了自己所理想的生活。 苏明玉所代表的是三次元主流社会的一种理想生活模板。有钱，有事业，有家庭，会生活，是社会对于人“成功”和“幸福”的典范，也是很多人向往的潮流。当个人对自己的期望与社会对个人的期望是一致时，奋斗会是一件艰苦但幸福的事，比如苏明玉。反其道而行之，即使奋斗也是艰苦与痛苦。因为社会的不认同，自己的理性也不去认同。这时的理想与现实是无比割裂的。 我妈也不例外，给我发了一篇“有钱一时爽，一直有钱一直爽”的爆文。她是最喜欢这种有钱的小资生活的人，可惜起点太低，所以希望我能成为外向/自律且能过好生活的有钱人。很不巧，她的女儿完全相反，是一个非常内向/对不想做的事极度不自律/对想做的事能把对己极度push的人。 按照MBTI的分类方法，苏明玉（姚晨饰）是ENTJ，指挥官型人格。而我是INTP，如果T再弱一些，F的属性再重一些，也就是INFP时，是我的抑郁状态。抑郁状态不是悲伤，接近崩溃，造成的影响难以逆转。 2 我的一个朋友在985学的软件工程，可开心了，每一次学习知识都是有趣的，和大家做出什么东西都很有成就感。 我曾经一起玩电子音乐编曲的朋友，在普通本科学软件工程，不喜欢做网页，因为做网页不是设计网页，不像作曲编曲就是设计音乐。所以他在自学Unity，说想做游戏。 另一个一起玩电子音乐编曲的朋友，学化学的，不编曲了。 我也不编曲了。 3 前段时间晚上和一个画画的大佬交流。大佬不是天生的大佬，这两年是看着大佬进步的，尤其进了公司后，画技一月一变。大佬翻出了之前的黑历史给我看，确实还挺黑的，然后说，“你现在画得可比我那时候好多了，有被鼓励到吗？” 我仔细想想，说“没有[捂脸]”。 大佬说我怎么这么丧，要是小海（另一个画友）看了那肯定高兴炸了。大佬说他上大学那会儿临摹了一张图，当时觉得自己牛逼得不行，现在一看，什么鬼。 我确实没有被鼓励到，这挺对不住别人的鼓励的。我也很羡慕这种有点小成就就能很开心的心态。但有人告诉我，这种小成就感会造成短视，选择这样的行业可能不会有太高的高度（没错说得就是前端，几年下来牛逼到不行年薪也就40w）。如果我还把画画当成兴趣，那我也是那个画了个很像的临摹就觉得自己特牛逼到处发社交平台的人。但现在不行了，我清楚我要是在毕业之前不能画到一种可以靠画画吃饭的水平，可能会永无天日，也永远没有去提出要求让家里继续花钱的权利。 而基友就很不一样，想画就画，不想画就把画笔一摔：“老子不画了，老子要打游戏。” 4 前段时间和一个热爱科研的大佬用qq写信交淡，聊的是关于人生的思考。大佬一直年级前十，真的热爱科研，通原导论课这种介绍专业大纲的论文拿了满分。他说他很纠结，因为不管是参加比赛，去实验室工作，拿奖，都是真的喜欢，不是为了社会意义上的功名。所以他为了有自己安静思考的空间，没有去清华（要去一定可以去的那种），拿特奖进了Top3觉得已经知足了。但他爸爸觉得他太寡淡，不去争，只留在小破学校。他纠结的是：“社会上都希望给人标签化，而我在做的事情是去标签化。那我是要坚持非标签化的生活习性，并在这个道路上找到容身之地，还是选择标签化自己，和正常的社会人一样建功立业呢？” 我看完几乎要给他跪下。在平常人眼里，做科研已经社会上非常认可的一条路，社会自动会给他贴上科研大佬的标签，现在不去清华以后过自己想要的生活还是绰绰有余的。只不过他爹是更功利一些，更加看重他的标签罢了。 但这确实是一个多想想就无解的问题。在人际关系过于庞大的社会，人们只会看你有的标签和别人口中的印象。标签不适合就首先被淘汰了。大佬不用担心，他选的路和他拥有的标签是一致的。而我呢？标签和想选的路一直不一致的怎么办？ 5 我相信是能做好一件事的是真的热爱的。 但是先有热爱才有的一步步成就，还是先有的一步步成就才有的热爱呢。 这两者都有。龙哥是越来越喜欢演戏的。而年轻有为的大佬们都是先有热爱的。但自己呢？能放弃喜欢的事情把热爱挪到社会的给正轨上吗？ 6 都说二十多岁的年轻人选择很多，其实一点不多。不说天赋筛掉的路，从填好高考志愿的那一刻，社会已经对你有了期待的方向。等到工作时，除了部分自由职业者和创业者，要走什么路几乎可以一眼见底。转行的成本不是一般人承担得起的，包括精神上和物质上。 而当能承担转行的成本时，说明在原来的领域已经是做得很好的，而我相信是能做好一件事的是真的热爱的。这就变成了一个无法解开的死锁。 导师不赞同学生写技术博客。导师赞同用什么学什么。这也是一种一眼见底。“哪管喜不喜欢，只看能不能干。”一个创业的哥哥说。 不知道为什么，我非常非常讨厌这样的模式。理性告诉我这是实际情况，是对的，这样的人通常过得很好。可我依旧讨厌，迫切想远离。太现实主义了。他们先决定了想怎么活，干什么是无所谓的，只要能干。而我是先想干什么，怎么活是无所谓的，只要能活。 可能还是太年轻，被打击得不够狠。 7 我仍然相信科技能从实处改变生活，并且看到人们的生活因此更加丰富多彩而欣喜。但我仍然不知道怎么做。","tags":["生活"],"description":"自我发泄罢了。","keywords":[],"date":"2019-03-26T16:00:00.000Z"},{"id":"近期资源整理2018-08-17","title":"近期资源整理2018-08-17","content":"尽量弄点技术资源上的整理，或者记一点比较有趣的事。像p2p暴雷之类的就不记了。 教程 Build CPU from scratch (英文) 从零开始建造CPU小游戏，从一个与非门开始一步步搭建出各种逻辑运算单元，直到拼出一个CPU。需要数字电路基础和计算机组成原理的知识。 Google推出的机器学习速成课程 Google推出的在线机器学习课程，并且不用科学上网。 资源 这是第一次写，所以夹杂了之前的资源。 GitHub上有趣、入门级的开源项目分享站 开源项目分享站。大部分是中文项目，可按语言分类检索，每月出一期月刊，适合正在学习的人练手。 free-programming-books 整理了所有和编程相关的免费书籍，同时有 中文版项目 有了这个列表，程序员不愁没练手的小项目了 学了新语言之后不知道怎么巩固时，可以按照上面的列表实践练练。 OSDev.org 操作系统wiki。提供编写一个计算机操作系统的所需要的信息。可以作为教程看，也可以作为参考。 文章 API之下 - ruanyf 借用一下文中的原话，“虽然标题里面有 API，但是本文谈的不是编程，而是更重要的事情”。 有趣又无聊的发现 SCP基金会：全世界作者协同创作的小说 SCP中国分部 SCP基金会是一个虚构的神秘的组织，记载了各种超自然现象、个体等事件。小说的形式就是组织内一篇篇“机密文件”。有趣的是任何人都可以成为SCP系列的作者，只要文章符合要求就能被收录进SCP基金会网站。目前已经有了基于SCP世界观的游戏衍生和小说改编。 近期事件 Python的流行趋势跃居编程语言第一（IEEE，PYPL） （Python都已经作为高考内容了，而当年高考时我还什么也不会）","tags":["资源整理"],"description":"","keywords":["CPU教程","资源分享","开源项目"],"date":"2018-08-16T16:00:00.000Z"},{"id":"B站反查用户弹幕小记","title":"B站反查用户弹幕小记","content":"工具：Chrome浏览器 反查用户分为视频里现存的弹幕反查和历史弹幕反查。其中反查历史弹幕需要用Chrome的调试工具，需要懂一点前端，比较简单，仍然是非技术向的一个小记。 从视频里现存的弹幕反查用户 能有工具用就用。以下两个工具都能实现从视频里现存的弹幕反查用户。 Bilibili弹幕发送查询 Chrome扩展 Bilibili Helper 从历史弹幕里反查 了解原理需要知道前端的基础。原理在 这篇文章 里说得很清楚了，一定要看。（目前文章已失效，请继续往下看） 问题是在于历史弹幕文件的获取。2018年历史弹幕的API有变动，需要用户已经登录了才能获取（因为页面的请求方式是是Request），因此之前网上的工具箱都没法用了。这里说一下使用Chrome的开发者工具获取历史弹幕并反查用户的方式。 首先，Chrome需要登录过bilibili，这样才能有cookie。 然后打开一个视频，这里用 av29242495 为例。 开启Chrome的开发者工具，并选择network选项卡，刷新一下，大概是这样。 在上图的bilibili界面中选\"查看历史弹幕\"，选则一个日期（我选的8月14日）。然后在右侧的Filter中填入history，结果是这样 ) 其中以history开头的文件就是我们所需要的历史弹幕文件，双击就可以在新标签页中打开。这个例子中的历史弹幕文件地址长这样： https://api.bilibili.com/x/v2/dm/history?type=1&#x26;oid=50775916&#x26;date=2018-08-13 可以见这个历史弹幕的api就长这样，oid是视频的编号（不是av号），后面加个date。type=1目前我没弄清楚是什么。 弹幕文件里的弹幕都是这个样子的 &#x3C;d p=\"弹幕出现时间,模式,字体大小,颜色,发送时间戳,弹幕池,用户Hash,数据库ID\">123123&#x3C;/d> &#x3C;!--比如--> &#x3C;d p=\"10.15700,1,25,16777215,1534175832,0,39d120,3687662110113792\">卧槽番外&#x3C;/d> &#x3C;d p=\"19.93100,1,25,16777215,1534175761,0,6acc8733,3687624958541824\">台词太强了，节奏太好了&#x3C;/d> &#x3C;d p=\"24.98000,1,25,16777215,1534175677,0,f11c8b72,3687580849668100\">来啦 给大大比心&#x3C;/d> 其中要用的是用户Hash。用户Hash只是简单的把数字ID用 ITU I.363.5 算法进行了Hash。不过这里不用手动写算法了，因为下面的接口还能用。 https://biliquery.typcn.com/api/user/hash/[用户Hash] 比如我从文件里任意选了两个用户Hash，替换掉上面的[用户Hash]，分别返回了如下结果 {\"error\":0,\"data\":[{\"id\":17882889}]} // 比较老的用户 {\"error\":0,\"data\":[{\"id\":390105526},{\"id\":21670130}]} // 一般新用户 用户ID(uid)为后者。用B站的个人主页网址格式就能找到了弹幕发送者的主页了。格式如下 https://space.bilibili.com/uid/#/","tags":["web","经验"],"description":"","keywords":["bilibili，弹幕，查询，逆向"],"date":"2018-08-14T16:00:00.000Z"},{"id":"使用pandoc转换md为PDF并添加中文支持","title":"使用pandoc转换md为PDF并添加中文支持","content":"由于最近需要把markdown文件导出为pdf并且需要用到latex的行内的数学公式，只用typora无法做到，于是开始使用pandoc。问题是pandoc中在从md转pdf的时候需要手动设置中文，否则会有转换问题。这个坑查了很久，最终从一个pandoc模板里得到了解决方法。 系统：macOS 10.13.2 基本操作 准备：需要先安装 HomeBrew 安装pandoc brew install pandoc 安装texlive，支持latex brew cask install mactex 导出pandoc转换为时的latex默认模板 pandoc -D latex > template.latex 在template.latex里添加中文字体支持 \\usepackage{fontspec} % 允許設定字體 \\usepackage{xeCJK} % 分開設置中英文字型 \\setCJKmainfont{SimSun} % 設定中文字型 \\setmainfont{Helvetical} % 設定英文字型 \\setromanfont{Helvetical} % 字型 \\setmonofont{Courier New} \\linespread{1.2}\\selectfont % 行距 使用模板把md转换为pdf pandoc --pdf-engine=xelatex --template=[template.latex的路径] newfile.md -o newfile.pdf pandoc的默认使用的模板路径 在mac os下，在～/.pandoc/templates文件夹里。没有的话要手动创建的。 cd ~ mkdir -p ~/.pandoc/templates 导出latex的默认模板至默认的模板路径 pandoc -D latex &#x26;gt; ~/.pandoc/templates/default.latex 在default.latex里添加中文字体支持 \\usepackage{fontspec} % 允許設定字體 \\usepackage{xeCJK} % 分開設置中英文字型 \\setCJKmainfont{SimSun} % 設定中文字型 \\setmainfont{Vollkorn} % 設定英文字型 \\setromanfont{Vollkorn} % 字型 \\setmonofont{Courier New} \\linespread{1.2}\\selectfont % 行距 这样下来转换的时候不使用指定的template，使用的就是default模板。例如 pandoc --pdf-engine=xelatex newfile.md -o newfile.pdf","tags":["markdown"],"description":"使用pandoc转换md为PDF并添加中文支持","keywords":["pandoc","PDF","PDF转换","markdown转PDF"],"date":"2018-02-06T16:00:00.000Z"},{"id":"welcome","title":"Welcome to sansui's blog","content":"这个文件记录了此博客的外观变化。从2016年开始，使用 hexo 建立博客。 2019-03-24 yilia ，一个hexo官网没有的但很多人都知道的主题。移动端的优化很好。偏重于内容，挺生活化的，搜索也很全。 yilia接入gittalks评论 。 Hexo yilia 主题一揽子使用方案 2020-11 换成了 Hugo 的 Loveit。 2020-12 逐渐偏黑白设计感。 hexo-theme-aircloud tkl 2022-05-13 用 NextJS 重构中。将逐渐脱离通用博客框架。 2023-08-21 文档数据丢失。内容慢慢重写。","tags":["blog"],"description":"","keywords":["博客","hexo","next.js"],"date":"2016-03-24T11:23:17.000Z"}]