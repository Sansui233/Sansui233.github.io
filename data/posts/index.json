[{"id":"2025-12-30-Better-Web-Typography-for-a-Better-Web-Chinese-Version.md","title":"Better Web Typography for a Better Web 中文版","content":"这是一本讲网页排版书籍，书中内容有在线示例与代码，是这么多年来对我极其有用的平面设计书籍之一，说是我的排版启蒙也不为过。此博客的采用的正文排版均构建于此书所介绍的基础上。\n\n- 书名：Better Web Typography for a Better Web  \n- 译名：更好的网页排版，造就更好的互联网\n\n> 此书为 90% 的 AI 翻译，完全保留原书排版，由人工校对以确保大部分用词统一。\n\n## 推荐语\n\n2018 年，我还在大学社团做海报，那时候对排版的理解更多是靠“直觉”。直到接触到了 Matej Latin 的网页排版公开课，也就是这本书的起源。课和中提出“排版的完美等边三角形”——即字号、行高与行宽之间的动态平衡，以及“模块化比例”的概念，彻底改变了我观察网页的视角。我至今铭记在心：“要获得完美的段落，需要三样东西：字体大小、行高和行宽。它们需要达到平衡。”\n\n从那以后，这三要素就成了我做阅读文字时绕不开的底层直觉。每当我看到一个网页，总会下意识地去拆解它的文字比例是否协调。尽管此书以英文为基准，其中的排版规律对多种语言均适用。\n\n虽然这本书写在八年前，在互联网平面设计风格迭代如此之快的今天，它讨论的核心规则却依然稳固。甚至可以说，如今主流的网页排版方向，就如书中的所言。如果你想摆脱“凭感觉”排版，真正理解排版的美学逻辑，倾情您阅读推荐这本书。\n\n## 简介\n\nBetter Web Typography for a Better Web 是一本源自高分在线课程的著作，旨在向网页设计师和开发人员等网站构建者讲解排版。作者 Matej Latin 将垂直节奏（vertical rhythm）、模块化比例（modular scale）和页面构成（page composition）等复杂概念，以通俗易懂的方式进行了深入浅出的解析。本书配有实时代码示例，读者在阅读过程中将亲历设计并构建一个示例网站的完整流程。这是一本针对新媒介的排印新书：基本规则虽未改变，但除此之外的一切都已焕然一新。\n\n## 资源链接\n\nCloudFlare - R2 直链下载：\n\n- [更好的网页排版，造就更好的互联网 - Matej Latin](https://img-cf.sansui233.com/books/%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%BD%91%E9%A1%B5%E6%8E%92%E7%89%88%EF%BC%8C%E9%80%A0%E5%B0%B1%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%20-%20Matej%20Latin.epub)\n\n标签： 排版，字体排印，平面设计，网页设计","description":"我的排版启蒙书","keywords":"平面设计, 排版, 网页排版, 字体, 网页设计, 字体排印, epub, 电子书, 资源, 下载","date":"2025-12-30 06:10"},{"id":"2025-07-24-embed-python-with-uv.md","title":"uv 管理 conda 项目依赖","content":"##  conda 的问题Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。![沐神都解决不了的](https://img-cf.sansui233.com/imgs/2025/07/202507242029977.webp)conda 的问题在于1. requirements.txt **全手写**！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。2. 依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python 发了论文和仓库就跑的项目是很多的。安装一个旧项目导致之前安装 numpy 被卸载，然后整个项目就垮掉。这种情况相当之多，又解决两个小时的依赖问题。3. （至少我不愿意看到）电脑里十几个相同版本的 torch 和 cuda。当时的硬盘还只有 256G，多装几个 torch 无法接受，嗯……直到现在都还是这样的，大家主打一个能跑完实验就行。包的更新是激进的，包管理是落后的。在几年前有人说用 PDM，后面有 poetry。这两是不用再手写 `requirements.txt` 了，依赖也会自动 resolve 不会覆盖来覆盖去的，但还是会装十几个 torch。直到 uv 开始用硬链接进行包管理。##  uv 之于 conda 项目uv 接管 python 界的依赖管理按理说已经没什么问题。但实际情况是，很多项目还是在用 conda。除非哪天 torch 和 HF 都把 uv 设置为首推，否则就得一直与  conda 存在的问题战斗。### 1. 不提供 venv 的项目用于研究的项目一般都是不提供的打包好的环境的，主要是太大了，每个人设备情况也不一样。所以下载后第一件事是```shuv venv./.venv/Script/activate```如果这个项目不再更新了，或者是打算迁移到 uv，可以直接使用 uv 的方式管理依赖。uv 会自动维护 `pyproject.toml` 和 `uv.lock` 文件。```uv add -r requirements.in -c requirements.txt```如果这个项目，他还在更新，你时不时就得去拉一下分支。这时候最好用 `uv pip` 。至于依赖混乱问题，听天由命吧。~~跑得起来就得了~~```uv pip install -r requirement.txt```###  2. 提供 venv 的项目 提供 venv 的项目通常是给人用的，b 站的整合包一大堆。这种已经配好环境的项目也意味着你最好只用 pip。通常还是非常原始地调用 pip```./.venv/python -m pip install xxx```……等于说又开始了安装十几份 torch 的依赖管理模式。用 uv 是可以重复利用缓存的。这个时候 uv 的问题在于无法接管 python 环境，需要设置一下环境变量：```shexport UV_PYTHON=\"./.venv/python\"uv pip list```然后就可以利用 uv 的缓存了。当然，依赖混乱问题使用 `uv pip` 是无法避免的。这对于发行版也是一种麻烦。因为发行版的环境全给你配好了，但有的项目设计了插件系统，插件系统又需要装插件的 requirement.txt，安一个许久没更新的插件让主项目废掉的情况也不是不可能……如果让插件作者指定的兼容版本？只靠规范做不到，必须像MC那样检查版本号，不更新版本号就不放行。这样就算不更新代码了，也得倒逼作者每个版本都进行一次（至少是与主项目的）依赖兼容性测试。我觉得以当前 python 的运行方式，不 lock 子依赖的版本，这个问题是没法解决的。##  uv 管理 torch 下载源通常而言，在不指定 index 时 uv add torch 是去 pypi 或清华镜像源找 CPU 版本。如果打算每个项目都采用一样的 torch 版本 和 cuda ——###  uv 创建的新项目共用的 `uv.toml` 指定下载源。Linux 在 `.config/uv/` 下，Windows 在 `%APPDATA%/uv/` 下。```toml[[index]]url = \"https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/\"default = true[[index]]name = \"pytorch-cu128\"url = \"https://download.pytorch.org/whl/cu128\"explicit = true```项目级别的 `pyproject.toml````tomldependencies = [  \"torch==2.7.1\",  \"torchvision==0.22.1\",  \"torchaudio==2.7.1\",][tool.uv.sources]torch = [  { index = \"pytorch-cu128\"},]torchvision = [  { index = \"pytorch-cu128\"},]torchaudio = [  { index = \"pytorch-cu128\"},]```然后执行 `uv sync` 安装。###  uv pip 管理老项目直接指定命令行 的 `--index-url` 和 `--torch-backend````shelluv pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126 --torch-backend=cu126```和用 pip 的方式差不多，区别是会硬链接到集中的缓存，不会重复占用十几份 torch。当然。该有的依赖冲突还是会有的。~~关键是装好后就不要更新了~~","description":"沐神都解决不了的……","keywords":"python, 包管理, uv","date":"2025-07-25 04:12"},{"id":"2025-07-12-compare-css-solutions.md","title":"踩了一圈 CSS 构建方案的坑","content":"css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）## CSS类复用粒度我自己把 css 选择器（类）的复用粒度分三个层级。### 组件类粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字```css.wrapper.container.list-item```组件化的选择器下面通常有很多条的 css。### 功能类通常是共用的样式或状态，比如```css.open.close.light.dark.glass-effect```这个看起来好像和组件类不冲突，但硬说的话组件类其实应该是这样```css.container.open { 此处将 .open 的所有样式全覆盖 }.container.close { 此处将 .close 的所有样式全覆盖 }.container.light { 此处将 .light 的所有样式全覆盖 }.container.dark { 此处将 .dark 的所有样式全覆盖 }```组件类的状态严格在组件的 scope 下。功能类则是可以不限 Scope 的复用。这 CSS 容易混乱的根源。在工程维护角度，功能类是最不敢乱动的类，不知道动了后哪里样式就会出问题。但在设计角度，用功能类复用一些状态又确实很方便，统一设计也好用。比如增加统一的圆角、描边、阴影样式。功能类的优缺点是一体两面——图像的只有主观的好看与否，没有客观的对错。### 原子类定义海量常用的基础样式类，在 class 上直接写类名就能获得对应效果。就是 tailwind css。原子类相较于功能类粒度更小，也不会轻易改动 css 属性。```css.flex.col-1.text-sm```## 方案通常来说，一个库的样式会着重在一个某一个粒度上。### 原生 css用原生 css 时通常会以 **组件化** 的粒度为主，带极少的功能类。现在配合 css 变量使用。早期的网页简单，一个 CSS 文件就能搞定全站，设计上并没有考虑项目变得越来越复杂后的实践。**优点**：性能好，扁平的结构利好小项目。适合写研究新样式。**缺点**：过于扁平，大量工程化后易屎山，存在样式与 DOM 分离带来的维护混乱。### SCSS古法预处理器，可能多层嵌套 css，可组合。是 **组件化** 的粒度。在 CSS.module 出来前，用 SCSS 分割 Scope 挺好用。**优点**：结构非常清晰**缺点**：1. 编译后的选择器很长一串，从浏览器渲染角度，匹配DOM是耗性能的2. 难以应对复杂项目 DOM 结构的改变，需要考虑扁平化 + 命名，但这样做和原生 CSS 的维护体验也不相上下。### CSS ModuleCSS Module 是完全 **组件化** 的粒度。相比起 SCSS 的样式与 DOM 分离，CSS Module 为组件内部样式耦合，组件间样式分离。**优点：** 在组件粒度分割合理的情况下，清晰易维护。**缺点**：依赖预构建，写类名写起来太磨叽了。整体我用得不多没法评价。```jsxconst Button = () => {  return (    <button className={styles.button}>      Click me    </button>  );};```### BootStrap**组件化** 为主，少量原子化修饰的预制样式库，拿来即用是不错的。早期 CSS 框架大多是指预制样式，和预构建的库有本质区别。### Tailwind css完全原子化的神奇之库，通过编译可以有功能类和组件类。它更像是重新定义了 css 语法。**优点**1. 灵活，快，好看2. 工具链齐全，可以裁剪掉不用的原子类。**缺点**1. 稍微要写复杂一点的样式，DOM 就会被一大堆 class 埋没。2. 从浏览器渲染角度，匹配、合并大量 CSS 样式是需要更多性能开销的3. 要做到同种样式的复用，必须组合原子类，变成功能类或组件类，否则维护起来相当麻烦。这似乎违背了用 tailwind css 的初衷，熟悉了 css 的不如直接自己用 css 手撮功能类和组件类。4. 其实我是 tailwind 黑，嗯。但无法否认开发时确实很快很方便。```jsxfunction Card({ title, description, imageUrl, imageAlt }) {  return (    <div className=\"max-w-sm rounded overflow-hidden shadow-lg\">      <img className=\"w-full\" src={imageUrl} alt={imageAlt} />      <div className=\"px-6 py-4\">        <div className=\"font-bold text-xl mb-2\">{title}</div>        <p className=\"text-gray-700 text-base\">{description}</p>      </div>      <div className=\"px-6 pt-4 pb-2\">        <span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#photography</span>        <span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#travel</span>        <span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#adventure</span>      </div>    </div>  );}```### 原生 css in js指 JS Object 转译为 CSS。由于写起来太不像 CSS，复杂的功能写起来过于不直观 ，我直接 PASS。```jsxconst InlineStyleExample = () => {  const myStyle = {    color: 'blue',    backgroundColor: 'lightgray',    padding: '10px',    borderRadius: '5px'  };  return (    <div style={myStyle}>      <p style={{ fontSize: '18px', fontWeight: 'bold' }}>        This text is styled with inline CSS.      </p>    </div>  );};```### Styled-components**组件化**的 CSS in JS 方案，写起来像 CSS 实际是 JS。支持客户端动态修改 CSS 具体属性（其他方案做状态改变主要依靠 selector 的匹配）**优点**：灵活好拓展，比如主题管理不仅仅是颜色，还可以是图片资源一类的。**缺点**：1. 因为是 JS 转 CSS，服务器编译慢和客户端渲染慢得选一个2. React 的 useContext 要被废弃了，而 styled-components 严重依赖此 hook，导致进入了维护状态。JS 框架发展太快了。```jsximport styled from 'styled-components';// Create a styled button componentconst StyledButton = styled.button`  background-color: blue;  font-size: 16px;  padding: 10px 20px;  border-radius: 5px;  &:hover {    background-color: darkblue;  }`;function App() {  return (    <div>      <StyledButton>Click Me</StyledButton>    </div>  );}```### Linaria自定义 **功能类** 的 CSS in js 方案，同时也支持 **组件化** 写法。生成的是完全静态的 css，样式值的复用靠变量，片段的复用靠 `css` 生成的类。**优点**：是预构建方案，在服务端渲染。和原始的 CSS 写法和思路差不多。**缺点**：1. 值复用靠变量，但是由于是 **静态 css**，这个并不会变。所以变量插值**其实是常量**。比如下面的 font-size 并不会变化。   ```jsx   const fontSize = 16;   const Title = styled.h1`     font-size: ${fontSize}px;   `   ```   也就是说，你如果想在客户端随意改变字体，用 context/zustand 这种 runtime 的 fontSize，这样写报错。不过，Linaria 允许你借助 react 的 props 和 `styled` 组件来实现客户端的值变化。   ```jsx   const Title = styled.h1`     font-size: ${props => props.size}px;   `   export default function MyComponent() {     const fontSize = useAppStore(state => state.fontSize)     return <Title fontSize={fontSize}>Hello</Title>   }   ```   相当于生成   ```jsx   <h1     className=\"_title_xyz\"     style={{ '--linaria-font-size': `${size}px` }}   >   ```   那这和 styled-components 写起来已经差不多了。而且要做主题化的值都得用快要废弃的 `useContext` API。只不过 linaria 改的 style 属性，styled 是改的 css  API。改 style 属性其实已经不能算静态了。2. 组件间的**样式复用方案**只有原生的 CSS 方案，上述的奇妙客户端插值做不了这个需求。假设，你要做一个主题化的对话框的卡片阴影，只能使用原生 css 类中加原生 css 变量。上述动态改变样式的因为依赖 props，只能使用 `styled` 的写法，但这样就会把 html 标签了也继承了，不同的样式也无法随意组合。这也是为什么我说 Linaria 是原生 css 的替代，而不是 styled-components 的替代，构建方式就决定他们差得太了远。3. 基于2，导致你写组件又要检查 `styled` 又要确认 `css` 类又要检查 JSX classname 的顺序。如果用组件继承会被迫连 DOM 类型都继承。4. 使用功能类有点像原子化，又完全不如 tailwind 已经给你预设好一堆东西的效率。写类名和 cssmodule 一样，太磨叽了我博客本想迁移至此方案，但由于工作量实在巨大而放弃。linaria 主要还是解决了个命名空间冲突的问题，想用得更深入一点就会四不像。```jsximport { css } from '@linaria/core';const eleStyle = css`  color: red;  font-size: 3rem;  &:hover {    color: blue;  }`;function App() {  return <h1 className={eleStyle}>Hello Linaria!</h1>;}export default App;```##  构建组建库每一个 CSS 方案都有对应的构建组件库的实践。 [shadcn](https://github.com/shadcn-ui/ui) 是基于 tailwind 构建组件库实践。## CSS 框架选择要素1. 样式复用2. 样式组合3. 动态样式4. 主题切换5. 代码提示6. 自动裁剪7. 随意重构8. 渲染性能9. 实践的统一性最重要的还是自己的需求。","description":"前端代码中质量最薄弱的一环","keywords":"CSS, SCSS, Bootstrap, tailwind, styled-components, Linaria","date":"2025-07-12 20:49"},{"id":"2025-04-22-techs-about-steam-crack.md","title":"Steam 假入库是怎么做的","content":"很久以前被淘宝的 Steam 假 CDKey 给坑过，因为价格其实也不便宜，打的正版宣传，其实是盗版，后来感觉太可疑了查了一下确认被坑了。现在突然想起来了解了一下。本文概述是日常语境中的 “Steam假入库”需要的一些步骤，概括起来为五个方面：解锁、下载、入库、DRM、API验证。## 下载验证steam 的下载鉴权流程是1. 查找账号是否有拥有此游戏，有则显示下载按钮2. 点击下载后，把游戏软件 Manifest 对应的密钥（DecryptionKey）明文写入一个本地文件 `Steam\\config\\config.vdf`3. Steam （原版）根据 `config.vdf`中的信息，发送下载请求至 Steam CDN 进行下载“Steam 解锁” “Steam 假入库” 指的是绕过上述机制。具体而言，如果没有购买游戏，可以：1. 将按钮变为可下载（至于是伪造请求实现还是逆向 hook 实现，我不知道，都可以，因为甚至不需要变按钮，给个外部的下载按钮也可以）2. 点击按钮后，从不知名渠道获取一个正版账号的 Manifest（下载清单）和 Decryption Key（下载密码），写入`Steam\\config\\config.vdf`3. Steam（原版）根据 **`config.vdf`**，发送下载请求至 Steam CDN 进行下载Steam 的下载验证可以说是相当简单，明文本地存密码，CDN 无状态的验证，这么多年没有改过流程，给入库工具空间（虽然说前端的事总有办法 Hack 但也是可以让 Hack 成本变高很多的）。不过 Steam 理念本来就是以平台服务留住玩家的，反倒是扩大了其影响力与营收。一些名词解释：- 解锁：指对没有购买的游戏，“可以显示下载按钮”。和能不能下载没有关系。- 下载：Steam 根据 **`Steam\\config\\config.vdf`** 的信息下载游戏文件。- 入库：指把下载好的游戏，在当前电脑的 Steam 库中显示。以上过程均不涉及对游戏本身的破解，只是对 Steam 下载过程的破解。也就是，破解的是 Steam，不是游戏。## 运行时验证这里开始才会涉及到游戏破解。有的 Steam 游戏下载下来后是不用破解的，直接找到游戏目录，点 exe 可以正常游玩（比如星露谷）。只是无法通过原版 Steam 打开，也就只能离线。有的游戏是无法脱离 Steam 直接运行的。这里涉及两层验证：### 加密算法层这是一层 DRM（数字版权加密保护）。Steam DRM 系统的名称为 SteamStub。SteamStub 的加密有各种的变体，每个游戏使用的不一致。只对 exe 的算法加密，是一个离线的步骤。不涉及 Steam 平台的验证。网上有一个开源工具叫 Steamless，可以破除 SteamStub 对游戏的 DRM，称为脱壳。但脱壳本身不处理 Steam 在线验证相关，只进行了脱壳的游戏也是无法正常游戏的。> SteamStub DRM 和 Steamworks API 是两个独立层。Steamless **仅移除 SteamStub 加密外壳**，但游戏代码中与 Steam 平台功能（如成就、云存档、联机）相关的 API 调用（通过 `steam_api.dll`）仍会保留。### Steam API 验证游戏还可能调用 Steam api 进行在线通信，如成就、云存档、联机相关的 API 调用。这是使用入库工具玩破解游戏可能被红信或封号的根本原因，因为对 API 的调用是发送到 Steam 官方服务器的。在小红书上了解到，有的玩的盗版可以与正版联机，说明 Steam 在联机时并不会验证账号是否拥有该游戏。包括 Steamtools 实现的家庭共享联机，也说明了 Steam 对于是否账号可以进行联机鉴权不足。但只要留有记录就有可能导致被封号，取决于 Steam 什么时候想管理盗版现象。反之，如果伪造一个 Steam 的服务器，并且替换游戏中的 Steam 相关的动态链接库，如 `steam_api.dll` ，游戏里所有对 Steam API 的调用被发送到假服务器上，返回一个假的结果。这种工具也已经有了，项目为 goldberg_emulator，简称 GBE。破解版的游戏通常会内置一个这样的虚拟 Steam 环境。### 第三方厂商验证很多大厂的游戏有自己的联机服务器和验证机制、不仅走 Steam API 的验证。这种也是可以通过虚拟环境破解，但没人做，除非专门对这个游戏的所有 API 做逆向。难度比逆向通用的 Steam API 高很多。## Steamtools 是什么已知 Steamtools 主要是做 **解锁** 和 **入库**。对于会不会破解游戏，网上没有更多的信息。我也不想冒风险尝试使用它。根据官网的解释，Steamtools 可以离线运行（不如说破解游戏只能是离线运行），是提供了类似 GBE 的验证环境。有没有对 DRM 脱壳不清楚，但个人倾向于有，很多游戏都有 DRM 的保护，除了 SteamStub，还有其他的 DRM 验证方式，不脱壳玩不了。因此个人推测是，Steamtools 是集 **解锁、下载、入库、破解、运行时验证** 为一体的工具集。## SteamAutoCrack 是什么只做 DRM 脱壳和 Steam API 验证。项目在 Github 上，破解后的游戏会运行在 GBE 的环境下。这种方式是完全离线运行的单机。## 风险来源完全脱离 Steam 运行没有风险，只要在线就可能有风险。假入库阶段的风险主要来自于入库工具对 Steam 请求拦截的覆盖程度不足。例如 Steam 版本更新了，使得 API 和下载流程有变化，而入库工具没有对其做处理，无法完全欺骗下载流程。网上看到假入库的人可能有囤积癖或者是打算做灰产，一次性入库了几十个游戏，直接导致被 SteamCDN 拉黑。运行时的风险也是来自于在线验证，如果是开着 Steam 玩的破解游戏，没有离线时甚至尝试联机，使得游玩信息发送到了 Steam 的服务器（比如不该有的存档、不该有的联机等等）。另外，入库工具会侵入式修改 Steam的客户端，直接打开 Steam 可能会有检测文件是否被修改。 Steamtools 提供了三种启动模式，可以随时恢复为原版 Steam 的运行。但淘宝卖的入库工具说不准是什么样的，当年骗我的店家那个用的是早期的 steamtools，使用店家的账号下载游戏后，使用 steamtools 离线运行（本来已经忘记了，努力想想竟然想得起来一点细节）。但现在的店家说不准是什么样的，在 B 站看到说有的是直接修改文件，从此都是盗版Steam 客户端，只能卸载重装。没有风险的方式：如果你有方式得到 Steam 正版的游戏文件，然后用 SteamAutoCrack 破解，能直接脱离 steam 运行则没有风险。对于更多的人而言，下载木马是最大的风险。## 参考资料- bbs.steamtools论坛- SteamManifestCache wiki- SteamLess Readme","description":"入库不仅仅是入库","keywords":"steamtools, steam-auto-crack, gbe, Steam假入库","date":"2025-04-22 03:59"},{"id":"2025-04-19-windows-context-menu.md","title":"Windows11 右键菜单自定义 - NileSoft Shell","content":"（发现简中圈居然没有人写这个事，写个草稿发别的地方）\r\rWindows11 右键菜单问题被诟病已有，网上很多还原为 win10 菜单的教程……但 win10 有 win10 的问题，有用的没用的都往里放，常用的不常用的混在一起。有没有一种方法可以兼顾好看，同时有合理的菜单层级呢？\r\r有的 —— Nilesoft Shell。可以自定义的 Win11 右键菜单。已经用了两年多了很好用（以至于差点忘了有这个软件）。\r\r## 下载并安装\r\r下载在官网： https://nilesoft.org/\r\r安装完后，新菜单应该已经生效了，并且会开机自启。这时候可以点点看，如果感觉效果满意就不用再看下去了。\r\r当然颜狗是不满意的，大部分一级菜单我用不上，我只想保留我常用的，不用的塞到更多选项。如图\r\r![](https://img-cf.sansui233.com/imgs/2025/04/202504190843358.webp)\r\r##  挪动菜单层级\r\r如果你是默认安装，`C:\\Program Files\\Nilesoft Shell` 应该能看见以下的文件结构\r\r```\rNilesoft Shell/\r├── shell.exe\r├── shell.nss\r├── imports/\r│   ├── modify.nss\r│   └── ...\r└── ...\r```\r\r以 `.nss` 结尾的是配置文件，可以用记事本打开。以下是几个案例：\r\r### 1. 收纳不常用菜单至 “更多选项” \r\r例如，收纳所有名称里带有 “QQ” 和 “百度” 的菜单项，在 `modify.nss` 添加如下：\r\r```\rmodify(mode=mode.multiple find=\"QQ|百度|网盘\" menu=title.more_options)\r```\r\rfind 中包含的字符串会被匹配，“|”是或。表示匹配“QQ”或“百度”或“网盘”的任意项都会被挪走。\r\r这是主要的挪菜单的方式，我实际上挪了一大堆。\r\r```\rmodify(mode=mode.multiple\r\tfind=\"收藏夹|打印|共享|PowerRename|Microsoft Defender|Change Attributes|File Locksmith|upic|火绒|百度|QQ|Acrobat|Adobe|OneDrive|在沙盒中运行|PicList|旧版 Windows Media Player\"\r\tmenu=title.more_options)\r```\r\r###  2. “创建快捷方式”挪到顶层\r\r有人可能看不惯 创建快捷方式 放在了 更多选项 里。要恢复把 `modify.nss` 中一行注释掉就好。\r\r```\rmodify(mode=mode.multiple\r\twhere=this.id(\r\t\tid.send_to,\r\t\tid.share,\r\t\t// id.create_shortcut, 这行注释掉\r\t\tid.set_as_desktop_background,\r\t\tid.rotate_left,\r\t\t...\r```\r\r###  3. 顶层添加新菜单项 “使用 vscode 打开”\r\r在 `shell.nss` 中，新起一行添加\r\r``` \ritem(title='Open with VS Code' image=[\\uE272, #22A7F2] cmd='code' args='\"@sel.path\" && exit' sep='top')\r```\r\r添加的这行可以不在最后，添加的位置决定它在菜单中的位置。我添加在了中间，最后的几个 \"import\" 之间。\r\r要是问为什么我不用 vscode 自带的右键菜单……我的 vscode 装得太早了，那时还没有右键菜单关联，现在也懒得再装了就将就用吧……\r\r###  4. 顶层菜单添加新目录\r\r你要是在图片上右键，会发现系统自带有“使用 Windows 画图编辑”“使用照片编辑”“向左旋转”“向右旋转”……我的天，哪个天才设计的，你不知道自家照片 App 打开后能编辑也能旋转吗？（我知道这肯定是两波人开发的但还是想吐槽）\r\r秉持着只挪不删的原则，在“更多选项”前加了个“编辑”目录。以下加在了 `shell.nss`\r\r```\rmenu(mode=\"multiple\" title=\"编辑\" image=image.glyph(\"\\uE0A1\"))\r{\r}\r```\r然后在 `modify.nss` 里加了\r```\rmodify(mode=mode.multiple\r\tfind=\"*编辑|旋转|PDF\"\r\tmenu=\"编辑\")\r```\r\r这样等于说，编辑和旋转相关都被归到了新的“编辑”目录下。加上 PDF 相关操作挪进去。我没有装 WPS，装了 WPS 也可以把 WPS 挪一个目录。\r\r## 生效\r\r管理员权限运行安装目录下的 `shell.exe`，点 Register 生效\r\r## 其他\r\r按 shift 后右键菜单，会有一个“Developer” 目录。没错 shift 显示隐藏菜单也可以实现，配置的属性有 `vis=key.shift()` ，但不是实时变化的所以没有mac 上的好用。除此之外还有喜闻乐见的能配置主题、颜色、图标等……我不管了。\r\r##  参考\r\r官网的文档很详细，但是非常面向程序员。不过大部分的需求被人在论坛上问过了，也有人在 issue 里问。不会就去论坛翻一下。看不懂英文开翻译，看不懂文档丢给 AI。\r\r文档： https://nilesoft.org/docs\r\r论坛： https://github.com/moudey/Shell/discussions","description":"颜狗就是得样式和功能性全要，怎么了","keywords":"","date":"2025-04-19 09:21"},{"id":"2025-01-05-2024-summary.md","title":"2024 年的总结与分享","content":"印象中之前每年其实都有写去年主要干了什么，看了什么作品。但又忘了都写在了哪里。今年想起来还是在这里写吧。主要说说看了些什么吧。## 实用小技术1. 无线 iPad 当作电脑副屏某天突然想躺着用手柄玩电脑的游戏，所以 [sunshine](https://github.com/LizardByte/Sunshine) + moonlight(iPad) 串流。效果非常不错！2. 便携显示屏后面，我又嫌无线的码率不稳定，组装了个便携显示屏，变成了躺着用电脑副屏……配件全部拼多多的。- 显示屏，京东方 NV156FHM N69- 驱动版、按键板、软排线- 外壳、音响3. 新的代理协议与客户端今年对于魔法上网，非常重要的事情就是去年年底 clash-core 删库。不过也正好，促使我看看有没有人设计新的协议。协议方面尝试了 hysteria2 和 naive，测试下来已经把 hysteria2 当作主力了。顺便读了下 http2 [rfc7540](https://github.com/abbshr/rfc7540-translation-zh_cn) 和 http3 [rfc 9114](https://datatracker.ietf.org/doc/html/rfc9114) （但现在又忘了！）客户端试了 [singbox](https://sing-box.sagernet.org/)，在 ios 上替代了 shadowrocket，性能好非常多。电脑端 GUI 是典型的后端程序配置的思维，很难用，还是用 clash-meta 系列了。## 单机游戏 1. [Getting Over it](https://store.steampowered.com/app/240720/Getting_Over_It_with_Bennett_Foddy/) (掘地求升)我的天，有生之年我居然打通了这个8年前的破游戏！打通的那一瞬间，我感觉觉得自己已经可能面对任何困难无所不能了。但是山顶的聊天室早已空无一人，有一点寂寞。![Getting over it](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202401131219995.webp)2. [博德之门3](https://store.steampowered.com/agecheck/app/1086940/?l=schinese)tga 2023 年度游戏，不好玩。去年买了，今年和 meme 大师与墨墨联机了好几次，还是玩不下去！打架打一局太久了……而且打不好还要 SL……补药啊！（后面没法联机了其实主要是因为我作息太乱了）3. [双人成行](https://store.steampowered.com/app/1426210/_/?l=schinese)2021 年度游戏，好玩，这个还是感谢陈 sir 陪我打完了，而且因为他是全成就大师所以我也跟着全成就了。因为我竟然买了两年都没有玩，显得特别可怜……4. [Tiny Glade](https://store.steampowered.com/app/2198150/Tiny_Glade/)新出的休闲建筑游戏，最不像游戏的游戏。建筑方式新颖，而且好好看哦！玩了后做了个视频，竟然被 HR 联系了……差点当诈骗私信……![Tiny Glade](https://img-cf.sansui233.com/imgs/2025/01/202501050253199.webp)5. [动物森友会](https://www.nintendo.com/hk/switch/animal_crossing_new_horizons/)到今年才打开这个几年前的游戏。建岛是好玩的，画风也可爱，但因为手游也有在刷，对于刷刷刷的都有点疲惫了。6. [Halo](https://store.steampowered.com/app/976730/Halo_The_Master_Chief_Collection/)meme 大师带飞的经典 FPS，有剧情，非常好游戏！我只用跟在后面捡各种好玩的枪就好了（不是）7. [传送门2](https://store.steampowered.com/app/620/Portal_2/?l=schinese&curator_clanid=31468181)十几年前的解谜神作，好丸！多人模式也是 meme 大师带飞的。8. [Second Eden-理想箱庭物语](https://www.bilibili.com/video/BV1hS411w7tR)这是个新的 minecraft 深度魔改整合包，基于模拟殖民地 mod。我觉得比很多整合包都要好，考虑了流程、循环、引导，有些 mod 加的解谜结构很好玩。但模拟殖民地本身有 bug，加上流程上其实也不是特别完整，只建了一小半。9. 零大陆这是个超老的 Minecraft1.8 原版 RPG 整合包。真的非常震撼能做到这个程度，流程设计、地图设计上超级完整……可惜循环有问题，卡在一个冒险模式下的银河城地下区域了。![零大陆](https://img-cf.sansui233.com/imgs/2025/01/202501050335032.webp)10. 模拟地铁休闲小游戏，也是老游戏了，极简地铁规划，最后发现还是开滴滴比较好。内容对得起价格。也因此和喜欢地铁的朋友有聊些城建游戏。![模拟地铁](https://img-cf.sansui233.com/imgs/2025/01/202501050330486.webp)11. [动物井 (Animal Well)](https://store.steampowered.com/app/813230/ANIMAL_WELL/?l=schinese)解谜 + 平台跳跃。太好玩了，这才是真正的 2024 年度游戏！！而且只 33 M，性能也超好！是像素美术但是是很现代的赛博梦幻像素美术，好看的！![Animal Well](https://img-cf.sansui233.com/imgs/2025/01/202501050325838.webp)12. [传说之下 (UnderTale)](https://store.steampowered.com/app/391540/Undertale/?l=schinese&curator_clanid=31318556)经典日式 RPG，脑洞超大角色有意思，剧情很温暖。是Meme 依据本人的游戏时长与偏好定制的 steam 礼物……非常喜欢！![UnderTale](https://img-cf.sansui233.com/imgs/2025/01/202501050055049.webp)## 动画&漫画1. [葬送的芙莉莲](https://www.bilibili.com/bangumi/media/md21087073)中世纪魔法动画，难得味这么正，不算是我非常喜欢的类型但能看下去。而且作画的流畅程度真的……太有钱了！整体比较日常，很温馨。2. [蓝色禁区 Blue Lock](https://www.bilibili.com/bangumi/media/md28339713)足球番，我原以为我不喜欢看，最后根本停不下来……动画第一季做得实在太好了，但第二季是 PPT，1 分都不想给……漫画非常棒，不愧2024 年的日本漫画销冠。不过我是其实从其中一对 CP 图决定看，结果看完动画觉得这两人麦太多了……不如好好看球！3. [异形舞台 Alien Stage](https://www.bilibili.com/video/BV1ag4y1W78U)动画音乐剧，讲的外星人饲养地球人当宠物，看人们在舞台上通过选秀比赛相杀的故事。特点是，一集一个寡妇（夫）……太刀了！## 电影1. 你想活出怎样的人生宫崎骏动画电影，我觉得依旧很好看，很温暖。2. 蓦然回首（Look Back）藤本树动画电影，讲普通画画人的故事。非常牛美术风格。尽管我不是画画人，也没有很好的画画天赋。但也有一些感受有经历过，日复一日练基础，什么时候都在考虑画画……以及藤本树居然开始走治愈系了！3. 志愿库 - 存亡之战怎么突然出现了国庆战争片……这个真的拍得挺好的，算是近年陈凯歌的不那么扑的了。以及我有朱一龙演技滤镜，在超烂低成本不被任何人看好的改编网剧里，因为演技太好而突然红的，真的没得说。4. 名侦探柯南 - 黑铁的鱼影和雨疏的年度固定节目，不错的粉丝向主线剧场。真好啊真好十年后还在和她一起看柯南。## 音乐年度歌手还是 Radwimps，基本老歌。上半年没怎么听年底听 4 块钱的直播，才发现日系真是年年有天才。「晚餐歌」真的很厉害。原来不是我不喜欢听歌了，是没关注到好听的歌了，网易云日推越来越不行了，一直推各种时下 OP ED。## 技能相关- 游戏，给 MC 服务器写了 彩虹帽子 数据包。想来这其实是第一次和游戏有关的编程，经典入口是帧更新 tick()。- 画画，学了平面设计的课，作业也很肝完了，有一些收获。然后又看了些曼奇的网课，素描关系有提升，就是增加了短调子、空间感、体积感的意识。我之前也不是感受不到，而是没觉得差一点明度就会差很多。这是 Ti - Se 画画相比于 Se - Ti 的劣势，需要有理论后才能画得好……- 原神里头一回赶上音游的版本，写了几首比较难的谱面，这个非常满意，是我自己都可以反复玩的！## 专业相关~~这随便吧又没人看。~~- 笔记主题没怎么更，我也用得越来越少了- 博客有更新，但忘了！- 新写了个服务器的监控页。- 论文挣扎着狂补。- 有去接触 GPU 相关的，不想只停留在业务 MVC 再 CRUD。但看了发现没需求的话确实用不上。公司的相关还是不说了……主要是图形学和，久违的 OOP 编程，新的语言 C#，但长得非常通用面向对象，没有太多的入门门槛。不禁感叹外面世界的语言真是五花八门……但要说写界面好用还是声明式的，OOP 写界面特别过程式就，扭曲，痛苦，但无疑性能会更好。","description":"怎么全在写游戏……","keywords":"","date":"2025-01-05 09:21"},{"id":"2024-11-12-把drawio装修为简单美观的白板应用.md","title":"把 draw.io 装修为简单且现代的白板应用","content":"[draw.io](http://draw.io) 是一个功能丰富的流程图绘制软件。此前写论文时我一直使用这个软件画图。在没有系统性的画图需要，转而变成了有时想要随手画矢量示意图后，这个软件启动交互流程步骤繁琐，我便极少使用它了。但在使用了 tldraw, excalidraw 后，又回到了 [draw.io](http://draw.io)，才发现这个软件的可定制性其实非常强，完全能满足随手画图的需要。这里记录一下如何把 draw.io 变成一个更适合打开即用的、默认效果更加现代的白板应用。![image.png](https://img-cf.sansui233.com/imgs/2024/11/202411120511240.webp)（草……windows 截图这边缘的黑框好丑啊！）## 为什么是 draw.io先对比一下适合需求的竞品（不想看请跳转下一节）：- [visio](https://www.microsoft.com/en-us/microsoft-365/visio/flowchart-software): 收费，而且 mac 上没有。- [tldraw](https://www.tldraw.com/), [excalidraw](https://excalidraw.com/): 更适合作为 sdk 使用，作为成品有些过于简单，在易用的同时，想多做一点非流程图的东西又很复杂，中文字体也不契合其默认的手写设计。而且并没有打包为桌面 App，文件关联是个问题。- [processon](https://www.processon.io/): 要登录- [figma](https://www.figma.com/): 要用梯子登录- powerpoint: ……我只是想偶尔画个示意图- 飞书: 每30天要扫码登录 ……我只是想偶尔画个示意图- adobe illustrator: 没有常用预制样式库，漫长的启动时间，对于没接触过的人学习成本很高。- 无边记、goodnotes: 苹果移动端生态 only[draw.io](http://draw.io) 没有上述的问题，但它由于设计之初不是个草图应用，所以：- 默认较为重型的 UI- 启动先选择储存位置，太慢了- 默认组件样式很丑，看起来只适合工控图- 有时会感觉曲线箭头很难调，怎么都不流畅我根据以上三点问题大致说一下如何改进。## 更换UI布局默认的 UI 较为传统的重型设计，熟悉这类UI是相当好用的，但按钮组过多会显得不够轻便。在 `其它→主题→外观` 中可以更换为其他的主题，有5套可用：经典、极简、简易、草图、atlas。我个人用得比较多的是「简易」，并且关掉了左侧栏形状库的栏，改为用顶栏，右侧格式栏在顶部有快速按钮展开。习惯 tldraw、excalidraw 的用户应该还是更适合「草图」主题，绑定了基础形状的快捷键。需要去手动调出格式栏。![image.png](https://img-cf.sansui233.com/imgs/2024/11/202411120511552.webp)## 更改启动流程默认情况下，启动时会弹出选择保存位置的框。新建画布时，又会先看到一大串模板的选择题，还得去想命名。但很多时候，随便画图是不需要保存的。在经典主题下，需要去「其它」→「显示开始画面」上取消勾选。在其它的主题下，则需要去菜单的「设置」→「配置」里取消勾选「显示开始画面」。![image.png](https://img-cf.sansui233.com/imgs/2024/11/202411120516688.webp)## 配置默认样式要做到更改默认样式，需要写 JSON 配置。尽管可以在侧栏按「设置为默认样式」，但只能当前打开的窗口生效，刷新、新开文档都会导致默认样式回到最初的样子。在经典主题下，需要通过 「其它」→「配置」打开，其它主题下，则是「设置」→「配置」。> **我的配置已经上传到 [gist](https://gist.github.com/Sansui233/a7f5b88e35194f82b1a76a7e05df4f5c)。**JSON 写法参考了如下文档：- [Customise default shape libraries, templates and plugins in draw.io for Confluence Cloud - draw.io](https://drawio-app.com/blog/customise-default-shape-libraries-templates-and-plugins-in-draw-io-for-confluence-cloud/)- [Configure the draw.io editor](https://www.drawio.com/doc/faq/configure-diagram-editor)[draw.io](http://draw.io) 的图形分为 vertex（顶点图形） 和 edge（箭头、线段）两类，选中按 `ctrl + e` 即可查看当前图形应用的样式。### 配色与样式设计整体采用的粗线条粗体，比较契合现代简约又活泼的趋势。edge 采用黑色，与高饱和的 vertex 非常好搭配。直接抄的无边记的颜色，有的有轻微的改动。不过无边记最印象化的水蓝色没有抄上去。默认的配色改为了最后一个蓝色。以下配色均可以在右侧的「格式栏」中找到并应用。![配色方案.png](https://img-cf.sansui233.com/imgs/2024/11/202411120513014.webp)### 关于圆角矩形现代设计中圆角矩形用得更多。对于圆角的弧度，可以通过属性 Arc Size 去调整。可以点击设置为默认样式，也可以配置到 JSON 里。![image.png](https://img-cf.sansui233.com/imgs/2024/11/202411120514766.webp)如果你使用的「经典」主题，需要自己选择圆角矩形的图形。在「草图」主题下，按 `D` 就是默认配置好的圆角矩形，相当简单。「简易」主题下的位置如图：![image.png](https://img-cf.sansui233.com/imgs/2024/11/202411120511067.webp)### 关于曲线设置曲线设置不对会变得很难调整，一张图说明大多数情况下的曲线操作与设置：![曲线.png](https://img-cf.sansui233.com/imgs/2024/11/202411120515358.webp)### 想更换为手写风格？在不选中任何东西的情况下，把右侧格式栏的草图勾选上即可，就可以获得类似 excalidraw 的手写风格啦！另外，如果没有自定义 JSON， 「草图」主题下的默认样式也是手写风格的。### 关于默认字体（附网页用字号推荐）JSON 中这几个字段设置默认字体。我默认英文是 Inter，中文是使用的系统黑体。文字大小我设置为了网页标准 16px。```json{  \"customFonts\": [    \"Inter\",    \"pingfang sc\"  ],  \"defaultVertexStyle\": {    \"fontSize\": 16,    \"fontFamily\": \"Inter\"  },  \"defaultEdgeStyle\": {    \"fontSize\": 16,    \"fontFamily\": \"Inter\"  }}```另外介绍一下常用网页文字大小的规范，现代的美术设计由于自己屏幕很大，或者对标准视距缩放大小没太多概念，非常容易把字给设置得很小（点名星穹铁道）- 16px 为默认正文大小，但由于主要是考虑了希腊字母面积比较小，所以也有的中文网站会设置为 15px。- 14px 偏次级小段落、不重要的文字，长时间阅读会累。- 13px 为代码常用大小。- 12px 已经非常小了，是正常视距下最小可视大小，适合做脚注、引用。再小的字号不推荐作为内容性文本使用。### 关于背景网格在简易主题中默认关闭的，经典主题中可以通过配置 JSON 为默认关闭。关掉背景网格会显得比较现代化。```json{  \"defaultGridEnabled\": false,  \"defaultPageVisible\": false}```但还是有时可能需要开启网格，那就什么都不选中，右侧栏开启网格就可以了。## 其他使用 Tips### 导出设置导出时注意一下缩放。网页标准大小字体为 16px，编辑时画布 100% 缩放下一切正常。但是当导出为位图（jpg, png）时，需要根据你的显示器缩放进行放大，否则文字一定会糊。我的显示器为 150% 界面缩放，因此需要缩放到 150% 才能大概清晰，如果要让 4k 屏也看得无比清晰，最好导出 200% 缩放，且 dpi 尽量在 180 以上。另外可以直接框选后右键复制，不一定要导出。### 一个文件画多张图经常会遇到多张同系列图的需求。为此，你可以选择都画在一页上，要用时框选特定范围，右键复制为 png 。这样很适合边聊天边画图发给别人，但也会失去缩放、加白底、加白边等设置。至少你得打个组，把 16px 的文字放大后再复制，以确保结果不会糊。[draw.io](http://draw.io) 也可以分页，建议是一页一个图，可批量导出。### 从 Mermaid 生成图、嵌入 Notionmermaid 是一种画流程图的代码，比较适合不想可视化排列对齐的强迫症。draw.io 可以在菜单中的「高级」使用 mermaid 生成图，下面的图就是导入 mermaid 生成的。![未命名绘图.png](https://img-cf.sansui233.com/imgs/2024/11/202411120516990.webp)由于 notion 无法画图，在 notion 我都是用的 mermaid，有点不好看但至少目的达到了。不过最近发现，[draw.io](http://draw.io) 的导出可以选择直接嵌入notion，点开还能进行编辑……实现方式是图像数据全部存放在了链接里……不得不说 draw.io 自主兼容性做得很强，从接入了那么多网盘就可见一斑。### 自定义CSS如果还是觉得 UI 太丑了，在 [Configure the draw.io editor](https://www.drawio.com/doc/faq/configure-diagram-editor) 中可以找到自定义 CSS 的部分（但我觉得 UI 排列上还是不错的，这足够了）","description":"装修无止境！","keywords":"draw.io, 白板, whiteboard, figma, processon, 流程图工具, 草图, 矢量图","date":"2024-11-12 13:19"},{"id":"2023-09-29-windows-system-chinese-fonts-adjustment.md","title":"Windows 调整之中文字体","content":"> 以下仅适用于低于 4k 缩放 200% 的显示器微软雅黑作为随着 Windows7 出现的字体，加上遥遥领先（？）的 ClearType，在当时的 1080p 显示器上十分清晰易读。但如今的显示器分辨率越来越高，旧版微软雅黑的设计存在着明显的缺陷。一是其字形设计并不平衡，中宫过大，有的字形可以以难看来形容；二是微软雅黑字形只在 4K 屏 200% 缩放（以上的配置）上有着较好的显示效果。微软曾经设计过“另一版的微软雅黑”，即 Noble Scarlet，但并没有在正式的系统中使用。这一版字体设计依然中宫偏大，但相对老版收敛了不少，平衡了一些。另外，如果你不巧像我一样用着 2K 或 2.5K 屏，- 在 24寸时，100% 缩放字体比较合适，但与 16 寸 1080p 显示器差不多清晰度，不过屏幕可用空间更大。- 在 21 寸时，100% 缩放字体会偏小，比较锻炼眼睛。150% 缩放字体大小比较合适，效果更细腻，但字型会比较怪，且屏幕可用空间与 1080p 相同。- 在 16 寸时，150% 缩放字体稍微偏小，效果比较细腻，但非整数倍缩放+ClearType 的加持下，一些像素被吞掉，笔画的间距不平衡，有种“ windows 特有的字被虫噬的美”。![字形](https://img-cf.sansui233.com/imgs/2024/08/202408190158527.webp)可以看到，上图的 100% 200% 缩放没有字形变形问题，可以说微软雅黑小字优化是考虑的 100% 缩放。100% 缩放显得糊则是因为图片放大放大倍率过高，实际不会有糊，而是有锯齿感。150% 缩放会由于 clearType 的“锐化”导致字形变化，不知道的还以为换了个字体。如果是125%、175%的缩放，字体变形更加糟糕。造成缩放问题的原因大概可以用下图进行简要解释：![缩放](https://img-cf.sansui233.com/imgs/2024/08/202408190318888.webp)Mac 上的 Retina 渲染相当于 4k 200% 缩放起步。而 windows 下， 2k-2.5k 的屏幕都在 200% 以下的缩放中挣扎。如果软件没有适配高分屏，没有 clearType，强制进行双线性缩放（常见于图片UI），就会显得非常糊。想体验这样的糊，可以下载旧版的原神启动器。##  需要准备- **Noble Scarlet**  替换系统的微软雅黑。由于 Noble Scarlet 是一个未完成的字体，普遍使用的是社区修正版，以下是资源参考。  - [pcbeta](https://bbs.pcbeta.com/viewthread-1960120-1-4.html)  - [bilibili](https://www.bilibili.com/read/cv6059905/)- 系统字体替换工具：搜索 “[字体替换工具 by 随风飘扬](https://www.fishlee.net/soft/SysFontReplacer/)”。替换完后重启，否则可能有缩放错误。另外，github 上有一个非侵入式的系统字体替换工具 [noMeiryoUI](https://github.com/Tatsu-syo/noMeiryoUI)，可惜换不全 windows 11，只是作为预览不同字体在系统上的效果倒是个很不错的工具。- [**MacType**](https://www.mactype.net/) 改善 ClearType 的虫噬渲染方式带来的不均匀，使用后提升非常非常大。- **[思源宋体](https://source.typekit.com/source-han-serif/cn/)**：推荐将浏览器的 Serif 字体设置为此字体。默认的宋体真的，不论中文英文，都很丑……只适合打印。##  常用正文黑体简述![](https://img-cf.sansui233.com/imgs/2024/07/202407260100518.webp)### 苹方苹方是一款设计上很优秀的字体，其间架结构、中宫非常平衡，既兼顾了传统的汉字笔画细节又有规整而现代的几何化，间距合理，阅读起来非常舒适。但是……苹方的设计缺字重。在设计上，苹方没有 Heavy 字重（[参考](https://support.apple.com/en-us/103203)）。而在[流行的 github 苹方字体仓库](https://github.com/paraself/PingFang-Fonts)中，则是将 Bold 字重映射到了 Heavy，而将原本的Medium 映射到了 bold。虽然这个问题不是苹果设计的导致的，而是一个再次分发时的错误，但致使目前网上能搜索到的第三方仓库的苹方字体整体字重均偏细。另外，苹方在 2.5K 屏上表现非常糊，苹方问世时已经进入了 Retina 屏的时代，没考虑过在低 PPI 屏幕上的表现（不是4K屏缩放200%都别用）。第三，苹果设备的显示的西文字体是 [San Francisco](https://zh.wikipedia.org/zh-hans/San_Francisco_(2014年的字体))，不是苹方。在 [细数 Pingfang SC 的七宗罪](https://lrd.im/blog/2022-01-17) 中，也提到仅使用苹方导致不同设备字体 fallback 的不一致的问题。而作为系统字体里的其他问题，例如缺失本地化的字型，也是大部分字体所缺乏的，这已经不仅仅是一个字体问题，而是和字体相关的和 UI 技术标准化问题，难以仅通过字体解决。而无比例数字、冒号不垂直居中、没有垂直标点等细节，则都是因为苹果显示标点数字用的 SF 字体，苹方在此类字符上算是基本能用，但缺少多种场景下的细节。其他资源： [Pingfang for windows - Figma](https://www.figma.com/community/file/1089832205783108371)另外，苹方是有版权限制，以下字体除了思源黑体，和大厂的开源黑体，均不可免费商用。###  思源黑体系列思源黑体(Noto sans) 是 google 的开源可商用字体，用于 Android 系统，在开源可商用的的黑体其质量无可替代。更纱黑体是思源黑体的衍生，修改了西文部分，相比思源黑体上更符合作为 无明显风格特征的系统字体，带 hinting 在 1080p 和 2.5k 下都能保证良好的清晰度。但是，思源黑体系列设计相比于国产的商用字体并不能算好，有时间架结构比较怪异，字形的细节不太统一，比如“用”字明显矮了一截，整理风格上给人一种不稳定感。同时也不是一个大气的字体，比如口字旁处理对于黑体而言偏小，“用”字矮了一些，但是在宋体设计上，“用”字矮的这一截反而让字体看起来平衡。而一个系列的字体衬线、非衬线的统一感来源于其比例，个人理解为思源/更纱系列是优先考虑宋体的字形，和黑体的比例有一定的结合。整体而言还是宋体的设计更加优秀。相对而言更纱黑体更适合作为系统字体，有着合理的 hinting。思源黑体是不太适合低 ppi 屏的，它的 Regular 字重看起来像 Bold。###  方正兰亭系列（微软雅黑）Noble Scarlet （社区版）常规体是新设计中宫收窄的微软雅黑，而粗体是方正兰亭黑 Pro，因此在加粗时，字体明显会变小一圈。微软雅黑系列字体在标点处理上很差，最直观的就是全角引号，太像半角的处理方式，很难看出前引号与后引号的区别。其实我在写这一篇文的时候，换了 Typora 的字体，才发现前后引号全打反了……方正兰亭黑 Pro 想对于两版微软雅黑都有着更小的中宫，字形设计中正。但也由于稍小了一些，在低 ppi 屏的小字上笔画更容易显得不太均匀，渲染效果不太好。另外使用此字体需要相比于其他所有字体更大的行距，因为其较小的中宫，字间距显得相对宽了。###  汉仪旗黑系列近年来的国产安卓厂商字体都是汉仪旗黑的衍生，代表阿里的普惠体、鸿蒙体、小米的字体、Oppo的字体。这系列字体间架结构合理，但笔画上更加激进，减弱了起笔与收笔的的传统突出，以追求几何感与现代的科技感。在观感上，这样规矩的方形会使得字体相比方正系列更加圆润，多了现代感但少了汉字的人情味，用于阅读小说时尤其明显。仅字形而言，作为 UI 是非常不错的。不过 Misans 渲染出来明显偏粗，我没有测试其他同系列字体是否也有这样的问题。##  改掉 Windows 的默认中文无衬线字体很多无法分别修改中英字体的 windows 原生应用，当只设置了英文字体时，显示的中文是新宋体（SimSun），比如 vs studio。原因在于系统里的 Microsoft Sans-serif 字体名，回落到的第一个字体就是新宋体……难以想象微软雅黑出了十多年了还有这样的问题。解决办法：- winkey + R, 输入 regdit，进入 windows注册表- 进入 `HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink`- 把 Microsoft Sans Serif 的值中 SIMSUN.TTC 那一行去掉。这样默认的无衬线体就会往后 fallback 到系统的微软雅黑上。- 把 `Segoe UI` 的 `TAHOMA.TTF,Tahoma` 挪到 `MSYH.TTC,Microsoft `后面---创建于 2023-09-29 02:25:44更新于 2024-08-19 01:45:31","description":"让 windows11 字体更好看的一些设置与字体浅谈","keywords":"Windows工具, 软件推荐, Windows调整, Windows设置, 字体, 字体设置, Noble Scarlet, 微软雅黑","date":"2024-08-02 02:08"},{"id":"2024-02-29_像素的一生.md","title":"笔记 - 像素的一生","content":"内容来自于 2018 年谷歌的一个视频。原视频不长但内容很多，非常值得一看。Chrome 的渲染机制是在不断变化的。笔记原存于 Logseq，如果有类似于，“见CSS/图层”一类的语句，为笔记内超链接。相关概念需自行了解。📚 **资料**- [b站视频 - 2018](https://www.bilibili.com/video/av35265997/?vd_source=a94b8ba67535fb1431364b8c5fac341d)- [英文slides](https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit?pli=1)- [思否文章](https://segmentfault.com/a/1190000020102554)**渲染流程**：web content → magic(rendering) → pixels## 1. Web content最常见的 HTML + CSS + Javascript API还有图片、视频、音频、web assembly、WebGL、Canvas、PDF等等![Web Content](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342847.webp)## 2. 渲染渲染是在一个 sandbox 进行的。渲染引擎 Blink 是渲染代码的一个子集。操作系统渲染 API：OpenGL，DirectX(Windows), vulkan。包含 textures shaders 等等。### 2.1 渲染目标1. 把 web content 渲染为 openGL 的调用2. 为更新渲染建立起对应的数据结构### 2.2 基本渲染流程![渲染流程](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342848.webp)渲染流程太复杂，会被分为几个阶段进行数据结构的转换不是每一次更新渲染，都要走全部的流程。相关看 浏览器/渲染原理 中的回流与重绘。#### HTML to DOM解析 HTML 为 DOM 树。DOM树的作用有两个，一个表示文档结构，二是暴露 API 给 Javascript，由 V8 JS引擎进行 API 绑定。#### CSS to ComputedStyleCSS 转换为 StyleRule 集，每个 StyleRule 包含 CSSSelector 和 CSSPropertyValue。流程如图![css parser](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342849.webp)根据 css 样式规则，计算出每个 DOM 元素样式属性的最终值，存储于 **ComputedStyle** 对象模型中，是一个 style properties 与 values 的超大映射。这个过程被称为 Style Resolution。![style resolution](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342850.webp)**ComputedStyle** 对象已经暴露给了 JS。使用`getComputedStyle(element)['padding-top']`即可获取。在 Dev tools 的 Elements 中的 Computed 选项卡的值就是依据此 对象来的。#### Layout Stage例子：- Web 最基础的 Block Flow 布局，需要计算出 Block 的 x、y、width、height。- 由于 Block 自适应高度，需要根据内容的尺寸，找到文字换行的地方，以计算每个 Block  的高度。- 每一个 Block 的矩形有多种边界（在CSS/盒模型中说得很清楚）。内容 overflow 时，需要计算两个矩形，一个是**实际内容区域**，一个是**能显示出的内容的区域**。如果内容可滚动，还要计算**滚动边界**和**滚动条边界**。Document 的根节点本身就是 overflow 且可滚动的。Layout Objects 也树结构存在，几乎与 DOM 是一对一，但并非总是如此。比如伪元素、浮动元素。![layout](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342851.webp)在 style 计算后会构建一个没有填入任何数据的 **Layout Tree**。**更新布局**的本质就是遍历 layout tree 并向里面填充所有数据。Slides里说目前没有把 Layout Stage 的输入输出区分开，但没细说，只是说下个版本会改。放个图![Layout Stage NG](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342852.webp)#### Paint to display item lists做类似于在指定坐标内画一个红色的矩形这样的动作。代码结构上 ，是 LayoutObject 有一个 Paint 方法。去调用更底层的 Paint  API。**此阶段生成“作画步骤”，还没有真的画出像素**。步骤是可以重放的。至于为什么这样做，之后再说（然而之后并没有说）。Paint 是从 z-index 最大到最小进行的，而不是 DOM 的前后顺序。而两个并列的层叠上下文时，后覆盖前。在一个 CSS/层叠上下文 内，按层叠上下文的堆叠规则绘制（z轴的层叠规则），如图![image.png](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342853.webp)#### Rasterization 栅格化将 Display Item（位于 CC Layer 中，之后说）中记录的 Paint 操作转化为**位图**(bitmap)。raster bitmap 通常保存于 GPU 内存中，被 **OpenGL Texture Object** 引用。GPU 不仅可以保存 bitmap，也可以生成 bitmap。叫 **accelerated rasterization**。**此时像素纹理已经生成到内存，但还是没有画到屏幕上。**![Rasterization](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342854.webp)栅格化通过 **SKIA 库**生成对 **OpenGL** 的调用。SKIA 提供了一系列对硬件的抽象。具体而言，PaintOps 会调用 SKIA 中的 SkCanvas 对象。![SKIA](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342856.webp)由于渲染过程是在 sandbox 进行的， 不能产生系统调用，OpenGL 调用是通过 command buffer 塞进另一个进程 **GPU Process** 执行的。GPU Process 接受到绘制命令后通过 GL API 去产生真正的 GL 调用。使用 GPU process 隔离渲染进程除了渲染进程有沙盒机制外，OpenGL 可能也不太稳定或者是有漏洞。GPU Process 可以做一些保护措施。GL API 来源于系统动态库 `libGLESv2.so`。但是 windows 中来自于 Google 的 ANGLE 库 `libglesv2.dll`，因为 Windows 上渲染不是用的 OpenGL，而是 DirectX API。ANGLE 库可以翻译 OpenGL 调用为 DirectX 调用。![GL API](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342857.webp)## 3. 图层合成### 3.1 帧与动画每一帧是当前 Web 内容的完整呈现。动画是连续的帧。针对第一部分提到的 style、layout、paint、raster，浏览器都做了跟踪失效的处理，只重绘改变的部分，其他部分复用。### 3.2 合成线程一个单独的渲染线程，减少 JS 主线程的其他操作和渲染之间 block。**图层**给合成线程渲染。比如 video 和 gif 在单独的图层，还有 transform3D, will-change 等 css 属性也会新建图层进行处理。合成线程也需要处理交互。能处理的先合成线程处理（比如滚动），处理不了的就进主线程。**Layer Tree**（CC Layer Tree）图层也是以树结构存在，前序遍历。有的图层的存在不是绘制，而是图层效果，比如剪贴蒙版、滤镜。![layer tree](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342858.webp)图层的合成位于 CC (Chronium compositor) namspace, 所以代码里有很多 `cc::layer`。如果一个 Layout Object 没有指定单独的 layer(比如没有 will-change 属性)，就会被绘制到父 layer 的图层。Paint Layer 是要被分到 CC LayerTree 的。这就是CSS/层叠上下文与CSS/图层之间的关系。![image.png](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342859.webp)![paint layer map](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342860.webp)### 3.3 compositioning update在上一章的流程中，没有讲到合成这步，实际要加上。因为合成不是必须的，但合成步骤能优化渲染。![更新合成](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342861.webp)未来，创建图层的工作会放到 paint 之后（slimming paint）![commit](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342862.webp)**commit**提交一次合成。这里合成线程与主线程都存在 layer tree，需要同步合成线程与主线程的状态。### 3.4 Tilling在 rastering 阶段，把 CC layer 分块成 tile。**tile 是 raster 的最小单位**，在专门的 **raster 线程** 进行栅格化。合成线程有一个 **tile manager** 安排 tile 优先级。不同分辨率的 tile 策略是不同的。### 3.5 Drawing不同 tile 合成为 **Quad**。Quad 引用内存中的 raster output，封装在合成进程中，再提交到浏览器进程。浏览器动画帧的**帧**概念就是 Quad。![Quad](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342863.webp)不同 commit 有先后顺序，需要从 pending **激活**再绘制。### 3.6 Display浏览器进程将 Quad 展示到屏幕上的过程。位于 Viz 组件中，调用 OpenGL 绘制 GPU 进程中的 Quad 资源，和 rastering 的 GL call 一样。大部分平台的显示合成输出是双倍缓冲（有过游戏画面撕裂经验的应该对这有概念），quad 是在后台缓冲器（GPU的还是Viz？）中绘制的，用 swap 命令让后台的 quad 到前台展示。## 4. 总结Blink 引擎严格执行了主线程的步骤。但由于要实现 Web 平台化，是有一些合成线程的权限的。![总结](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/202402292342864.webp)## 其他渲染器和浏览器都用到了 GPU，都有向GPU进程的IPC通道。如果想让滚动的交互产生的动画不在主线程而在合成线程执行，需要强制 will-transform 分层","description":"浏览器渲染原理","keywords":"浏览器，渲染，回流，重绘","date":"2024-03-01 07:45"},{"id":"2023-11-29-windows-shell-configuration.md","title":"Windows 命令行相关配置","content":"## 常用 shell一直以来 windows 的命令行方案都很多，个人感觉都有不太好用的点，怎么配置也是仁者见仁智者见智的一个事情。先总结一下常用shell 方案- `powershell` 官方shell，各种工具库支持最全，缺点自带的命令太长，以至于完全没有日常使用的想法。- `msys2` windows 上的类 unix 环境，基于现代 Cygwin (POSIX兼容层) 和 MinGW-w64（工具包）。确实像 unix，一般命令可以无缝迁移。缺点是兼容性，需要手动配置很多东西，比如是否继承 windows 环境变量，不继承的话不想维护两份环境，继承了又容易冲突。- `git bash` msys2 阉割版，无包管理，多了 git。- `wsl` 完全的 Linux 子系统，但太占内存。## 方案选择我需求- 常用命令必须是类 unix 命令- 有包管理器，各类命令行工具配置友好且兼容性不错。- 不要太占内存结果发现这就是经典的三圈相交，没有任何一个常用方案能满足以上要求。最后，我决定用 powershell。除了第一条外都满足。后面两条属于难以解决的硬伤，而第一条可以编写脚本，将常用的命令模拟。### powershell 配置流程包含工具包、终端美化。1. Install the latest Powershell Core2. Install [git-bash](https://gitforwindows.org/) for basic bash and git tools3. Install [Windows Terminal](https://apps.microsoft.com/store/detail/windows-terminal/9N0DX20HK701?hl=zh-cn&gl=cn&rtc=1) and open Powershell4. Install [PSReadLine](https://github.com/PowerShell/PSReadLine)5. Install [starship](https://starship.rs/) with **Winget**, Don't use scoop(too slow).7. Install [gsudo](https://github.com/gerardog/gsudo) for softlink8. Install [eza](https://eza.rocks/) for listing9. open `$PROFILE` in powershell, append the contents of [**Microsoft.PowerShell_profile.ps1**](https://gist.github.com/Sansui233/0451b8f7c354d600c4efa74fc284d39c#file-microsoft-powershell_profile-ps1)大致介绍一下用途。- git-bash，一系列类 unix 工具，git 一类的- Windows Terminal，微软的终端。我拒绝终端用 electron 去套的……- PSReadLine，改变一系列 powershell 的行为。比如复制粘贴的快捷键。可惜在 vscode 里会没用，只能右键粘贴。- oh-my-posh，美化。需要用 Winget 或者自己 Setup 安装。不要让 Scoop 装，找环境变量这一步能把启动速度拖慢1s。这个可以用 starship 或者 posh-git 替代。不过都挺慢的。- gsudo，提权，类似 unix 的 sudo。可能运行时会被杀软报毒，需要加入信任区。- eza，2024年了，终于有了一个像样的 ls 替代……powershell 的用户配置文件输入 `$PROFILE` 就能找到。我的配置文件上传到了 [**Microsoft.PowerShell_profile.ps1**](https://gist.github.com/Sansui233/0451b8f7c354d600c4efa74fc284d39c#file-microsoft-powershell_profile-ps1)。需要挂代理打开。配置文件包含 `ls` `ln` `open` `grep` `which` 等命令模拟。powershell 的缩写默认支持了 `mv` `cat` `rm` 等命令，配合起来日常基本够用。## 终端代理我在配置文件中设置了`proxy`和`unproxy`函数，以快速设置与取消终端的代理连接。自己改下端口就能用。因为我自己习惯上不开系统代理，都是软件内的 http 连接。```powershell# Proxy Togglersfunction proxy {\t$portInUse = netstat -ano | findstr \"LISTENING\" | findstr \"7890\"\t$portInUse2 = netstat -ano | findstr \"LISTENING\" | findstr \"10808\"\tif ($portInUse -ne $null) {\t\t$env:HTTP_PROXY = \"socks5://127.0.0.1:7890\"\t\t$env:HTTPS_PROXY = \"socks5://127.0.0.1:7890\"\t\tWrite-Host \"Proxy set to socks port 7890\"\t} elseif ($portInUse2 -ne $null) {\t\t$env:HTTP_PROXY = \"socks5://127.0.0.1:10808\"\t\t$env:HTTPS_PROXY = \"socks5://127.0.0.1:10808\"\t\tWrite-Host \"Proxy set to socks port 10808\"\t} else {\t\t$env:HTTP_PROXY = \"socks5://127.0.0.1:1080\"\t\t$env:HTTPS_PROXY = \"socks5://127.0.0.1:1080\"\t\tWrite-Host \"Proxy set to socks port \"\t}}function unproxy {\t$env:HTTP_PROXY = \"\"\t$env:HTTPS_PROXY = \"\"}```## 其他常用工具- winget：自带的包管理器，命令行工具都是这个装的。部分用的 scoop，非常少。还有的直接用的官网 setup。- nvim：命令行编辑器，vim 的替代品。我用的是发行版 AstroNvim。之前也有自己折腾插件，太懒得维护了，算了。- nodejs：JS 环境，nvim 的插件要用，开发也要用- zoxide：快速跳转目录。最有用的功能没有之一。类似 unix 的 autojump- Terminal-Icons：ls 命令加 icon，还能解决 ls 不高亮的问题。但是，颜色很丑。但是，我不也想再配置了，配置真的心好累。- ripgrep：类似 grep 的用法。我在模拟 grep 命令时只是单纯替换成了 findstr，真的 grep 建议用 ripgrep (rg) 替代。nvim 的 telescope 一些插件也会用到。安装脚本汇总：```powershellwinget install condawinget install neovimgit clone --depth 1 https://github.com/AstroNvim/AstroNvim ~/.config/nvimwinget install gerardog.gsudowinget install OpenJS.NodeJSLTSInstall-Module -Name Terminal-Icons -Repository PSGallery; Import-Module -Name Terminal-Icons# z-jumpwinget install zoxide # z-jump, see https://github.com/ajeetdsouza/zoxidewinget install BurntSushi.ripgrep.MSVC # grep 的完全替代品```## ZSH有关 zsh 相关的配置，我放在了 [Windows 命令行相关配置之 msys2+zsh+zi](https://sansui233.github.io/posts/windows-zsh-conf) 。","description":"","keywords":"Windows命令行, Windows调整，Windows设置, powershell","date":"2023-11-29 12:07"},{"id":"2023-11-11-typescript-generatic-type-proble-ts2322.md","title":"关于 typescript 泛型中返回值类型约束的问题","content":"最近遇到这么一个需求。> 定义一个函数接口，要求其返回值类型是 type A 的任意超集。于是我按直觉写下了：```typescripttype A  = { a: string }type FuncA  = <T extends A>() => Tconst f: FuncA = () => {  return { a: \"ok\" } }```人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：```textType '() => A' is not assignable to type 'FuncA'.  Type 'A' is not assignable to type 'T'.    'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322)```这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如```tsfunction foo(){  return \"1\"} // 自动推断出函数的具体签名为 () => string```那为什么上面的报错例子，不能做这样的推断呢？```tstype A  = { a: string }type FuncA  = <T extends A>() => Tconst f: FuncA = () => {  return { a: \"ok\" } } /* 推断出具体的签名类似于() => {  a: string;  [name: string]: any}*/```也就是说，a 是必选属性，其他属性全是 optional。（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？在 typescript 的 [github issue](https://github.com/microsoft/TypeScript/issues/50027) 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：> 如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 `()=>{}` ，没有prop 属性。但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：```tstype A = () => void;type B = () => void;// 类型签名为 <T extends A | B>(value: T) => T 的实现function f1<T extends A | B>(value: T): T {  return () => {};  // 推断出 T 此时是 typeof ()=>{}，也就是 ()=>{}}let f: any= ()=>{}f.prop = \"haha\"f1(f) // 这里传参报错，因为 typeof f 和 typeof ()=>{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错```当然上面的例子返回值类型已经定了是 `typeof ()=>{}`，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。> 什么是 subtype？T extends A，T 就是 A 的 subtype这又引发了另一个问题：这和函数重载有什么区别？当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 `A`。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。如果要解决开头的问题，大概是以下三个思路：- 定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 `[name: string]: any`。- 考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。- 根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样```typescripttype Extend<T extends object> = {  [name: string]: any} & {  [K in keyof T]: T[K]}type A  = {a: string}type FuncA  = () => Extend<A>const f: FuncA = () => {  return { a: \"ok\", b:\"extra\"} } f().a // a is stringf().b // b is any```总之，在目前的 typescript 中，**返回值类型不能是泛型**。当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。---可能没用的参考：- [typescript - How to fix TS2322: \"could be instantiated with a different subtype of constraint 'object'\"? - Stack Overflow](https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint)- [Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript](https://github.com/microsoft/TypeScript/issues/50027)","description":"","keywords":"typescript, ts, generic type, ts2322，泛型约束","date":"2023-11-12 06:26"},{"id":"2023-10-09-the-little-prince-review.md","title":"重读《小王子》","content":"《小王子》在不同年龄阶段都看过，中译和原著也都读过，当时只是觉得有趣。但尝试自己写故事后，才惊觉其实所有的有趣都是是作者的刻意表达。仅仅以生活中的“有趣”与“想象力”写出的故事远远不够，别人看起来并没有你认为的那么有趣，内核是空洞的。人在成年人后，所经历的一切容易让笔下故事的发展陷入自身所见所闻，很难写出孩子般质朴的想象，无法逃离现实的束缚。举个例子，如果你的故事需要一个超现实的“天体引力”进行推动，你会用怎样的方式让这样的力产生？我搜集了很多宇宙的资料，试图从中找到什么想法。但事实上我并不是想写硬科幻，也没人想在简短的剧情中读一大堆物理考据。我对此一筹莫展，觉得怎样都编不出一个合理的解释……最后决定拉出上帝作为隐喻，上帝按自己心意去裁定天体引力。听起来很离谱吧，就好像是小孩子的瞎想，仅仅是“上帝裁定天体引力”不也是一具无意义空壳吗？但如果将这个设定赋予别的象征，就不再是无意义的。或者说，我其实是想象征什么，才拉出一个离谱的上帝。不过这个处理我也并不满意，但一时想不到更好的方法。幻想的意义不在于幻想本身，而是幻想对故事带来的推动。感到有趣的事在深入思考后也不仅是罕见、超现实的表象，它会带来的新体验，又或者：“喜剧的内核是悲剧”。今天复看《小王子》，试图从写故事的角度去理解，作者在下笔时是带着怎样的想法与心情呢？或是单纯是觉得有趣吗？怎么想出这些光怪陆离的可爱小故事？我是一个强逻辑性的Ne人，这样的思考也许能提高一下Ni的水平，带来一些不一样的启发。## 第1章介绍“我”与“大人”之间的区别。“我”在成为大人后 ，依然有着孩子般的心灵。如果不是这样，后文的“我”将是一个很难理解小王子的大人。体现这一点是“蛇吞象”与“帽子”的故事（作者真的很会想）。大人看东西只关注现实，不现实的事情对于大人毫无意义。## 第2-7章介绍小王子的由来。“我”困在沙漠中时遇到来自另一个星球的小王子，一个礼貌的、有点忧伤的小王子。小王子想要我画一只绵羊给他，但挑三拣四，最后对一只藏在箱子里看不见的小绵羊表示满意，还觉得小羊在箱子里睡着了。为什么想到在这里安排这么一只奇怪的绵羊，如果仅仅想有趣，那安排一只会走钢丝的山羊不行吗？读到最后才隐隐有了答案——美丽的事物往往是不被看见的，这也许是“箱子里的羊”的动机。第6章的写小王子星球上的猴面包树。从编剧的角度，不描写羊吃什么食物也无伤故事发展，但写了，还写的是特别具体也不常见的猴面包树，大概是有什么想法在里面的。猴面包树是会无限扩张的、不好的东西，但这和小王子的生活有什么关系呢，也就是多了一些并不让人开心的日常打扫。我不认为这里是象征自私的欲望、野心，小王子的星球上没有出现这类元素的必要性，含义也并不太深刻，在后续别的星球遇到更合理。后来看知乎上感觉有一个（我认为）挺靠谱的说法：> 作者发表时正值二战期间，作者是一名法国人，国土沦丧旅居纽约。旅居纽约的法国人又分成戴高乐派和维希派，他想劝告两派捐弃前嫌共同对敌，却遭到两派的夹攻，非常无奈，这三棵灌木正是代表法西斯的德国、意大利和日本。破坏这份宁静的、疯长的、夺取人生存空间的猴面包树。然后引出了对于小王子最重要的玫瑰花。作者是先想到绵羊再编出的玫瑰花，还是本来就想写玫瑰花与小王子的故事、再编出绵羊？如果以先写大纲让剧情先行的角度，我偏向于后者。无论以何种方式开始，绵羊和玫瑰花的情节是精妙契合的。情节的前后衔接一向不是一个简单的事情，如果先写剧情可能人物 ooc，如果先写人物可能会想不出后续，好多长篇就是这么坑掉的……这部分里还有一些别的情节，比如说谈到小王子的星球叫做行星 B612 时，讽刺了大人们喜欢以衣冠取人，关注外在与代号，不关注人的本质。小王子的星球上还有两座活火山一座死火山，非常有趣的脑洞，对剧情发展没什么用但并不觉得无聊，气质很符合小王子的星球（氛围渲染也是有必要的？）。小王子有一天最多看了43次日落，后文对不同星球的日落次数描写对比起来也非常有趣。至此基本表现出了小王子日常生活。## 第8-9章玫瑰花与小王子的相处这两章浪漫温柔，明显以人物情感先行，对话自然发生。剧情上没有太多刻意安排。有刻意安排的剧情是小王子最后一时冲动生了玫瑰花的气，离星出走。虽说是生气了，但看起来还是十分的文艺……整个文笔的基调就是这样的，very童话。## 第10-15章离星出走章节。不同星球上住着不同的奇怪大人，写得非常直白。后面有许多章节都会显得较为独立且直白，是娓娓道来的日常故事。第10章：有理性但放不下权威架子的大人。第11章：爱慕虚荣的大人。第12章：永远在犯同样错误的酒鬼。非常短，像四格漫画一样，但闭环的对白好有趣。第13章：除了钱和财产再脑子也容不下别的东西的商人。一些人看到什么东西就觉得是自己的，什么也不做就想据为己有，像是在讽刺资本主义的起源嗯……第14章：守规矩的、不知变通的打工人。观看一千多次日落这个吐槽也很有趣，像是人物先行写出来的。第15章：不出门的地理学家。看到好多模板的影子：不深入基层的高高在上的 leader、掉书袋不实践的人、把别人的成果据为己有的人、不切实际的甲方。地理学家知道地球，但连自己的星球上有没有大洋和火山都不知道，却觉得理所当然。## 第16-19章小王子来地球的见闻。第16章介绍地球。第17章小王子来到地球寻找人类，第一个遇见的毒蛇是为以后小王子回家埋下的伏笔（好残忍）。第18章向花问路的写作视角很有趣。以花的视角，人没有根，所以被风送走了。第19章的回声有点类似空镜的作用？我不理解，但隐约觉得好像是有用的，好可爱。## 第20-21章算是主线章节（？）很多玫瑰的花圃，小王子最初知道自己的玫瑰在外形上不是独一无二的后，很伤心。但小狐狸的出现又让他明白了> **正是因为小王子在玫瑰身上花费的时间，才使得玫瑰变得如此珍贵。因此单她一朵，就胜过了这世间所有。**此外小狐狸还教会了他仪式感。## 第22-23章永远在向往别处，行色匆匆，忽视脚下风景的人。永远在节省时间，追求效率的现代人。## 第24-25章沙漠里的井水，突出主题的两章，和星星上的玫瑰花一样。这个情节的设置和作者的自身经历有关，对于没有经历过的人而言难以复刻。> “沙漠美丽，因为沙漠的某处隐藏着一口井。”> “房子也好，星星、沙漠也好，美化他们的东西，是肉眼看不见的。”## 第26-27章小王子通过死亡回去了，“我”不舍。这两章人物先行，对白比较重要。总体感想是，这是一本给成年人读的童话。我清楚记得我小学时看到第一章，只觉得这是一个有点可爱的怪孩子。到高中时，可以感受到文笔有童话的美好，但并不太理解作者要表达什么。大学时看原著也没有懂，纯学英文去了。直到现在才对里面的情节有所体会。小王子的“童真”是人在成长过程中需要慢慢获得的，是成年人的反思，在小时候的记忆中类似的想法我从未存在过。小时候反而会现实得多，真正的小孩子有着更原始更本能的残酷。语文考试总是在问“作者在这一段想要表达什么”，小时候总觉得有时候是出题想太多。现在觉得，不是的，但也不应该有标准答案。刻意设计的剧作可以解释，很多人带着心情自然而然书写而成的东西，自己也是无法准确剖析的。剖析自己对每个人都是困难的，何况是一纸之隔的他人呢。","description":"","keywords":"小王子,世界名著,童话,读后感,书评","date":"2023-10-09 21:56"},{"id":"2023-09-26-minecraft-settings-for-v1-20.md","title":"Minecraft v1.20.1 常用设置","content":"在 Minecraft 1.20 版本光照引擎被大幅改写，使得帧数提升，模组的数量似乎又多了起来。另外在 fabric 发展起来以后，mod的社区生态有了很大的变化，有很多老牌模组有了更新的替代。现在记录一下实现常用的基本功能需要的模组与修改设置。我使用的 hmcl 启动器，在其中进行模组下载可显示模组间的依赖情况。以下内容在 1.20.1 中完全兼容，且项目均在维护中。## 1. ModsMC 是一款肝度明显过高的游戏。mod 的选用主要是为了：1. 使画面养眼2. 降低肝度，同时少引入额外的快捷键3. 优化细节使用体验使用以 fabric-api 构建的模组。### 1.1 渲染类- Sodium: 渲染优化之神，许多模组的前置- Sodium-extra: 渲染优化之神的扩展，相应 GUI 为reeses sodium options- Lithium: 原版机制的算法改进- Iris: Sodium 加光影- Custom Entity Models: 自定义实体模型，增强对 optifine 材质包的支持- Continuity: 无缝纹理，安装后需要启用相应的材质包。对第三方材质包支持一般，主要和 optifine 的格式还是不一样。- Indium: 许多模组的前置，提供 Fabric Rendering API的支持### 1.2 功能类- modmenu: 显示所有模组和相应的设置页面（如果有的话）- carpet: 单人生存必备，可使用命令放置假人以常加载区块刷红石- tweakeroo: 一系列微调的小功能。主要使用 freecamera（灵魂出窍）以获得更好的摄影视角，zoom 开启类似 optifine 的按 c 视角放大，handrestock 可自动补货手里的工具、方块- JourneyMap: 小地图，降肝度必备。Xae 的小地图也不错，两者都需要设置一下显示的东西，默认会非常多，我只开启了玩家、时间、坐标。关闭了网格显示和生物显示。- Invertory Profile Next: 高版本的 R 键背包整理（但被我改成 Z 键整理，R 键通常是 JEI 查看合成表）。自动补充工具、连续合成、捡物品时默认扔到背包中，以及在打开箱子时使用滚轮移动物品。关掉快破损时替换工具。- Carry on：手里没有东西时，`shift+右键` 搬运箱子，降低装饰的肝度。- JEI + EMI + 通用拼音搜索: 物品搜索，查看合成配方、查看方块用途，EMI 增加了**查看合成树**、切换可合成物品。合成树我觉得非常非常有用……- imblock: 输入法冲突修复- Panda's falling tree：砍树时树会倒下，降低砍树的肝度。- Leawind's Third Person: 更好的第三视角。这算是第一个可以日常使用的第三视角模组，挖方块瞄准都很方便。日常的垂直平滑 0.5 以上，不然爬山能晕死。- better combat: 动作战斗优化，攻速和攻击范围都有反馈了。- Litematica：投影。辅助红石机械建造，也算是一种降生存建筑的肝度。使用相当简单，一根木棍，control+滚动切换模式，快捷键进菜单。最难的其实是收集足够多的预置模型。但这个模组，要抢 Map 的 M 键……键位需要大改。- Hey Wiki: 在指向物品时按 h 键查询wiki。在物品越来越多的高版本具有一些引导作用。### 1.3 新物品- Gliders：类似塞尔达的滑翔伞，防摔。在空中按空格展开滑翔。使用方式和大部分游戏一致。只是要占一个盔甲位。动画做得很不错。- Waystones：传送石碑，后期物品，降低交通的肝度。如果用地图作弊路径点传送就不需要这个东西了，但理想的玩法还是地图只是用来看的，让传送石碑在地图上显示（需要前期多刷小黑），只能传送石碑处，禁止任意传送。传送石不是个好设计，MC背包不能放下更多东西了。除非有单纯扩容用的背包模组。- travelersbackpack：背包模组，终于有了 fabric 版。虽然 mojang 一直很谨慎地加入新的方块，但似乎从未考虑过方块越来越多时的背包使用问题。再者模组整合包也因为方块种类数爆炸的问题增加背包模组。在 1.12 版本时，背包容量是刚好够的。个人并不是很喜欢背包的设计。## 2. 设置- 画面尺寸: 1920*1080@60fps，窗口化- 视场角: 85- 鼠标灵敏度: 75- 模拟距离：8- 渲染距离：12### 2.1 快捷键修改总体的键位映射图如下。深绿色为原版的功能。橘色为Mod功能，蓝色为创造模式功能。键位分为直接按键、组合键、修饰键（长按）。MC 原版只能定义直接按键，组合键与修饰键在复杂的 mod 中用得多，并且会覆盖原版的直接按键。![KeyMaps](https://img-cf.sansui233.com/imgs/2025/03/202503240157178.webp)#### 游戏主界面首先把 ctrl 改到 capslock 键位，方便疾跑。系统全局 powertoys 改的（吐槽一万句control的键位）- 长按 `tab`，滚轮切换物品栏。在tweakroo 的「工具」中开启 hotbarscroll，再在 tweakroo  的「快捷键」中把 hotbarscroll 的快捷键设置为 Tab。 - `v`: 切换第三人称视角(visual)，很常用的功能。原本是f5，实在太远了- `f4`: Leawind's Third Person 第三人称视角相机调位置。同时关掉左右切换。点按左右，长按居中- `f5`:  灵魂出窍，在 tweakroo 的 freecamera 中设定- `c`: 望远镜，在 tweakroo 的 zoomactivate 中设定- `t`: 路标点传送管理(transport)。聊天改 `enter` 键- `x`: 锦致装饰-箭袋- `m`:  显示 jouneymap 大地图和设定。Journey map 的其他快捷键全关掉。- `n` Litematica 投影菜单- `h` Hey Wiki 查询指向的物品 Wiki- `shift+右键` 空手时搬运箱子，carry on 自带。特定工具下的修饰键：- 木棍工具  - `~`  Litematica 木棍工具修饰键，改变区域大小  - `n+space` Litematica 木棍工具模式5下放置投影预留键位：- `g` 圆盘菜单- `~`  特定工具修饰键，比如连锁挖矿- `b` 背包(backpack)- `j` FTB任务书(journal)- `左alt` 创造模式下，建筑模组 axiom 用 alt 切换专用物品栏。#### 合成台、箱子UI- r: REI 查看光标下物品的合成方式- u: REI 查看光标下物品的用途- ctrl + 左键点击REI的物品，移动物品到合成台- z: 一键整理。在 IPN 的设置中修改。- 使用滚轮以在背包和箱子间移动物品，按shift移动整组## 3. 光影- BSL v8.2.04，默认配置High，把 Camera 中的 Bloom 关闭，把 Atmosphere 中的 fog 调到 0，开启 lighting 中的handDynamicLight。抗锯齿的TAA随便开不开，取决于风扇响不响- Complementary Reimagined，配置 medium，high 会开启材质的反射运算量明显变大。夜晚也比较亮，适合生存。- itt 3.0，更适合搭配了写实系材质的建筑，风格最写实的 shader 没有之一。不适合生存。## 4. 材质- 任意矿物发光材质。比如 [New Glowing Ores](https://www.curseforge.com/minecraft/texture-packs/new-glowing-ores)。主要是因为 BSL 光影没有矿物发光，所以要加一个材质以确保有 fallback。- [彩虹像素](https://afdian.net/a/Nan2uu)，非常优秀的免费猛男材质包，原版风但更精致。有很多更可爱的附加包。## 5. 创造模式附加### 5.1 ModAxiom 高版本环境必备，可以创建实体方块随意拉伸模型，相当好用。effortLess structure 快速建造几何体。原 effortless buidling。lotweaks 自定义材质轮盘wordedit 经典创世神### 快捷键`tab`: effortLess structure 轮盘。`r`: lotweaks 轮盘，和手中方块有关。会禁用丢东西（但创造模式本来就不用丢东西除了篝火灭火，何不用 Axiom 的调试棒？）`左 alt`： Axiom 的大菜单","description":"","keywords":"Minecraft, fabric, 常用设置, mods","date":"2023-09-26 10:38"},{"id":"2023-08-30-windows-tweak-and-enhancement.md","title":"Windows 调整之基础功能与常用插件","content":"自从感觉内存硬盘越来越不够用，以及对老黄的显卡需求，从 mac 换成了多年不见的 windows11 。做了非常多的调整，至现在基本稳定，记录下来以供参考。## 基本调整与基础功能增强- **右键菜单**     使用 [shell](https://nilesoft.org/download)，恢复被藏到“更多选项”中的的右键菜单项，同时保持 win11 的设计风格。并且带有用 vscode 打开和用 windows Terminal 打开。虽然说 Windows Terminal 自己也有一个“用终端打开”，但那个有 Bug，打开的目录会被两个程序同时占用句柄，导致无法对目录本身进行操作。- **批量重命名**    使用 [Powertoys](https://learn.microsoft.com/en-us/windows/powertoys/) 中的 PowerRename，可选中多个文件后右键批量重命名，整理素材时太有用了。大致与 mac 的多文件重命名相同。缺点是不能改成 `同名称 + 编号` 。但系统自带的重命名恰好只能同名编号。Powertoys 有很多别的小工具，但都不够好用，按需关掉。- **快速预览**    使用 [QL-Win/QuickLook](https://github.com/QL-Win/QuickLook) ，选中文件后按空格直接预览，再按空格关闭。对于看各种后缀的文本文件、zip 压缩包目录结构非常有用。也用了 mac 后没法割舍的一个功能。前面说的 Powertoys 也有，但快捷键一定要加 ctrl（真的难按），功能更少，图片不能显示大小，无法定制。- **文件快速搜索**   使用 [Everything](https://www.voidtools.com/)，我大部分使用场景是在卸载程序后，清除残留的下载数据与用户数据。- **快速启动/全局搜索**   使用 Listary - **优化合集**   [hellzerg/optimizer](https://github.com/hellzerg/optimizer) 微调 windows 的合集程序，包括禁止系统更新、改 hosts 文件刷新 DNS、移除开机启动项、添加自定义右键菜单等。- **历史剪贴板**：在 `设置→系统→剪贴板` 中启用。- **屏幕颜色配置文件(ICC Profile)**    在 `设置→屏幕→显示配置文件` 中，换成对应屏幕的sRGB文件。否则对于广色域屏幕，某些不读 ICC Profile 的照片查看器会出现色彩过饱和的情况。- **输入法**   微软输入法需要改成回车时键入英文，否则会清空，不方便中英混输。不过作为一个五笔用户，我现在使用的是基于 Rime 的 [98五笔输入法](http://98wb.ysepan.com/) 和 [我的配置](https://github.com/Sansui233/98wubi)。~~因为微软输入法 shift 加 空格会标点变全角，而这个功能在中英混输时非常容易触发，还不能改掉，实在太弱智了~~- **关闭顶部自动布局**   关闭 `系统→多任务处理→贴靠窗口`。此功能乍一看非常贴心，实则非常容易阻碍鼠标精准排列窗口，尤其是想把上沿拉到顶部时。不建议使用鼠标时开启，更适合手指操控设备。- **多线程下载器**   使用 [aria2](https://aria2.github.io/)，在网上抄了一个配置文件，并且让 chatgpt 写了一个开机自启脚本。面板使用的是 Chrome 插件 [Aria2 Explorer](https://chrome.google.com/webstore/detail/mpkodccbngfoacfalldjimigbofkhgjn)，考虑到都是在浏览器中下载，没必要使用独立的客户端 App。- **与手机互传文件**（折腾但稳定版）    使用 [alist](https://github.com/alist-org/alist) 进行磁盘目录映射，并且使用 [DDNS-Go](https://github.com/jeessy2/ddns-go/wiki) 动态绑定本机的 ipv6 地址到公网。手机上将相应的 alist 页面添加到主屏幕，便可在该页面互传文件。好处是能走局域网，速度快，不同网络环境下可用，可远程传输等等。依然让 chatgpt 写脚本将两个程序加入开机启动。## 硬件调整- 硬件信息监测  使用[hwinfo](https://www.hwinfo.com/)的实时监测数据作为硬件调整的基准- 功耗/风扇转速调整  使用 [g-helper](https://github.com/seerge/g-helper) 调整日常使用的风扇曲线。我买的幻16，作为全能本，出厂的奥创调教特别垃，首发时还有bug。它的三种模式  1. 静音模式风扇完全不转，经常温度突然飙升很吵地转一会儿  2. 性能模式开什么都以游戏本的方式转，对我来说挺吵的  3. 增强模式的声音不是给人用的。    如果用windows默认电源管理方案的话，似乎和程序资源占用有关，即使只有60度也给转上4000转。打个小游戏真的不配这么吵……    后面用g-helper关闭睿频，功耗限制35w。测下来开原神默认高画质 1080p 稳定在CPU 65度，风扇3500转，不卡。这代 GPU 的散热反而问题不大，至少玩原神不会超过60度。然后测试了带光影的 Minecraft 1.20.1。MC 对 CPU 的要求更高，不过单机的话，不刻意刷红石，35w也够了，一般在25w左右，温度还是差不多的65度，全程电压没有超过1V，降压对于控温还是很有用的。奥创之所以动不动就吵就是因为一开性能模式，什么都不干电压给到1.8V……没必要，真的没必要。    日常使用场景下，好像也就编译比较耗CPU，其他时候都用不到很好的CPU性能。图形处理还是占GPU更多。音乐制作一类的也是耗CPU但也还好，但更耗内存硬盘。## 音频调整- **[Equalizer APO](https://sourceforge.net/projects/equalizerapo/files/)**    调全局声音的均衡，需要搭配 [Autoeq](https://github.com/jaakkopasanen/AutoEq) 仓库中说的 peace 插件使用（现在好像直接叫autoeq.app）。耳机发烧友的必备。注意蓝牙耳机无法使用卷积eq。- **内录用虚拟声卡：[VBCABLE_Driver](https://vb-audio.com/Cable/)**    网上有很多教程，为轻量级内录解决方案。另外如果系统带有 xbox，用 xbox 的录制视频是默认走的内录。- **降低 Midi 键盘延迟**    键盘连接电脑练琴，无独立声卡时，可用 [ASIO4ALL](https://asio4all.org/) 降低延迟。效果显著。缺点是 ASIO 是设备独占的，比如宿主软件使用 ASIO 到耳机，那看 b 站视频就只能外放（或者别的耳机/音响）。","description":"","keywords":"Windows工具, 软件推荐, Windows调整，Windows设置，插件","date":"2023-08-30 17:42"},{"id":"20230822-Super_resolution_models_and_tools.md","title":"图像超分辨率工具推荐","content":"~~推特~~，现在叫 X.com，是我的桌面壁纸来源，但是推特的图压缩得非常糊，喜欢的动画人基本也只传 1080p 图，导致壁纸糊上加糊。因此需要使用 AI 放大模型进行图像处理。\n\n- 放大效果外链预览：[Comparison](https://imgsli.com/MjAwMDcx)\n- 细节对比：  \n![](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/comparison.jpg)\n\n文章分为三个部分：\n\n- 图像处理工具\n- AI 图像放大模型\n- 如何使用\n\n## 图像处理工具\n\n### 1. [chaiNNer](https://github.com/chaiNNer-org/chaiNNer)\n\n一个无代码的图像处理自动化工具，可以实现批量改大小、调色、压缩、拼接等等等。同时也支持用 AI 对图像放大，也能接入 Stable Diffusion 的工作节点，上限非常高。缺点没有内置模板，即便是很小的功能（比如文件批量重命名）都需要自己创建。\n\n应用内置使用文档，不过不看文档也能一眼知道怎么用。\n\n**只有英文，没有中文。**\n\n- 传送门：[chaiNNer](https://chainner.app/)\n\n### 2. [imagestool](https://imagestool.com/zh_CN/)\n\n对于单张图和 gif 的常见处理小工具合集，网页打开即用，完全本地运行无隐私问题。特点是非常易用，支持小批量处理，支持 pipline，也就是说如果想在调整大小后转换格式再压缩，不需要每一步都上传下载图片，可以处理完每一步直接选下一步，只下载最终的处理结果。\n\n- 传送门：[imagestool](https://imagestool.com/zh_CN/)\n\n## AI 图像放大模型\n\n超分辨率成像(Super-Resolution，简称 SR) 是一种提高图像分辨率的技术，通俗的叫法就是图像放大。如果你曾经使用过 Photoshop 对小图进行放大，会发现放大后的边缘总是非常模糊，并且用锐化等操作无法弥补，这是传统方法的在图像放大上的缺陷。\n\n但是神经网络（Neural Networks，简称NN）的出现对图像放大的效果带来了极大的提升，几年前就已经有不少 AI 图像放大的应用，但最近两年的模型效果尤其好。下面介绍几个现阶段应用上比较火的模型。\n\n### 1. [SwinIR](https://github.com/JingyunLiang/SwinIR)\n\n2021年基于 Transformer 的图像超分辨率模型，放大任何图片的效果都非常好。风格偏锐利且干净，且参数少，处理速度快。此模型分为 3 类，经典图像超分辨率（Classical image SR）、轻量级图像超分辨率（Lightweight image SR）、真实世界图像超分辨率（Real-world image SR）。\n\n- 下载链接： [Release  · JingyunLiang/SwinIR](https://github.com/JingyunLiang/SwinIR/releases/tag/v0.0)\n\n可下载的版本很多，不知道选哪个的就选 [001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth](https://github.com/JingyunLiang/SwinIR/releases/download/v0.0/001_classicalSR_DIV2K_s48w8_SwinIR-M_x4.pth) ，这个为4倍放大的模型，也是 Stable Diffusion 的 SwinIR 预置模型。\n\n### 2. [Real-ESRGAN](https://github.com/xinntao/Real-ESRGAN)\n\n2021年的经典图像超分辨率模型，这论文出来后大家疯狂在它基础上卷，基于 ESRGAN 改进的模型和论文非常非常多。不过最初的版本也已经足够好用。\n\n下载链接：[Releases · xinntao/Real-ESRGAN](https://github.com/xinntao/Real-ESRGAN/releases)\n\n依旧版本很多，不知道下哪个的下载 [RealESRNet_x4plus.pth](https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.1/RealESRNet_x4plus.pth) 即可。\n\n### 3. 4x-AnimeSharp\n\n基于 ESRGAN 架构的动漫类放大，~~可能由于训练集选得好~~，在众多动漫类放大中它可以很好地处理景深，其他的Anime模型多少在景深部分会有一些清晰过度的问题，包括著名的 [RealESRGAN 动漫模型](https://github.com/xinntao/Real-ESRGAN/releases/download/v0.2.2.4/RealESRGAN_x4plus_anime_6B.pth)\n\n- 下载链接：[AnimeSharp - OpenModelDB](https://openmodeldb.info/models/4x-AnimeSharp)\n\n OpenModelDB.info 上有更多的微调模型，可以试试。总体来说，AI 放大的图像质量目前来说还是乍一看可以，涉及商用美术的话质量仍然不过关。~~如果商用美术能过关，岂不是能画糊图然后丢AI出高精图了。~~ 作为壁纸放大非常合适，即便是补充的细节不能推敲，但把像素精度补齐到屏幕分辨率带来的视觉提升也是非常大的。4k 壁纸就是比 1080p 看起来舒服。\n\n## 如何使用\n\n使用 chaiNNer 时可照抄下图结构，使用 4x-AnimeSharp 模型放大原图、重命名图片并保存。\n\n![chaiNNer](https://cdn.jsdelivr.net/gh/NamiLing/upic/picgo/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-22%20213633.jpg)\n\n如果使用的是 [stable-diffusion-webui](https://github.com/AUTOMATIC1111/stable-diffusion-webui) ，Extra Network 选项卡中也有预置模型，可以使用 SwinIR 和 ESRGAN。\n\n---\n\n可能有用的资料：\n\n- [4x-AnimeSharp](https://openmodeldb.info/models/4x-AnimeSharp)\n- [Interactive Visual Comparison of Upscaling Models](https://phhofm.github.io/upscale/)\n\n---\n\nPS：强烈建议无代码应用都开发个 template market……不要做一堆功能摆那里就自由发挥了啊诶！当发现要什么工作流很难做时就会感知到这些无代码 App 的问题所在了……在实际应用场景中很烂！很难做！说的就是comfyui……","description":"AI图像放大模型+工具推荐","keywords":"AI，图像处理，图像放大，超分辨率，CV, SR","date":"2023-08-23 06:20"},{"id":"2023-02-20-stable-diffusion-AI-experience.md","title":"Stable Diffusion AI 绘画的实用经验与总结","content":"2023-03-03：待大量补充和修订。\n\n------\n\n进阶经验，非科普。分为五个部分：模型选择，分辨率调整，采样方法，ControlNet，Lora概述。\n\n此文章涉及多平台发布，由于生成类 AI 的争议，文中无外链推荐。\n\n## 一、模型选择\n\n模型影响构图和笔触和色彩，决定成图的平均水平。社区经常都在换流行的模型，还是根据需求定，huggingface 和 civitai 上很多。\n\n二次元目前主流三家 Anything Orange Counterfeit 。\n\n目前有不少混合了 2D 和 3D 的 2.5D 模型，用来出 cos 的，个人不喜欢。\n\n下图模型为 pastel-mix，图片画质已严重压缩（看不见则需要开代理，如果你用的 Innoreader 手机版阅读此文，大概率被放头图了）\n\n![pastel-mix](https://cdn.jsdelivr.net/gh/NamiLing/upic/uPic/00153-2596022983-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20sun%20shine,water,%20on%20back,%20lying%20in%20wa.jpg)\n\n### 模型精度选择\n\nfp-16(2G)，fp-32(4G)，full(7G) 用于生产没有肉眼可见的区别。full 主要是训练用的。fp16 生产够用了，快，占用小。\n\nbf-16(2G) 相对 fp-16 会损失一小部分细节，不推荐，会发布 bf-16 版本的模型也较少。\n\n### VAE权重网络\n\n影响色彩，主观效果是增加饱和度（比修图软件饱和度增强好太多）。目前流行的 VAE 就两个，一个 Waifu 的一个 Anything 的，很多带 vae 模型都是用的这两个改了个名字。\n\n下图为 mix-pro-v3-fp16 模型，叠加了其配套的 WD vae 的 效果。\n\n![Mix-pro-v3](https://cdn.jsdelivr.net/gh/NamiLing/upic/uPic/00045-311454338-Original%20Characters,%201boy,%20sea%20shore,%20%20pastel-full.jpg)\n\n### Prompt\n\nprompt（提示词）是玄学范围。不同模型的 prompt 词库不一，目前主流的词库有两个\n\n- 适用 SD v1.x 及其衍生模型的 lexica\n- 适用二次元模型的 Danbooru。\n\n对于二次元模型，Prompt 指定物体，调整动作、指定颜色比较容易。取决于模型的泛化能力。\n\nPrompt 难以精确控制画风，所以尽管上限非常高，但主流越来越不倾向于用大量 Prompt 叠 buf，转成微调模型以达成精确需求。\n\n在两个月前关于 Prompt 研究的文档就已经非常多了，这里不做推荐，因为不看文档，直接翻译成英文大概率是有效的。\n\n### 文生图与图生图\n\n文生图与图生图本质上没有什么不同，文生图只是将图片输入换成了一张随机的噪声图。\n\n## 二、分辨率\n\n不同模型在生成时有最佳的分辨率，大部分都在 512px 左右，不超过 1024px。\n\n提高分辨率不仅是单纯放大图片，AI 能够用模型细化图片。\n\n### 图生图\n\nimg2img(图生图) 大部分时候被用来衍生，但是其效果最好的是将 txt2img 的低分辨率图放大（用同一个seed）。\n\n在 web-ui 中，仅缩放(just-resize)为无 AI 的放大算法处理。 AI 放大使用的 Latent 方法即将被归入 Upscaler，也就是下面说的 Hires fix。\n\n### Hires fix\n\nHires fix（高清修复）的作用是用 AI 从小图生成高分辨率图，处理用得好可以提高大幅提高图片上限。upscaler（放大器）可选几种放大方法，其中的 Latent 就是 SD 的画图方法，文生图与图生图均是这个方法。\n\n在 web-ui 中， 默认只有 txt2img 可用，因为 img2img 本身就可以做图片放大。另外，有专门的 upscaler 选项卡。\n\n使用 Latent upscaler (图生图) 放大到高分辨率图涉及局部重绘，部分模型支持较好，如 Pastel。但在 512 px 完成度就很高的模型上通常没有效果，或者更差（比如炫彩厚涂），这种用 GAN 类 Upscaler 直接放大比较好。\n\n值得注意的是 web-ui 的 Hires fix 有两版算法，目前 txt2img 是新版， img2img是旧版，效果有一些小差别，很难比较好坏。\n\n## 三、采样方法\n\nSampler（采样方法） 决定笔触和结构的稳定性。常用的有：\n\n- Euler a 是一个规整稳定的采样方法，出的图较平滑\n- DDIM 是一个过程不算稳定的采样方法，通常看起来比 Euler a 细节更多\n- DPM++ 2M Karas，最近在用的，过程稳定但有细节\n\n有部分 Sampler 对高分辨率（1024px 以上）支持不好。\n\n## 四、 ControlNet\n\nControlNet 目前是一个需要额外安装的插件，可以用于给线稿上色并细化，或从草图细化。\n\n你的草图可以决定的是：\n\n- 60%-100% 的线条位置（构图）\n- 主要色块位置。需要搭配图生图，并且色块越碎越好，需要提前做好整体的光影效果。因为 大部分 AI 只会画整，会画碎的比较少（Pastel 会画碎）。\n\n细化风格（画风）由模型决定，不由你的草稿决定。模型风格对于画风影响非常关键。Prompt 也可以影响画风。\n\n细化内容（画的具体是什么）由 Prompt 、草稿、模型共同决定，调整 CFG、Denoise 、 ControlNet 的 Weight 可改变三者比例。\n\n下图为自己的较草的线稿使用 ControlNet 与 Anything V3.0 上色：\n\n![Control-Net](https://cdn.jsdelivr.net/gh/NamiLing/upic/uPic/00275-3225619170-masterpiece,%20best%20quality,%20illustration,face,%20right%20hand,%20atomespheric,%20cold,%20sunshine,%20sky,,%20high%20detail,%20flowers%20and%20leafs.jpg)\n\n（这个东西出名是因为某博说 ControlNet 初衷是洗稿……之前 Pixiv 也出过线稿上色的 AI，只是效果好和不好的差别，怎么没人说是搭配 PS 的线稿提取功能洗稿）\n\n## 五、Lora\n\nLora 是一种训练小模型的方法，可以在 15 张图以上生成稳定的单个角色图。\n\n已有大量角色图积累的流水线漫画苦力会比较省事，搭配 ControlNet 可生成固定姿势，或者使用线稿稳定地上色。但对于连续动作的细微差别不太行，细节演出表现依旧需要依赖线稿，或手动重绘\n\n训练过程分为裁剪、自动打标、训练，最终生成约 100M 左右的 Lora 网络。Web-ui 已自带。\n\n## 写在后面\n\n风格迁移渐渐成熟了，过拟合的问题在逐渐减少。减少过拟合的最终解决思路，还是把端到端的网络，按需求拆成了人为可控的 pipline。个人认为 AI 如果真的要作为工具，模块化的 pipline 是终点。\n\n直接出成图的是对已有作品的模拟，抽抽卡，融入不到创意的工作流。\n\n但是在发展好之前，地球可能已经枯竭了。\n\n![pastel-mix](https://cdn.jsdelivr.net/gh/NamiLing/upic/uPic/00162-1748765688-masterpiece,%20best%20quality,%20ultra-detailed,%20illustration,%201boy,%20Link%20in%20Breath%20of%20the%20wild,%20stronde%20hair,%20sun%20shine,water,%20emotio.jpg)","description":"AI 画画现状","keywords":"AI绘画, stable-diffusion, AI绘图, AI画画","date":"2023-02-21 08:00"}]