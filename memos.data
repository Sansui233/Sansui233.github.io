[{"_1":2},"routes/memos",{"_3":4},"data",{"_5":6,"_96":97,"_10":104,"_170":171},"memos",[7,24,32,41,49,57,65,72,80,88],{"_8":9,"_10":11,"_13":14,"_15":16,"_17":18,"_20":21,"_22":23},"id","2026-01-24 02:47:21","tags",[12],"分享","imgs_md",[],"sourceFile","","csrIndex",[19,19],0,"word_count",12,"content_jsx","\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"3D\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=gdOaUv0_TC8\",\n          children: \"Blender Bones For Beginners - EASY - YouTube\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":25,"_10":26,"_13":27,"_15":16,"_17":28,"_20":30,"_22":31},"2026-01-19 21:09:44",[12],[],[19,29],1,444,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"技术\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://cacm.acm.org/blogcacm/two-concepts-of-intelligence/\",\n            children: \"智能的两种概念 – Communications of the ACM\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"我觉得可以折中一下，是在无相关经验情况下给出正确答案能力，既有了明确指标也避免了“归纳式智能”。这在现实世界是很确定的出题方式了吧，IQ 测试题都是被设计为无需先验知识的，不会有语言题，你甚至可以给猩猩做。看看图像模型看这么多图后，能不能补全呀哈哈的最后一颗石头就行了。我觉得 AI 是可以有逻辑的，要是有合适的无监督聚类算法，训练了说不定真的可以完成这种任务。但是没有这种无监督随便迁移领域的聚类算法，现在说的无监督实际是自动生成标注/不需要额外人力标注的有监督。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"对于情商我自己定义为，“在自我有相关经验情况下，能给出被社会接纳的答案，并强烈遵守此答案” 的能力。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"刚问了 GPT 下面这个问题，嗯，一塌糊涂。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://austinhenley.com/blog/ladybugclock.html\",\n            children: \"一个随机游走问题\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"结论应该是这样的：每个数字上的停留概率是一样的，这是一个理论上稳态分布 stationary distribution，有限次数内只能逼近无法到达的完美分布。如果限定到在有限次数内完成遍历，在 1 和 11 停留的概率是最大的，停留在 6 的概率是最小的。或者说，在 6 停留的平均步数要比其他的数字长，停留在 6 的 step 比 停留在 1 上的步数上要多个十几次，这已经超过了一圈的距离。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":33,"_10":34,"_13":36,"_15":16,"_17":37,"_20":39,"_22":40},"2026-01-18 18:05:29",[35],"TODO",[],[19,38],2,207,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"感觉 rust 的出现一统 shell 体验的天下……尤其是 windows 版本的。没有 rust 就不会出现 starship zoxide eza 这些东西，跨平台还要用到系统库 c++ 够得受了。如果 tree-sitter 生在现在就不会有各种 libc 的破事了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外就是小模型的浏览器 C 端运行…… onnx 还真是可以试一下，小工具狂魔又有玩的了。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/microsoft/onnxruntime-web-demo\",\n          children: \"onnxruntime demo\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/vietanhdev/samexporter\",\n          children: \"SAMexporter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/Xenova/whisper-web\",\n          children: \"Whisper Web - a Hugging Face Space by Xenova\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/webml-community/YOLO26-WebGPU\",\n          children: \"YOLO26 WebGPU - a Hugging Face Space by webml-community\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我觉得超分辨率模型还挺适合做这个的。列入 \", _jsx(Tag, {\n        text: \"TODO\",\n        children: \"#TODO\"\n      }), \" 吧。还有抠图，真的没有做纯客户端的抠图吗全都去服务器排队…… seg 模型 CPU 算个几秒也是完全可以接受的啊。哦对，这倒是有商业模式的问题。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":42,"_10":43,"_13":44,"_15":16,"_17":45,"_20":47,"_22":48},"2026-01-16 21:50:19",[],[],[19,46],3,30,"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"看了下 zed 的 \", _jsx(_components.a, {\n      href: \"https://www.gpui.rs/\",\n      children: \"gui 库\"\n    }), \"，wow，DOM 之青春版，蛮喜欢的。zed 团队的复刻轮子能力是真的强。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":50,"_10":51,"_13":52,"_15":16,"_17":53,"_20":55,"_22":56},"2026-01-16 16:05:27",[],[],[19,54],4,179,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    hr: \"hr\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"域名搬到 porkbun 了。namecheap 直接涨到 25刀了。本来想说迁移到 CF 算了，结果 Cloudflare 的 transfer  系统错误一次后就此卡住了。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"给了 vscode 编辑器一个 vim emulator。很早之前有用过但是实在是用不习惯。现在我觉得驯化程度比以前高一点了所以再试下。vim normal mode 可以解决快捷键不够用的问题，像是侧栏图标是很难按的，但给的快捷键实在不是人，三键起步还是最不好按的 ctrl + shift 组合。但我觉得 emulator 的响应速度有点慢，特别是保存文件时，调用的 vscode api 但要卡一秒， 不知道为什么。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":58,"_10":59,"_13":60,"_15":16,"_17":61,"_20":63,"_22":64},"2026-01-16 12:59:13",[],[],[19,62],5,142,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    hr: \"hr\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"……………………………………………………\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"现在来看 Rust 觉得设计得确实很好……最开始看时是有点天书的对有的规则比较死记硬背。即便真的会给你讲为什么这么设计，但并不能十分理解。准确地说，理解这个事情本身也要需要记住，需要熟练度的……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有人总觉得人到什么年纪理所当然应该懂得什么道理，但世界上没有那么多理所当然的事情，只是都懒得容忍不符合自己预期的人。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":66,"_10":67,"_13":68,"_15":16,"_17":69,"_20":47,"_22":71},"2026-01-15 15:48:35",[],[],[19,70],6,"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"Gemini Pro 竟然是能用国内发行的 visa 卡订阅的，甚至用的无额度的工行星座卡。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":73,"_10":74,"_13":75,"_15":16,"_17":76,"_20":78,"_22":79},"2026-01-14 17:32:36",[],[],[19,77],7,830,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    blockquote: \"blockquote\",\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"暴论之：如果 Rag 真的能变好用，能检索知识库到最相关的知识的而没有那么多噪声，建议去开个公司起个昵称 RAGoogle，口号是就划时代的谷歌。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"好像也不是第一次吐槽了，上一个这么吐槽的还是无代码。还觉得是个方向问题，并不 AI，更像是现在的工程。RAG 不够“AI”、效果不好的根源是检索时没有对 Prompt 的文本理解，只是把之前相关性排序的方式用机器学习又做了一遍，这个就是传统的数据分析，一直以来都算是脏活。搜索引擎的结果就没用过机器学习吗？巨硬广告营销部门搞算法的他们现在工作是在干什么？算法的准确性离开了人们的点击率驻留时长效果还能好的吗？要有好的结果必须要在排序文本相关性时理解人类的偏好，哪怕是推理出的偏好。大模型的长上下文有用正是胜在了对人类的输入与参考资料的相关性有一个推理的过程，如果拿一大串完全无关资料给大模型，大模型会告诉你引用似乎看起来没有关系，答案的正确性并不会受太多影响。但你在 User Query 后面说点废话（知识库包含的主题）看看 RAG 的 embedding 计算会不会检索出没用的资料？包的。同时可以试试谷歌，会不会在 \", _jsx(_components.code, {\n        children: \"bash 的配置方法 RAG 2025年的应用\"\n      }), \" 这种关键词里，真的在第一页搜出 bash 的配置的方法。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"真正的 AI 时代完全没有来临，因为市场结构完全没有因其变化。上世纪的那场泡沫用了7年破灭，如果到5年后还没有什么能用上的地方，嗯。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"我是感觉最终形态可能会是仿生生物的记忆储存方式，类似于一个虚拟大脑的结构，知识做了一些提取（但是同时有标记知识点的出处）处理，如果是知识点的调用，直接从虚拟大脑取到记忆即可，如果是想获取详细的原文，就通过出处去寻找原文，给出原文的详细内容。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"确实不如去做 summary（不一定是人类可读的形式 ColBERT 那种表征也行）。相关性排序（reranker）功能目前只能给大模型做，很难参数量小，没办法事实证明了产生够用的语言逻辑就得要这么大的模型，但问题是 rerank 前 retrieval 的部分效果，从 User Query 到召回这部分就还是纯数学的，问题不是出在 rerank 上。都到这个地步了又会想，不如大模型一把梭了得了，真到给人用的时候，又没有条件去做实时的 embedding FT，再小不也得几十 G 的 显存也没法说 1 分钟内训练完成。可以说 embedding 模型不下放到每个知识库去 fine-tune 都是没有意义的，即便下放了，也会面临缺乏对应知识库 QA 数据的问题，这就是个死路。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":81,"_10":82,"_13":83,"_15":16,"_17":84,"_20":86,"_22":87},"2026-01-12 16:27:54",[],[],[19,85],8,395,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"看了看 practical vim，感想是果然用不来。心智负担很重的。很多为了简化操作而进行的步骤，是因为当时没有直觉性的鼠标定位和编辑器不够智能才需要学。有里面提到，“程序员大部分时候在思考而不是写代码，所以默认为普通模式”。所以不思考的时候，用鼠标/触摸板滚动和浏览不是更好吗？主要就是大滚动后的定位，这个键盘怎么做都没可能比鼠标和触摸板好的。我个人觉得触摸板更适合这个任务，因为手的位置不用变化，真正的补齐了全键盘流最不方便的地方。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"批量编辑在 vim 中被拆解成了编辑一次、多次重复“定位与编辑”。但现代编辑器的替换工具都内置了，双击后 \", _jsx(_components.code, {\n        children: \"C-h\"\n      }), \" 再一路 \", _jsx(_components.code, {\n        children: \"enter\"\n      }), \" 下去，不需要换的 \", _jsx(_components.code, {\n        children: \"f3\"\n      }), \" 跳过。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但读这个还是有好处的，明白了给 vscode 安装 vim 插件到底是为了解决什么问题——分散的键位（由其 fn 系列）和频繁用小拇指。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"对于鼠标流，可以双击进入 view ，配合上的 smart expand 或者 \", _jsx(_components.code, {\n        children: \"af\"\n      }), \"，text object 的精准选择是可以更快的，然后再进行操作。对于 vscode，我觉得 view mode 比较重要一点，因为可视化软件都是先选中对象再操作的逻辑，这和 view mode 很像。先操作再选择怎么都不太能适应。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":89,"_10":90,"_13":91,"_15":16,"_17":92,"_20":94,"_22":95},"2026-01-11 06:42:02",[12],[],[19,93],9,597,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"综艺/生活\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://www.bilibili.com/video/BV1tfiFBzEhD\",\n            children: \"あざとくて何が悪いの？有点心机又如何\"\n          }), \" - bilibili 5的人的爱情，突然刷到看了起来……\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://www.bilibili.com/video/BV1tfiFBzEhD\",\n            children: \"一个韩国旅游博主的成都丽江之旅\"\n          }), \" 这位是真的会拍会剪的。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"看了一下有人在说虾皮的技术更新网页文档，全是滑动交互，感觉是用 three.js 塞了很多3D模型，确实好看。不过说由此说什么等领导审美觉醒不觉醒就不必了，真的想要自己的页面3s打不开吗，打开了第一页啥信息也看不出吗。特如果是做中文设计，要用系统字体以外的字体，可能就不是三秒的问题了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我有很喜欢的设计师的个站，但对设计师自己做的交互丰富的站有三个很刻板的印象。1是太卡了，用 JS 动画 CPU 爆炸，用 WebGL则是没有 GPU 时 CPU 爆炸，2是响应式容易不注意有一堆问题。其实还有一个是，3是信息密度太低看个什么都要划很多下，看不到重点的信息。有人会觉得硬件过剩，并没有，什么时候办公本都能做 AE 不卡了再来说硬件过剩，什么时候讨厌 Electron 教会解散了再来说硬盘和内存够用。设计是一个会用 10 倍资源去为了实现那 1 倍视觉效果的，就像剪辑里的动画一样，但设计师可不会只想要 1 倍效果，会想要 10 倍。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最实用且有效率的方式就是，画图，图片排版，做印象效果视差等等也够了。但图片的问题是依旧得拿字体去配图像风格，到中文这边，字体又是一个巨大的坑，一个字体能放一百张图。所以最好是图像的风格也是现代的无衬线字体换个颜色就能配上了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有设计感的站通常带有强烈的表达倾向，以至于字体语言配图全都是为表达服务的。体验是这样的效果非常酷，但也就意味着不可复用。我觉得把信息量和交互动效平衡做得很好的还算是 flatstudio.jp。他们用得很克制了。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","info",{"_5":98,"_10":99,"_100":101,"_102":103},311,11,"imgs",21,"pages",32,[105,115,117,123,133,143,147,152,159,163,167],{"_106":12,"_107":108},"name","memoIds",[9,25,89,109,110,111,112,113,114],"2026-01-09 03:25:00","2025-12-28 02:41:52","2025-12-15 10:53:00","2025-11-20 00:00:01","2025-11-16 05:39:33","2025-07-25 00:48:53",{"_106":35,"_107":116},[33],{"_106":118,"_107":119},"react",[120,121,122],"2026-01-08 14:14:49","2026-01-04 20:32:00","2023-11-08 01:30:55",{"_106":124,"_107":125},"博客",[126,127,128,129,130,131,132],"2026-01-04 03:34:48","2024-10-16 18:36:24","2024-08-23 08:18:14","2023-11-06 21:20:06","2023-11-05 21:04:56","2023-10-29 01:13:43","1980-01-01 00:48:28",{"_106":134,"_107":135},"工具",[136,137,138,139,140,141,142],"2025-12-18 02:58:11","2024-02-18 01:19:32","2023-12-27 18:09:43","2023-11-29 03:12:05","2023-11-21 00:57:14","2023-11-02 22:20:54","2023-08-30",{"_106":144,"_107":145},"字体",[146],"2025-07-31 02:40:38",{"_106":148,"_107":149},"游戏",[150,151],"2025-01-05 00:51:17","2024-12-08 00:12:16",{"_106":153,"_107":154},"沉思",[155,156,157,158],"2024-02-28 17:24:54","2024-02-22 15:36:59","2024-02-13 16:01:25","2024-02-09 00:34:23",{"_106":160,"_107":161},"书",[162],"2024-02-16 00:17:38",{"_106":164,"_107":165},"故事",[166],"2023-12-10 06:42:56",{"_106":168,"_107":169},"漫画",[129],"source","SSG"]
