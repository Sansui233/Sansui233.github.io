[{"_1":2},"routes/memos",{"_3":4},"data",{"_5":6,"_97":98,"_10":105,"_168":169},"memos",[7,24,32,40,48,56,65,73,81,89],{"_8":9,"_10":11,"_13":14,"_15":16,"_17":18,"_20":21,"_22":23},"id","2026-01-08 14:14:49","tags",[12],"react","imgs_md",[],"sourceFile","","csrIndex",[19,19],0,"word_count",387,"content_jsx","\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"回看 next mdx remote 的实现，当时我是着实不知道是为什么要分 rsc 和非 rsc。我知道 rsc 是服务端渲染的，但难道非 rsc compile 出来的组件就不能服务端渲染了吗。因为我看了下两个组件反序列化的过程可以说是一模一样一致，都是在客户端水合一下。唯一的区别就是非 rsc 把 mdx.js 暴露的全部组件都传了进去，\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-typescript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Compile Options\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providerImportSource\"\n        }), \": rsc ? \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@mdx-js/react'\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 对应 MDXRemote index 里的 \"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" mdx \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@mdx-js/react'\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 因为反序列化后的函数字符串可能会调用到 mdx-js 的内容，也就是 useMDXComponent，RSC 不支持，所以序列化前必须指明编译参数。\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也就是rsc 的组件实现是 mdx-js 是零依赖的。所以到底有什么必要在非 RSC 里的组件里把 mdx.js 所有的组件都传进去呢。主要就是是否注入 mdx-js 库里的 \", _jsx(_components.code, {\n        children: \"useMDXComponent\"\n      }), \"的调用。但不编译能有什么影响呢\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"问了 Gemini，他是这么说的：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"// 纯 Props 模式，每次用都要传，累死人\\n<MDXContent components={{ YouTube, Tweet, Chart, ... }} />\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"看了一眼 \", _jsx(_components.a, {\n        href: \"https://mdxjs.com/docs/using-mdx/#mdx-provider\",\n        children: \"MDXProvider\"\n      }), \"……其实开头就说得很清楚了：\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"You probably don’t need a provider. Passing components is typically  fine. Providers often only add extra weight.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"意思就是没需求别用……所以这种小东西自己写库就可以了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"给 markdown 自定义语法和渲染，其实就是需要两部分\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"remark 插件（rehype 也行 但我觉得 remark 更简单）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"component 渲染替换\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(Tag, {\n        text: \"react\",\n        children: \"#react\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":25,"_10":26,"_13":27,"_15":16,"_17":28,"_20":30,"_22":31},"2026-01-07 10:26:00",[],[],[19,29],1,137,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"看到一些说搞 AI 人的科普贴子，一看是部署的不是算法的，感觉有点无奈。学NLP在NLP最火的时候不搞NLP，论文不想写也就算了跟风搞应用也不想搞还能把自己饿死，跟有病一样。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后那种精神上想吐感并没有消失，我知道怎么解决但解决不了。不过远离对象一种烦躁的感觉消失了。什么他人即地狱（原意，不是其他人都是恶魔那个意思）。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":33,"_10":34,"_13":35,"_15":16,"_17":36,"_20":38,"_22":39},"2026-01-06 23:15:00",[],[],[19,37],2,32,"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"呕……好想吐，很难说是精神原因还是生理原因。我觉得有点偏向于精神上想吐。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":41,"_10":42,"_13":43,"_15":16,"_17":44,"_20":46,"_22":47},"2026-01-06 04:10:28",[],[],[19,45],3,71,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"草，有瓜\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"\",\n          children: \"这是一篇号商无能狂怒的聚集地：This is a gathering place for the incompetence and rage of a number merchant\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"全被删了。有贴子看了一眼风格\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"总结：\", _jsx(_components.a, {\n            href: \"https://linux.do/t/topic/1408515\",\n            children: \"https://linux.do/t/topic/1408515\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"贴子风格：\", _jsx(_components.a, {\n            href: \"https://x.com/flyiiawei/status/2008124574379212830\",\n            children: \"https://x.com/flyiiawei/status/2008124574379212830\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://linux.do/t/topic/1408358\",\n            children: \"https://linux.do/t/topic/1408358\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"怎么传播广的不是骂人就是黄段子……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":49,"_10":50,"_13":51,"_15":16,"_17":52,"_20":54,"_22":55},"2026-01-04 20:32:00",[12],[],[19,53],4,985,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    code: \"code\",\n    h3: \"h3\",\n    hr: \"hr\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"react\",\n        children: \"#react\"\n      }), \" 一个没有预料到的状态管理问题：如果组件层级 A>B>C，A负责获取数据源，C负责渲染。那 State 缓存数据不要给到 B。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为什么？因为 C 同时应用 A 的更新数据和 B 的缓存数据时，B的缓存数据更新会慢一拍，因为B需要去订阅A的更新再通知C更新 props（useEffect 是异步的）。如果 C 中有 state 的初始化依赖缓存数据，那这个初始化也会慢一拍。导致渲染结果（随着缓存更新）和 C_state（只随初始化更新）不一致。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可能会想，那 C_state 也去订阅 B 缓存就好了？不行，订阅 B 缓存，C_state 更新也还是比渲染慢一拍。此时如果渲染会更新 C_state，那就和对于 B 的订阅冲突了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"使用缓存是副作用，谨慎处理副作用。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"为什么有这么奇葩的结构……因为A和C都是库啊！！只能存到B。好消息是C库自己实现的，改成C库自己存数据，有数据更新后通知B了。但要是真只能写B，C不存数据，那 C 的 props\", _jsx(_components.strong, {\n        children: \"需要全部用同步更新的缓存\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"这其实提到了一个叫派生状态，知乎上有说，但最终也没提出来解决办法。派生状态至今没有检测。 \", _jsx(_components.a, {\n        href: \"https://zhuanlan.zhihu.com/p/349372515\",\n        children: \"https://zhuanlan.zhihu.com/p/349372515\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这是我使用 react-router clientLoader 最大的坑。非常容易遇到反模式。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h3, {\n      children: \"Lazy import 组件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"好好了解一下 Lazy 的概念，看 SSG 这种重 SEO 场景首屏能不能用。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先是要明白，Lazy 导入的组件必须被 Suspense 包裹，不然会 Throw 一个异常向上报错直到遇到了 Suspense 组件进行一个 fallback。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其次是分情况\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"函数 await import，以 show State 加载 -> 无首屏，不显示在Dom\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Lazy import，以 show State 加载 Suspense -> 无首屏，不显示在Dom，用 Lazy 属于多此一举。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Lazy import ，以 Suspense 加载 -> 大致能用（Dom 能显示，有短时间不可交互，直到浏览器自动下载完代码分割）\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"仅以 Suspense 加载 -> 能用（Dom能显示，显示就能交互，没有代码分割）（RSC核心）\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"对于以上第三个点，“大致能用”是有个坑\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"如果 JS 加载慢，React 在客户端运行时发现代码没到，它可能会判定为“未准备好”，于是\", _jsx(_components.strong, {\n          children: \"扔掉\"\n        }), \"服务端渲染好的完美 HTML，转而显示 \", _jsx(_components.code, {\n          children: \"Suspense\"\n        }), \" 的 \", _jsx(_components.code, {\n          children: \"fallback\"\n        }), \" (即 \\\"Loading JS...\\\")。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"需求2\"\n      }), \"：需要手动点击后再下载 JS，下载 JS 过程中显示一个 Fallback 。使用 \", _jsx(_components.code, {\n        children: \"Lazy import\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"useState\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 可做。\", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 可以让人少写一个 state 三目运算符，显得好看一点，别的没用。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"需求3\"\n      }), \"： 首屏不加载，但首屏挂载后偷偷下载 JS chunk 之后用。可以直接使用 \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" 普通 import。但是这边有个问题，这个import的结果是在副作用里，你要暂时存到一个变量才能在需要的时候调用。如果嫌组件存变量占内存，可以 \", _jsx(_components.code, {\n        children: \"useEffect\"\n      }), \" + 顶层\", _jsx(_components.code, {\n        children: \"Lazy import\"\n      }), \" + \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"总之： \", _jsxs(_components.strong, {\n        children: [\"用 \", _jsx(_components.code, {\n          children: \"useEffect\"\n        }), \" 触发网络请求，用 \", _jsx(_components.code, {\n          children: \"lazy\"\n        }), \" 管理组件引用，用 \", _jsx(_components.code, {\n          children: \"Suspense\"\n        }), \" 处理加载状态。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Suspense\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Suspense\"\n      }), \" 的本质并不是为了服务 \", _jsx(_components.code, {\n        children: \"lazy\"\n      }), \" 组件的，它的本质是：\", _jsx(_components.strong, {\n        children: \"让组件“暂停”渲染，等待某个异步操作（Promise）完成。\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Suspense 里挂载一个\", _jsx(_components.strong, {\n        children: \"异步组件\"\n      }), \"，就可以等异步组件有返回后再显示。比如子组件里使用 await fetch 阻塞了结果返回。而Lazy 组件，也这么一种异步组件。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Suspense 里挂载一个带有 \", _jsx(_components.code, {\n        children: \"use hook\"\n      }), \" 的组件在 use hook 完成前，都会使用最近的 Suspense。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"use hook\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在最新的 React 版本中，推出了 \", _jsx(_components.code, {\n        children: \"use\"\n      }), \" Hook，它允许你在组件内部直接“解包”一个 Promise。如果 Promise 没完成，它会触发最近的 \", _jsx(_components.code, {\n        children: \"Suspense\"\n      }), \"。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":57,"_10":58,"_13":60,"_15":16,"_17":61,"_20":63,"_22":64},"2026-01-04 03:34:48",[59],"博客",[],[19,62],5,799,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(Tag, {\n        text: \"博客\",\n        children: \"#博客\"\n      }), \" 重构记录\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"切换路由框架为 React Router 7 做 SSG。至于为什么……一是 Next.js 虽然比较自动，但真的很慢。主要我做 Memo 页需要混合路由，并不是单纯的 SSG 或者 SPA。\\n天知道我为了在 Next.js 12那个基于文件系统的路由框架上整个混合渲染有多麻烦，点个什么都要靠手动劫持路由还要小心状态机防止循环渲染。Suspense 是 AppRouter 出了才有的，感觉也是很不直观。就算现在，也做不到访问 query 时劫持掉静态内容直接显示 CSR 的骨架，一定要闪一下，因为分割渲染方式的入口是组件而不是路由。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"CSS 切换为 tailiwind 预构建。我虽然不喜欢 tailwind 的丑，但是也不太想用 css in js 去水合页面，有构建时水合的开销就算了还有运行时开销。此外原生 css 也混着用。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"markdown 内容用 velite 预构建。这个管线是真的好用，但也不担心类型问题（感谢 zod），rss 和搜索索引构建和应该写哪里的问题也一块解决了。其实还是要自己引入 mdx-js 去做 compile，因为静态 memos 对 markdown 的使用方式非常特殊。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"这个博客非常多的部分都靠预构建，路由自己写是有点麻烦但写好了也是自动生成了不用再动了。我觉得也正是这些预构建的步骤变多了，生成才能快得起来了。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"另外我彻底摒弃了 memos 多个来源混合的预留接口。真的不知道发在哪个 CMS 上，还有谁天天看在博客看即时消息啊。但是啊，如果说有同样的人构建同样的博客，并且允许跨域，那确实是可以把一堆建同样博客的人的消息混在一堆的……\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"巨量 debug。你永远不知道为什么本来工作地好好的 Virtualist 换个框架变 key 后不强制刷新了。我看了很多可变高度 Virtualist 的实现，感觉还是自己的实现使用起来最傻瓜（因为自动布局逻辑简单不了，落泪，状态机很麻烦的）。网上实现全是要手动算一堆高度的，连 fixed 高度也要指定，用起来实在太蠢了。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Memo 的 Image Browser 用 claude 迁移之后自动做了一个缩略图预览，笑死。感觉这样的话，相册页面也有着落了，但是相册页最麻烦的其实是，Memo 没有缩略图……也就是说需要超大图片展示相册以免自己一边开发着一边狂刷流量。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"SearchEngine 也改了下接口以不限制任何的 searchObj。当然匹配还是有 bug 的，但懒得测试了。以前老担心东西多了搜太慢，现在觉得这个问题永远不用担心，因为网永远更慢……怎么分割索引加快网速比客户端执行时间重要得多。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总之，是改了超多的，经常在发呆不知道还要改什么。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":66,"_10":67,"_13":68,"_15":16,"_17":69,"_20":71,"_22":72},"2026-01-02 18:39:54",[],[],[19,70],6,175,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    pre: \"pre\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"tailwind 的局限：做不了出入非对称的动画。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"The key difference:\\n- On hover: width transition has a 0.2s delay (bar appears after moving)\\n- On unhover: width transition has NO delay (bar shrinks immediately)\\nTailwind's group-hover:before:delay-200 only applies delay on hover, but the transition property itself doesn't change. I need to use CSS to handle this properly since Tailwind can't easily express different transition timings for hover vs unhover states.\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这是 Claude 说的，我对 tailwind 的了解着实很浅。怎么说，用高层包装的东西就是会感觉有一些受限吧。并且用原生 css，非常非常明显的渲染性能更好，感觉是 DOM 匹配样式表没那么大开销，tailwind 写出来渲染是掉帧的（不应该啊已经算好了为什么要卡）……\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":74,"_10":75,"_13":76,"_15":16,"_17":77,"_20":79,"_22":80},"2026-01-02 06:39:34",[],[],[19,78],7,121,"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"woc Inter 的 variable font 居然和 static version 不一样，还是说有更新过？不应该啊。我本地安装 的是可变字体，然后百思不得其解完全同样的写法怎么字变小了。事实证明是 Static version 字距什么都比较好。但我更百思不得其解的是为什么同样的 CSS 引入 font，现在的博客 fontback 到了本地字体上，我的天因为我这字体很全一直没发现。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":82,"_10":83,"_13":84,"_15":16,"_17":85,"_20":87,"_22":88},"2026-01-01 22:53:40",[],[],[19,86],8,392,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"在迁移用 Velite 当本地 CMS。落泪，2022 年重写博客时哪有这么好的条件。是我喜爱的预构建 0 运行时开销。顺便 RSS 问题也是不用在那自己 Pre-render 了，太 Ugly 了。当时也没想到再做一个外置的 CMS 工具，有的问题是到了要做搜索和 rss 后才发现需要的。当时在 Next.js 做 rss 真的就是把生成工具写到 getStaticProps 里面，这样导出时就能顺便调用了，也是服了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"另外，路由准备迁移到 RR 7。我近一年多受够 Next.js 了，感觉是如果是在框架内做事会很方便，想跳脱他的框架加点东西就会变得非常 messy……Transition api? 呵呵呵，因为你不是真正到了一个新 Document，所以无法 Transition。那就 CSR？呵呵呵，SEO 不想要了吗。我说的就是 Topbar，在 SSG 下，新点链接其实没有跳转页面，而是整个 tree 卸载掉再挂上整个新 tree，既不是到了一个新页面，也无法像真正的 CSR 那样只更新部分属性，直接导致两种东西动画都没法用。因此想要对预渲染方式有更细的粒度和更大的自由度。要说体验最流畅的肯定是纯 CSR 没跑，但是没 SEO 这点对于博客不可接受。可能会说 \", _jsx(_components.code, {\n        children: \"use client\"\n      }), \" 不是很方便吗？不，不能，我还是需要 SSR 的，只有部分点击的内容需要 CSR。可定义的粒度还是太低了。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":90,"_10":91,"_13":92,"_15":16,"_17":93,"_20":95,"_22":96},"2026-01-01 04:21:10",[],[],[19,94],9,111,"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"今天看到有人说觉得 OB 写技术类的还行，感性类的就怎么写也不舒服。我举双手赞成。我觉得靠感觉写东西的界面就是越简单越好，所见即所得很重要的，排除各种图标、线框、代码的干扰。我特别喜欢 Velocity 那个主题的设计，但是很遗憾就是不适合写作。要说写作，那就还得是 Typora。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","info",{"_5":99,"_10":100,"_101":102,"_103":104},299,13,"imgs",21,"pages",30,[106,111,118,122,126,131,138,142,145,149,157,161,164],{"_107":12,"_108":109},"name","memoIds",[9,49,110],"2023-11-08 01:30:55",{"_107":59,"_108":112},[57,113,114,115,116,117],"2024-10-16 18:36:24","2024-08-23 08:18:14","2023-11-06 21:20:06","2023-10-29 01:13:43","1980-01-01 00:48:28",{"_107":119,"_108":120},"字体",[121],"2025-07-31 02:40:38",{"_107":123,"_108":124},"动画",[125],"2025-07-25 00:48:53",{"_107":127,"_108":128},"游戏",[129,130],"2025-01-05 00:51:17","2024-12-08 00:12:16",{"_107":132,"_108":133},"沉思",[134,135,136,137],"2024-02-28 17:24:54","2024-02-22 15:36:59","2024-02-13 16:01:25","2024-02-09 00:34:23",{"_107":139,"_108":140},"obsidian",[141],"2024-02-18 01:19:32",{"_107":143,"_108":144},"五笔输入法",[141],{"_107":146,"_108":147},"书",[148],"2024-02-16 00:17:38",{"_107":150,"_108":151},"工具",[152,153,154,155,156],"2023-12-27 18:09:43","2023-11-29 03:12:05","2023-11-21 00:57:14","2023-11-02 22:20:54","2023-08-30",{"_107":158,"_108":159},"故事",[160],"2023-12-10 06:42:56",{"_107":162,"_108":163},"漫画",[115],{"_107":165,"_108":166},"mdx",[167],"2023-11-05 21:04:56","source","SSG"]
