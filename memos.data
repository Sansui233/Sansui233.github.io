[{"_1":2},"routes/memos",{"_3":4},"data",{"_5":6,"_96":97,"_10":104,"_173":174},"memos",[7,23,31,40,48,56,65,73,81,89],{"_8":9,"_10":11,"_12":13,"_14":15,"_16":17,"_19":20,"_21":22},"id","2026-01-29 01:32:56","tags",[],"imgs_md",[],"sourceFile","","csrIndex",[18,18],0,"word_count",59,"content_jsx","\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [_jsx(_components.a, {\n      href: \"https://yazi-rs.github.io/\",\n      children: \"Yazi\"\n    }), \" 确实好用，早日干掉 Windows 资源管理器（不是）。Windows 资源管理器现在都没有多栏 View，UI 在 23h2 上卡爆炸。 25h2 现在好像修了，其实还不错的。那只剩没有多栏  view 了。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":24,"_10":25,"_12":26,"_14":15,"_16":27,"_19":29,"_21":30},"2026-01-26 20:37:38",[],[],[18,28],1,90,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"挺看好  anrigravity 的。我倒希望和 vscode 差别越来越大。能干的事不只有写纯文本。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是模型写代码能力真的不太行，gemini 系列的幻觉还是太重了喜欢乱猜原因，然后把代码改得一团乱，而不是使用一些方法验证。这点还是 GPT5.2 和 cc 比较强。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":32,"_10":33,"_12":35,"_14":15,"_16":36,"_19":38,"_21":39},"2026-01-25 19:09:16",[34],"分享",[],[18,37],2,412,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/yuaotian/antigravity-proxy\",\n          children: \"免 tun 使用 Antigravity 的工具\"\n        }), \"\\n实测可以登录，但获取模型列表会出错。把\", _jsx(_components.a, {\n          href: \"https://github.com/yuaotian/antigravity-proxy/issues/29#issuecomment-3794299080\",\n          children: \"编辑器内 http proxy 也设置为 7890\"\n        }), \"  就好了。至于为什么不开 tun …… 我的 tun 目前还要留给学校 vpn，学术网站走代理软件即便是直连也不行。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://github.com/magic-research/magic-animate\",\n          children: \"magic-animate\"\n        }), \" 原来AI换动作用的是这个……其实我是想搜 motion 相关的插件，没想到出了这个……\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=xuoHLyWymz0\",\n          children: \"magic-animate\"\n        }), \" Davinci 很方便的做转场的动画插件。\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"出入场动画： Zoom, Whip，可设置延迟速度时长等等。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"中场动画，Shake, Mid Wave\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fusion 我用了，感觉是好难用。写了表达式可以在样条线里看，虽然写表达式不用手 K 帧是好事，但是你也没说能存个表达式和变量组的预设啊？变量有没有效果也不知道没报错。而且动画经常是要一段一段的，不是一个表达式就是写完的。样条线也没有预设保存，次次手K吗……很少见到这种强大又鸡肋的东西了。就是感觉 HTML 都写得比快……总之不要用 Fusion 做动画！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而且 Fusion 效果无法预览这点也很要命，要把所有节点的作用背下来……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外 MG 动画其实只要重复 + 非线性一下就会有好的效果，真的，就看有没有那个心情去 K 重复的动画。常见套路就是非线性+重复动画+时间差（视差），再加点莫名其妙的 Mask。 复古的抽个帧。PATH 类的常见路径动画。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":41,"_10":42,"_12":43,"_14":15,"_16":44,"_19":46,"_21":47},"2026-01-24 02:47:21",[34],[],[18,45],3,12,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"3D\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=gdOaUv0_TC8\",\n          children: \"Blender Bones For Beginners - EASY - YouTube\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":49,"_10":50,"_12":51,"_14":15,"_16":52,"_19":54,"_21":55},"2026-01-19 21:09:44",[34],[],[18,53],4,444,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"技术\"\n      }), \" \", _jsx(Tag, {\n        text: \"分享\",\n        children: \"#分享\"\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://cacm.acm.org/blogcacm/two-concepts-of-intelligence/\",\n            children: \"智能的两种概念 – Communications of the ACM\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"我觉得可以折中一下，是在无相关经验情况下给出正确答案能力，既有了明确指标也避免了“归纳式智能”。这在现实世界是很确定的出题方式了吧，IQ 测试题都是被设计为无需先验知识的，不会有语言题，你甚至可以给猩猩做。看看图像模型看这么多图后，能不能补全呀哈哈的最后一颗石头就行了。我觉得 AI 是可以有逻辑的，要是有合适的无监督聚类算法，训练了说不定真的可以完成这种任务。但是没有这种无监督随便迁移领域的聚类算法，现在说的无监督实际是自动生成标注/不需要额外人力标注的有监督。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"对于情商我自己定义为，“在自我有相关经验情况下，能给出被社会接纳的答案，并强烈遵守此答案” 的能力。\"\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"刚问了 GPT 下面这个问题，嗯，一塌糊涂。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://austinhenley.com/blog/ladybugclock.html\",\n            children: \"一个随机游走问题\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"结论应该是这样的：每个数字上的停留概率是一样的，这是一个理论上稳态分布 stationary distribution，有限次数内只能逼近无法到达的完美分布。如果限定到在有限次数内完成遍历，在 1 和 11 停留的概率是最大的，停留在 6 的概率是最小的。或者说，在 6 停留的平均步数要比其他的数字长，停留在 6 的 step 比 停留在 1 上的步数上要多个十几次，这已经超过了一圈的距离。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":57,"_10":58,"_12":60,"_14":15,"_16":61,"_19":63,"_21":64},"2026-01-18 18:05:29",[59],"TODO",[],[18,62],5,207,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ...props.components\n  }, {Tag} = _components;\n  if (!Tag) _missingMdxReference(\"Tag\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"感觉 rust 的出现一统 shell 体验的天下……尤其是 windows 版本的。没有 rust 就不会出现 starship zoxide eza 这些东西，跨平台还要用到系统库 c++ 够得受了。如果 tree-sitter 生在现在就不会有各种 libc 的破事了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外就是小模型的浏览器 C 端运行…… onnx 还真是可以试一下，小工具狂魔又有玩的了。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/microsoft/onnxruntime-web-demo\",\n          children: \"onnxruntime demo\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/vietanhdev/samexporter\",\n          children: \"SAMexporter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/Xenova/whisper-web\",\n          children: \"Whisper Web - a Hugging Face Space by Xenova\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://huggingface.co/spaces/webml-community/YOLO26-WebGPU\",\n          children: \"YOLO26 WebGPU - a Hugging Face Space by webml-community\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我觉得超分辨率模型还挺适合做这个的。列入 \", _jsx(Tag, {\n        text: \"TODO\",\n        children: \"#TODO\"\n      }), \" 吧。还有抠图，真的没有做纯客户端的抠图吗全都去服务器排队…… seg 模型 CPU 算个几秒也是完全可以接受的啊。哦对，这倒是有商业模式的问题。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n",{"_8":66,"_10":67,"_12":68,"_14":15,"_16":69,"_19":71,"_21":72},"2026-01-16 21:50:19",[],[],[18,70],6,30,"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"看了下 zed 的 \", _jsx(_components.a, {\n      href: \"https://www.gpui.rs/\",\n      children: \"gui 库\"\n    }), \"，wow，DOM 之青春版，蛮喜欢的。zed 团队的复刻轮子能力是真的强。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":74,"_10":75,"_12":76,"_14":15,"_16":77,"_19":79,"_21":80},"2026-01-16 16:05:27",[],[],[18,78],7,179,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    hr: \"hr\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"域名搬到 porkbun 了。namecheap 直接涨到 25刀了。本来想说迁移到 CF 算了，结果 Cloudflare 的 transfer  系统错误一次后就此卡住了。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"给了 vscode 编辑器一个 vim emulator。很早之前有用过但是实在是用不习惯。现在我觉得驯化程度比以前高一点了所以再试下。vim normal mode 可以解决快捷键不够用的问题，像是侧栏图标是很难按的，但给的快捷键实在不是人，三键起步还是最不好按的 ctrl + shift 组合。但我觉得 emulator 的响应速度有点慢，特别是保存文件时，调用的 vscode api 但要卡一秒， 不知道为什么。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":82,"_10":83,"_12":84,"_14":15,"_16":85,"_19":87,"_21":88},"2026-01-16 12:59:13",[],[],[18,86],8,142,"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    hr: \"hr\",\n    p: \"p\",\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"……………………………………………………\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"现在来看 Rust 觉得设计得确实很好……最开始看时是有点天书的对有的规则比较死记硬背。即便真的会给你讲为什么这么设计，但并不能十分理解。准确地说，理解这个事情本身也要需要记住，需要熟练度的……\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有人总觉得人到什么年纪理所当然应该懂得什么道理，但世界上没有那么多理所当然的事情，只是都懒得容忍不符合自己预期的人。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n",{"_8":90,"_10":91,"_12":92,"_14":15,"_16":93,"_19":71,"_21":95},"2026-01-15 15:48:35",[],[],[18,94],9,"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"Gemini Pro 竟然是能用国内发行的 visa 卡订阅的，甚至用的无额度的工行星座卡。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","info",{"_5":98,"_10":99,"_100":101,"_102":103},314,11,"imgs",21,"pages",32,[105,116,118,125,136,146,150,155,162,166,170],{"_106":34,"_107":108},"name","memoIds",[32,41,49,109,110,111,112,113,114,115],"2026-01-11 06:42:02","2026-01-09 03:25:00","2025-12-28 02:41:52","2025-12-15 10:53:00","2025-11-20 00:00:01","2025-11-16 05:39:33","2025-07-25 00:48:53",{"_106":59,"_107":117},[57],{"_106":119,"_107":120},"react",[121,122,123,124],"2026-01-10 03:19:55","2026-01-08 14:14:49","2026-01-04 20:32:00","2023-11-08 01:30:55",{"_106":126,"_107":127},"博客",[128,129,130,131,132,133,134,135],"2026-01-04 03:34:48","2026-01-01 22:53:40","2024-10-16 18:36:24","2024-08-23 08:18:14","2023-11-06 21:20:06","2023-11-05 21:04:56","2023-10-29 01:13:43","1980-01-01 00:48:28",{"_106":137,"_107":138},"工具",[139,140,141,142,143,144,145],"2025-12-18 02:58:11","2024-02-18 01:19:32","2023-12-27 18:09:43","2023-11-29 03:12:05","2023-11-21 00:57:14","2023-11-02 22:20:54","2023-08-30",{"_106":147,"_107":148},"字体",[149],"2025-07-31 02:40:38",{"_106":151,"_107":152},"游戏",[153,154],"2025-01-05 00:51:17","2024-12-08 00:12:16",{"_106":156,"_107":157},"沉思",[158,159,160,161],"2024-02-28 17:24:54","2024-02-22 15:36:59","2024-02-13 16:01:25","2024-02-09 00:34:23",{"_106":163,"_107":164},"书",[165],"2024-02-16 00:17:38",{"_106":167,"_107":168},"故事",[169],"2023-12-10 06:42:56",{"_106":171,"_107":172},"漫画",[132],"source","SSG"]
