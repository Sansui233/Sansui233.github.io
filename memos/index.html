<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EDE15EB3W8"></script><title>Sansui - Memos</title><meta name="description" content="Micro-blogging and short thoughts"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="modulepreload" href="/assets/manifest-7efb04b2.js"/><link rel="modulepreload" href="/assets/entry.client-4C1T-Ty8.js"/><link rel="modulepreload" href="/assets/chunk-JMJ3UQ3L-CM_uFqsX.js"/><link rel="modulepreload" href="/assets/index-BVXP-eVr.js"/><link rel="modulepreload" href="/assets/root-DQsl7uZB.js"/><link rel="modulepreload" href="/assets/site.config-B03RtX8f.js"/><link rel="modulepreload" href="/assets/memos-CGgTyNSI.js"/><link rel="modulepreload" href="/assets/memos-Clo_CPbJ.js"/><link rel="modulepreload" href="/assets/use-search-HHkQ677v.js"/><link rel="modulepreload" href="/assets/layout-Ig7IE2Rm.js"/><link rel="modulepreload" href="/assets/MDXComponent-Cp7WEeGf.js"/><link rel="modulepreload" href="/assets/date-ZZAo9_oO.js"/><link rel="stylesheet" href="/assets/root-FZiMFrgy.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;display=swap"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-EDE15EB3W8', {
                page_path: window.location.pathname,
              });
            </script></head><body><div class="bg-bg-2 flex min-h-screen items-center justify-center"><div class="text-text-gray-2 flex flex-col items-center gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-circle animate-spin" aria-hidden="true"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg><span class="text-lg font-medium">Cooking...</span><span class="text-text-gray-3 text-sm">等等，卡卡西正在做饭……</span></div></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"unstable_optimizeDeps":false,"unstable_subResourceIntegrity":false,"v8_middleware":false,"v8_splitRouteModules":false,"v8_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-7efb04b2.js";
import * as route0 from "/assets/root-DQsl7uZB.js";
import * as route1 from "/assets/memos-CGgTyNSI.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/memos":route1};

import("/assets/entry.client-4C1T-Ty8.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_170\":-5,\"_171\":-5},\"loaderData\",{\"_3\":4},\"routes/memos\",{\"_5\":6,\"_97\":98,\"_10\":105,\"_168\":169},\"memos\",[7,23,32,41,49,57,65,73,81,89],{\"_8\":9,\"_10\":11,\"_12\":13,\"_14\":15,\"_16\":17,\"_19\":20,\"_21\":22},\"id\",\"2026-01-06 04:10:28\",\"tags\",[],\"imgs_md\",[],\"sourceFile\",\"\",\"csrIndex\",[18,18],0,\"word_count\",71,\"content_jsx\",\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"草，有瓜\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: _jsx(_components.a, {\\n          href: \\\"\\\",\\n          children: \\\"这是一篇号商无能狂怒的聚集地：This is a gathering place for the incompetence and rage of a number merchant\\\"\\n        })\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"全被删了。有贴子看了一眼风格\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsxs(_components.p, {\\n          children: [\\\"总结：\\\", _jsx(_components.a, {\\n            href: \\\"https://linux.do/t/topic/1408515\\\",\\n            children: \\\"https://linux.do/t/topic/1408515\\\"\\n          })]\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsxs(_components.p, {\\n          children: [\\\"贴子风格：\\\", _jsx(_components.a, {\\n            href: \\\"https://x.com/flyiiawei/status/2008124574379212830\\\",\\n            children: \\\"https://x.com/flyiiawei/status/2008124574379212830\\\"\\n          })]\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: _jsx(_components.a, {\\n            href: \\\"https://linux.do/t/topic/1408358\\\",\\n            children: \\\"https://linux.do/t/topic/1408358\\\"\\n          })\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"怎么传播广的不是骂人就是黄段子……\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":24,\"_10\":25,\"_12\":27,\"_14\":15,\"_16\":28,\"_19\":30,\"_21\":31},\"2026-01-04 20:32:00\",[26],\"react\",[],[18,29],1,985,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    code: \\\"code\\\",\\n    h3: \\\"h3\\\",\\n    hr: \\\"hr\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.p, {\\n      children: [_jsx(Tag, {\\n        text: \\\"react\\\"\\n      }), \\\" 一个没有预料到的状态管理问题：如果组件层级 A\u003eB\u003eC，A负责获取数据源，C负责渲染。那 State 缓存数据不要给到 B。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"为什么？因为 C 同时应用 A 的更新数据和 B 的缓存数据时，B的缓存数据更新会慢一拍，因为B需要去订阅A的更新再通知C更新 props（useEffect 是异步的）。如果 C 中有 state 的初始化依赖缓存数据，那这个初始化也会慢一拍。导致渲染结果（随着缓存更新）和 C_state（只随初始化更新）不一致。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"可能会想，那 C_state 也去订阅 B 缓存就好了？不行，订阅 B 缓存，C_state 更新也还是比渲染慢一拍。此时如果渲染会更新 C_state，那就和对于 B 的订阅冲突了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"使用缓存是副作用，谨慎处理副作用。\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"为什么有这么奇葩的结构……因为A和C都是库啊！！只能存到B。好消息是C库自己实现的，改成C库自己存数据，有数据更新后通知B了。但要是真只能写B，C不存数据，那 C 的 props\\\", _jsx(_components.strong, {\\n        children: \\\"需要全部用同步更新的缓存\\\"\\n      }), \\\"。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"这其实提到了一个叫派生状态，知乎上有说，但最终也没提出来解决办法。派生状态至今没有检测。 \\\", _jsx(_components.a, {\\n        href: \\\"https://zhuanlan.zhihu.com/p/349372515\\\",\\n        children: \\\"https://zhuanlan.zhihu.com/p/349372515\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"这是我使用 react-router clientLoader 最大的坑。非常容易遇到反模式。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Lazy import 组件\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"好好了解一下 Lazy 的概念，看 SSG 这种重 SEO 场景首屏能不能用。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"首先是要明白，Lazy 导入的组件必须被 Suspense 包裹，不然会 Throw 一个异常向上报错直到遇到了 Suspense 组件进行一个 fallback。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"其次是分情况\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"函数 await import，以 show State 加载 -\u003e 无首屏，不显示在Dom\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"Lazy import，以 show State 加载 Suspense -\u003e 无首屏，不显示在Dom，用 Lazy 属于多此一举。\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"Lazy import ，以 Suspense 加载 -\u003e 大致能用（Dom 能显示，有短时间不可交互，直到浏览器自动下载完代码分割）\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"仅以 Suspense 加载 -\u003e 能用（Dom能显示，显示就能交互，没有代码分割）（RSC核心）\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"对于以上第三个点，“大致能用”是有个坑\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"如果 JS 加载慢，React 在客户端运行时发现代码没到，它可能会判定为“未准备好”，于是\\\", _jsx(_components.strong, {\\n          children: \\\"扔掉\\\"\\n        }), \\\"服务端渲染好的完美 HTML，转而显示 \\\", _jsx(_components.code, {\\n          children: \\\"Suspense\\\"\\n        }), \\\" 的 \\\", _jsx(_components.code, {\\n          children: \\\"fallback\\\"\\n        }), \\\" (即 \\\\\\\"Loading JS...\\\\\\\")。\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.strong, {\\n        children: \\\"需求2\\\"\\n      }), \\\"：需要手动点击后再下载 JS，下载 JS 过程中显示一个 Fallback 。使用 \\\", _jsx(_components.code, {\\n        children: \\\"Lazy import\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"useState\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 可做。\\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 可以让人少写一个 state 三目运算符，显得好看一点，别的没用。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.strong, {\\n        children: \\\"需求3\\\"\\n      }), \\\"： 首屏不加载，但首屏挂载后偷偷下载 JS chunk 之后用。可以直接使用 \\\", _jsx(_components.code, {\\n        children: \\\"useEffect\\\"\\n      }), \\\" 普通 import。但是这边有个问题，这个import的结果是在副作用里，你要暂时存到一个变量才能在需要的时候调用。如果嫌组件存变量占内存，可以 \\\", _jsx(_components.code, {\\n        children: \\\"useEffect\\\"\\n      }), \\\" + 顶层\\\", _jsx(_components.code, {\\n        children: \\\"Lazy import\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"总之： \\\", _jsxs(_components.strong, {\\n        children: [\\\"用 \\\", _jsx(_components.code, {\\n          children: \\\"useEffect\\\"\\n        }), \\\" 触发网络请求，用 \\\", _jsx(_components.code, {\\n          children: \\\"lazy\\\"\\n        }), \\\" 管理组件引用，用 \\\", _jsx(_components.code, {\\n          children: \\\"Suspense\\\"\\n        }), \\\" 处理加载状态。\\\"]\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Suspense\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 的本质并不是为了服务 \\\", _jsx(_components.code, {\\n        children: \\\"lazy\\\"\\n      }), \\\" 组件的，它的本质是：\\\", _jsx(_components.strong, {\\n        children: \\\"让组件“暂停”渲染，等待某个异步操作（Promise）完成。\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Suspense 里挂载一个\\\", _jsx(_components.strong, {\\n        children: \\\"异步组件\\\"\\n      }), \\\"，就可以等异步组件有返回后再显示。比如子组件里使用 await fetch 阻塞了结果返回。而Lazy 组件，也这么一种异步组件。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Suspense 里挂载一个带有 \\\", _jsx(_components.code, {\\n        children: \\\"use hook\\\"\\n      }), \\\" 的组件在 use hook 完成前，都会使用最近的 Suspense。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"use hook\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"在最新的 React 版本中，推出了 \\\", _jsx(_components.code, {\\n        children: \\\"use\\\"\\n      }), \\\" Hook，它允许你在组件内部直接“解包”一个 Promise。如果 Promise 没完成，它会触发最近的 \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\"。\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":33,\"_10\":34,\"_12\":36,\"_14\":15,\"_16\":37,\"_19\":39,\"_21\":40},\"2026-01-04 03:34:48\",[35],\"博客\",[],[18,38],2,799,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.p, {\\n      children: [_jsx(Tag, {\\n        text: \\\"博客\\\"\\n      }), \\\" 重构记录\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"切换路由框架为 React Router 7 做 SSG。至于为什么……一是 Next.js 虽然比较自动，但真的很慢。主要我做 Memo 页需要混合路由，并不是单纯的 SSG 或者 SPA。\\\\n天知道我为了在 Next.js 12那个基于文件系统的路由框架上整个混合渲染有多麻烦，点个什么都要靠手动劫持路由还要小心状态机防止循环渲染。Suspense 是 AppRouter 出了才有的，感觉也是很不直观。就算现在，也做不到访问 query 时劫持掉静态内容直接显示 CSR 的骨架，一定要闪一下，因为分割渲染方式的入口是组件而不是路由。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"CSS 切换为 tailiwind 预构建。我虽然不喜欢 tailwind 的丑，但是也不太想用 css in js 去水合页面，有构建时水合的开销就算了还有运行时开销。此外原生 css 也混着用。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"markdown 内容用 velite 预构建。这个管线是真的好用，但也不担心类型问题（感谢 zod），rss 和搜索索引构建和应该写哪里的问题也一块解决了。其实还是要自己引入 mdx-js 去做 compile，因为静态 memos 对 markdown 的使用方式非常特殊。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"这个博客非常多的部分都靠预构建，路由自己写是有点麻烦但写好了也是自动生成了不用再动了。我觉得也正是这些预构建的步骤变多了，生成才能快得起来了。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"另外我彻底摒弃了 memos 多个来源混合的预留接口。真的不知道发在哪个 CMS 上，还有谁天天看在博客看即时消息啊。但是啊，如果说有同样的人构建同样的博客，并且允许跨域，那确实是可以把一堆建同样博客的人的消息混在一堆的……\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"巨量 debug。你永远不知道为什么本来工作地好好的 Virtualist 换个框架变 key 后不强制刷新了。我看了很多可变高度 Virtualist 的实现，感觉还是自己的实现使用起来最傻瓜（因为自动布局逻辑简单不了，落泪，状态机很麻烦的）。网上实现全是要手动算一堆高度的，连 fixed 高度也要指定，用起来实在太蠢了。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"Memo 的 Image Browser 用 claude 迁移之后自动做了一个缩略图预览，笑死。感觉这样的话，相册页面也有着落了，但是相册页最麻烦的其实是，Memo 没有缩略图……也就是说需要超大图片展示相册以免自己一边开发着一边狂刷流量。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"SearchEngine 也改了下接口以不限制任何的 searchObj。当然匹配还是有 bug 的，但懒得测试了。以前老担心东西多了搜太慢，现在觉得这个问题永远不用担心，因为网永远更慢……怎么分割索引加快网速比客户端执行时间重要得多。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"总之，是改了超多的，经常在发呆不知道还要改什么。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":42,\"_10\":43,\"_12\":44,\"_14\":15,\"_16\":45,\"_19\":47,\"_21\":48},\"2026-01-02 18:39:54\",[],[],[18,46],3,175,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    code: \\\"code\\\",\\n    p: \\\"p\\\",\\n    pre: \\\"pre\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"tailwind 的局限：做不了出入非对称的动画。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"The key difference:\\\\n- On hover: width transition has a 0.2s delay (bar appears after moving)\\\\n- On unhover: width transition has NO delay (bar shrinks immediately)\\\\nTailwind's group-hover:before:delay-200 only applies delay on hover, but the transition property itself doesn't change. I need to use CSS to handle this properly since Tailwind can't easily express different transition timings for hover vs unhover states.\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"这是 Claude 说的，我对 tailwind 的了解着实很浅。怎么说，用高层包装的东西就是会感觉有一些受限吧。并且用原生 css，非常非常明显的渲染性能更好，感觉是 DOM 匹配样式表没那么大开销，tailwind 写出来渲染是掉帧的（不应该啊已经算好了为什么要卡）……\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":50,\"_10\":51,\"_12\":52,\"_14\":15,\"_16\":53,\"_19\":55,\"_21\":56},\"2026-01-02 06:39:34\",[],[],[18,54],4,121,\"\\\"use strict\\\";\\nconst {jsx: _jsx} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsx(_components.p, {\\n    children: \\\"woc Inter 的 variable font 居然和 static version 不一样，还是说有更新过？不应该啊。我本地安装 的是可变字体，然后百思不得其解完全同样的写法怎么字变小了。事实证明是 Static version 字距什么都比较好。但我更百思不得其解的是为什么同样的 CSS 引入 font，现在的博客 fontback 到了本地字体上，我的天因为我这字体很全一直没发现。\\\"\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":58,\"_10\":59,\"_12\":60,\"_14\":15,\"_16\":61,\"_19\":63,\"_21\":64},\"2026-01-01 22:53:40\",[],[],[18,62],5,392,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    code: \\\"code\\\",\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"在迁移用 Velite 当本地 CMS。落泪，2022 年重写博客时哪有这么好的条件。是我喜爱的预构建 0 运行时开销。顺便 RSS 问题也是不用在那自己 Pre-render 了，太 Ugly 了。当时也没想到再做一个外置的 CMS 工具，有的问题是到了要做搜索和 rss 后才发现需要的。当时在 Next.js 做 rss 真的就是把生成工具写到 getStaticProps 里面，这样导出时就能顺便调用了，也是服了。\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"另外，路由准备迁移到 RR 7。我近一年多受够 Next.js 了，感觉是如果是在框架内做事会很方便，想跳脱他的框架加点东西就会变得非常 messy……Transition api? 呵呵呵，因为你不是真正到了一个新 Document，所以无法 Transition。那就 CSR？呵呵呵，SEO 不想要了吗。我说的就是 Topbar，在 SSG 下，新点链接其实没有跳转页面，而是整个 tree 卸载掉再挂上整个新 tree，既不是到了一个新页面，也无法像真正的 CSR 那样只更新部分属性，直接导致两种东西动画都没法用。因此想要对预渲染方式有更细的粒度和更大的自由度。要说体验最流畅的肯定是纯 CSR 没跑，但是没 SEO 这点对于博客不可接受。可能会说 \\\", _jsx(_components.code, {\\n        children: \\\"use client\\\"\\n      }), \\\" 不是很方便吗？不，不能，我还是需要 SSR 的，只有部分点击的内容需要 CSR。可定义的粒度还是太低了。\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":66,\"_10\":67,\"_12\":68,\"_14\":15,\"_16\":69,\"_19\":71,\"_21\":72},\"2026-01-01 04:21:10\",[],[],[18,70],6,111,\"\\\"use strict\\\";\\nconst {jsx: _jsx} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsx(_components.p, {\\n    children: \\\"今天看到有人说觉得 OB 写技术类的还行，感性类的就怎么写也不舒服。我举双手赞成。我觉得靠感觉写东西的界面就是越简单越好，所见即所得很重要的，排除各种图标、线框、代码的干扰。我特别喜欢 Velocity 那个主题的设计，但是很遗憾就是不适合写作。要说写作，那就还得是 Typora。\\\"\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":74,\"_10\":75,\"_12\":76,\"_14\":15,\"_16\":77,\"_19\":79,\"_21\":80},\"2025-12-28 02:41:52\",[],[],[18,78],7,284,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    hr: \\\"hr\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [_jsx(_components.a, {\\n          href: \\\"https://floor796.com/#b1l1,282,992\\\",\\n          children: \\\"Floor 796\\\"\\n        }), \\\"一个全是角色的网站，好喜欢的风格\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"看了下网页几个轻拟物做得比较好的，比较有趣的是 box-shadow 的 inset 属性在加投影前都是凹进去的，一加投影就变凸了。所以\\\", _jsx(_components.strong, {\\n        children: \\\"要做凸先做投影\\\"\\n      }), \\\"，外部的颜色必须要更深，不然不符合凸的素描关系。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"（顺便凹凸的五笔还是那么难打……）\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"另外，如果要模拟更真实的效果，需要\\\", _jsx(_components.strong, {\\n        children: \\\"多重投影\\\"\\n      }), \\\" 模拟光线的弥散。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"以及\\\", _jsx(_components.strong, {\\n        children: \\\"悬浮效果\\\"\\n      }), \\\"，需要让投影的面积更小。感觉是模拟的真实世界的漫反射光线。直接投影的效果更像是有磨砂镜面反射。也能够说明为什么用单层外扩的 spread 颜色一深就丑了，这不符合白天光线的素描关系，只在夜晚/摄影棚出现，会显脏。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"听黎明和萤火虫还是很好哭，即便拿不拿是一个确实不太会唱歌的人，但这首是真的很喜欢……我相信声音比视觉更容易传递情绪。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":82,\"_10\":83,\"_12\":84,\"_14\":15,\"_16\":85,\"_19\":87,\"_21\":88},\"2025-12-27 02:11:50\",[],[],[18,86],8,86,\"\\\"use strict\\\";\\nconst {jsx: _jsx} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsx(_components.p, {\\n    children: \\\"唉，想做设计。真的论文会塑造得人挺无聊的，好不容易摒弃了因果学术那套，也好不容易终于有了点想表达的方向，又被拉回去。在大模型时代反而冷静下来不再追求将人工具化的效率，而更珍视人与想法本身。\\\"\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":90,\"_10\":91,\"_12\":92,\"_14\":15,\"_16\":93,\"_19\":95,\"_21\":96},\"2025-12-18 02:58:11\",[],[],[18,94],9,802,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    br: \\\"br\\\",\\n    code: \\\"code\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: _jsx(_components.strong, {\\n        children: \\\"工具\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [_jsx(_components.a, {\\n          href: \\\"https://github.com/farion1231/cc-switch\\\",\\n          children: \\\"cc-switch\\\"\\n        }), \\\" 中转站API切换GUI，MCP、Skill 管理和配置\\\", _jsx(_components.br, {}), \\\"\\\\n\\\", \\\"在国内只能使用中转，因此有个 GUI 管理还是方便一点，另外 Skill 也 MCP 也能管理。我不太用 MCP，原因是烧不起，有那种 5 倍 token 干 1.5 倍的事的感觉。Claude Code 的调用方式已经觉得烧不起了。在这之前是终端写了几个设置环境变量的函数来凑合一下的。\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"真的蛮想复刻一下 ChatGPT 的深度研究 的，做好了帮找论文确实好用，但同时也是 token 杀手。Gemini 的深度研究我觉得不太好用，有太多不够权威的结果。Chatgpt 查的都是专门的学术网站，查不到会触发近义词搜索什么的，非常接近人类找论文的状态了，但调研一次 5刀 token 真的是轻轻松松，论文那四五个点的调研天天查天天改，反复迭代，最后留的都有百篇 reference，真的是查吐了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"至于国内豆包那个结果，我只能说，图一乐……\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"另外 MCP 我觉得是一个概念先于应用的东西。与其是协议，更像插件 API 规范，MCP 的 P 不应该和 HTTP 的 P 坐一桌，而是和 command/API 坐一桌。LSP 和 DAP 的 P 都比 MCP 像协议，好歹人家是需要全程起一个进程才能给这个进程发消息的。\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"因为老被说是协议关系，经常会有一些令人误解的描述，比如：“LLM 调用 MCP 工具”。如果说 MCP 真的是印象中的协议，应该是 LLM 发送特定协议格式 \\\", _jsx(_components.code, {\\n        children: \\\"mcp://\\\"\\n      }), \\\" 给 MCP Server， MCP Server 返回结果给 LLM。但实际上呢？ 是 AI 客户端在 把 MCP 和 toolcall 这两种 API 互相翻译两边倒。MCP Server 也不需要“在线”，只需要是一个随时被 AI 客户端调用的二进制。换个说法，难道你会使用把 「“今天需要commit\\\\\\\" -\u003e 使用 git GUI 调用 git commit-\u003e ”告诉 leader 我commit了“」的全过程称为一种协议吗……\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"甚至可以说 MCP Server 一整圈的定义和 LLM 毫无关系。反正都是处理用户输入，MCP只参与到 「“今天需要commit\\\\\\\" -\u003e 使用 git GUI 调用 git commit」，后续结果告诉不告诉大模型关 MCP 什么事 。连第一步 ”今天需要commit“ 也可以不需要 LLM 的参与，你可以直接做成 \\\", _jsx(_components.code, {\\n        children: \\\"/commit\\\"\\n      }), \\\" 调用 MCP。这就是 tool，是个被调用的东西。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"另外就 RAG 这个东西总感觉最近风头已经过了。总觉得没理由做好用，瓶颈在向量相似度计算方式上，因为到客户端的相似度计算阶段是简单的线性的数学方法，拟合空间极其有限。前期 embedding 生成模型怎么优化都救不了。新生成的两段 Embedding 等于两个东西之前没有上下文信息也不存在注意力映射一类的，直接线性计算个几层太简单了。如果要做基于注意力机制的相似度推理，检索速度就不行。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",\"info\",{\"_5\":99,\"_10\":100,\"_101\":102,\"_103\":104},296,13,\"imgs\",21,\"pages\",30,[106,111,118,122,126,131,138,142,145,149,157,161,164],{\"_107\":26,\"_108\":109},\"name\",\"memoIds\",[24,110],\"2023-11-08 01:30:55\",{\"_107\":35,\"_108\":112},[33,113,114,115,116,117],\"2024-10-16 18:36:24\",\"2024-08-23 08:18:14\",\"2023-11-06 21:20:06\",\"2023-10-29 01:13:43\",\"1980-01-01 00:48:28\",{\"_107\":119,\"_108\":120},\"字体\",[121],\"2025-07-31 02:40:38\",{\"_107\":123,\"_108\":124},\"动画\",[125],\"2025-07-25 00:48:53\",{\"_107\":127,\"_108\":128},\"游戏\",[129,130],\"2025-01-05 00:51:17\",\"2024-12-08 00:12:16\",{\"_107\":132,\"_108\":133},\"沉思\",[134,135,136,137],\"2024-02-28 17:24:54\",\"2024-02-22 15:36:59\",\"2024-02-13 16:01:25\",\"2024-02-09 00:34:23\",{\"_107\":139,\"_108\":140},\"obsidian\",[141],\"2024-02-18 01:19:32\",{\"_107\":143,\"_108\":144},\"五笔输入法\",[141],{\"_107\":146,\"_108\":147},\"书\",[148],\"2024-02-16 00:17:38\",{\"_107\":150,\"_108\":151},\"工具\",[152,153,154,155,156],\"2023-12-27 18:09:43\",\"2023-11-29 03:12:05\",\"2023-11-21 00:57:14\",\"2023-11-02 22:20:54\",\"2023-08-30\",{\"_107\":158,\"_108\":159},\"故事\",[160],\"2023-12-10 06:42:56\",{\"_107\":162,\"_108\":163},\"漫画\",[115],{\"_107\":165,\"_108\":166},\"mdx\",[167],\"2023-11-05 21:04:56\",\"source\",\"SSG\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>