<!DOCTYPE html><html lang="zh"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.25, maximum-scale=5.0"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EDE15EB3W8"></script><title>Sansui - Memos</title><meta name="description" content="Micro-blogging and short thoughts"/><link rel="modulepreload" href="/assets/manifest-4c8363cb.js"/><link rel="modulepreload" href="/assets/entry.client-DkTTQJrl.js"/><link rel="modulepreload" href="/assets/chunk-JMJ3UQ3L-BVFOw7ai.js"/><link rel="modulepreload" href="/assets/index-HqdIF0eP.js"/><link rel="modulepreload" href="/assets/root-C0ep9fuI.js"/><link rel="modulepreload" href="/assets/i18nInstance-DPKwMV5N.js"/><link rel="modulepreload" href="/assets/i18n-C8hHMX00.js"/><link rel="modulepreload" href="/assets/RootLayout-CHttVE2X.js"/><link rel="modulepreload" href="/assets/throttle-DwQFwEus.js"/><link rel="modulepreload" href="/assets/index-CEQRVl7u.js"/><link rel="modulepreload" href="/assets/use-appstate-wXf1X0hJ.js"/><link rel="modulepreload" href="/assets/memos-D_qq4EKy.js"/><link rel="modulepreload" href="/assets/memos-DHVJSfVD.js"/><link rel="modulepreload" href="/assets/use-search-CGJ_0Tiw.js"/><link rel="modulepreload" href="/assets/MDXComponent-BzBGnsZ7.js"/><link rel="modulepreload" href="/assets/use-date-i18n-CH95KIPY.js"/><script>
              (function() {
                var theme = localStorage.getItem("theme");
                if (theme === "system" || !theme) {
                  theme = window.matchMedia("(prefers-color-scheme: dark)").matches
                    ? "dark" : "light";
                }
                console.debug("theme", theme);
                document.documentElement.classList.add(theme);
              })();
            </script><link rel="stylesheet" href="/assets/root-DLwv1eWL.css"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-EDE15EB3W8', {
                page_path: window.location.pathname,
              });
            </script></head><body><div id="initial-progress" style="position:fixed;top:0;left:0;height:2px;width:0;background:var(--accent);z-index:9999;animation:progressLoading 3s ease-out forwards"></div><!--$?--><template id="B:0"></template><!--/$--><section class="bg-bg/90 fixed inset-0 z-8 h-full w-full overflow-auto backdrop-blur-[6px] transition-all duration-500 ease-[cubic-bezier(0.46,0,0.08,1.11)] pointer-events-none opacity-0 "><div class="relative mx-auto pt-32 pb-23 text-center font-bold"><h1 class="
    transition-all duration-1000 ease-out transform
    delay-0
    opacity-0 -translate-y-8
  "><span class="relative inline-block">SANSUI的博客<span class="bg-accent-hover absolute bottom-0 left-0 -z-10 h-[0.5em] w-full rounded-[0.5em] mix-blend-overlay"></span></span></h1><div class="mt-8 
    transition-all duration-1000 ease-out transform
    delay-100
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110">系统外观</span></div><div class="mt-4 
    transition-all duration-1000 ease-out transform
    delay-200
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110"><a href="/categories" data-discover="true">分类标签</a></span></div><div class="mt-4 
    transition-all duration-1000 ease-out transform
    delay-300
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110"><a href="/atom.xml">RSS</a></span></div><div class="pt-12 text-[10px] font-normal 
    transition-all duration-1000 ease-out transform
    delay-400
    opacity-0 -translate-y-8
  "><div class="my-4 flex items-center justify-center"><a href="https://github.com/sansui233" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="mailto:sansuilnm@gmail.com" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail" aria-hidden="true"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"></path><rect x="2" y="4" width="20" height="16" rx="2"></rect></svg></a><a href="/rss" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss" aria-hidden="true"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></div><div class="mx-auto my-4 leading-relaxed">© Sansui 2026<br/>All rights reserved</div></div></div><div class="fixed top-5.5 right-5 z-5 h-5 w-6"><div class="flex flex-col justify-between cursor-pointer " style="width:1rem;height:1rem" aria-expanded="true" aria-label="Toggle menu"><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-0"></div><div class="relative h-0.5 w-full"><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-45"></div><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out -rotate-45"></div></div><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-0"></div></div></div></section><header class="bg-bg/60 fixed z-10 box-content flex h-15.75 w-full items-center justify-between backdrop-blur-[6px] transition-transform duration-500 ease-out translate-y-0  border-ui-line-gray-2 border-b"><div class="w-52.5 flex-auto items-center justify-start font-semibold max-md:w-25"><a class="flex items-center px-4" href="/" data-discover="true"><svg fill="currentColor" id="flat-neko" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72" width="36" class="shrink-0"><path d="m68.24,44.97c.54-.13.86-.68.73-1.21m0,0c-.13-.54-.68-.86-1.21-.73l-4.61,1.15c1.06-5.18.9-11.77-1.14-20.18,0-7-1.45-14.23-3.24-14.91-1.99-.75-11.76,5.91-12.76,8.91-7-2-13-2-20,0-1-3-10.77-9.66-12.76-8.91-1.79.67-3.24,7.91-3.24,14.91-2.05,8.41-2.2,15-1.14,20.18l-4.61-1.15c-.54-.13-1.08.19-1.21.73-.13.54.19,1.08.73,1.21l5.64,1.41c.33,1.14.72,2.21,1.18,3.2l-4.67.42c-.55.05-.96.54-.91,1.09.05.52.48.91,1,.91.03,0,.06,0,.09,0l5.49-.5c.44.75.92,1.46,1.42,2.11l-4.32,1.44c-.52.17-.81.74-.63,1.26.14.42.53.68.95.68.1,0,.21-.02.32-.05l5.08-1.69c6.8,7.11,17.32,7.75,21.6,7.75s14.8-.63,21.6-7.75l5.08,1.69c.11.04.21.05.32.05.42,0,.81-.26.95-.68.17-.52-.11-1.09-.63-1.26l-4.32-1.44c.51-.66.98-1.36,1.42-2.11l5.49.5s.06,0,.09,0c.51,0,.95-.39,1-.91.05-.55-.36-1.04-.91-1.09l-4.67-.42c.45-.99.84-2.06,1.18-3.2l5.64-1.41m-47.24,1.03c-5-1-7-5-6-10,.81-4.04,4.59-7.63,9-7,4.39.63,6.81,4.04,6.64,8.74-.18,4.98-4.64,9.26-9.64,8.26Zm21.45,1.28c-.64.32-1.36.48-2.09.48-.67,0-1.36-.14-2.01-.41-.94-.39-1.74-1.01-2.35-1.83-.61.81-1.41,1.44-2.35,1.83-1.37.57-2.87.54-4.1-.07-.49-.25-.69-.85-.45-1.34.25-.49.85-.69,1.34-.45.7.35,1.61.36,2.44.02,1.01-.42,1.78-1.28,2.16-2.44.03-.09.08-.17.13-.25-.7-.31-1.18-1.01-1.18-1.82,0-1.1.9-2,2-2s2,.9,2,2c0,.81-.49,1.51-1.18,1.82.05.08.1.16.13.25.38,1.15,1.15,2.02,2.16,2.44.83.34,1.74.34,2.44-.02.49-.25,1.09-.05,1.34.45s.05,1.09-.45,1.34Zm8.55-1.28c-5,1-9.46-3.28-9.64-8.26-.17-4.71,2.25-8.11,6.64-8.74,4.41-.63,8.19,2.96,9,7,1,5-1,9-6,10Z"></path><path d="m26,33c-.55,0-1-.45-1-1,0-.45.3-.81.7-.94-.16-.09-.32-.19-.5-.25-2.2-.81-5.2.19-6.82,3.53-1.6,3.29-1.17,7.39,2.48,8.79,3.31,1.27,7.01-.77,7.53-4.63.35-2.62-.16-4.96-1.41-6.41-.04.51-.46.92-.98.92Z"></path><path d="m53.62,34.34c-.45-.93-1.02-1.66-1.64-2.24-.05.51-.46.9-.98.9-.55,0-1-.45-1-1,0-.4.24-.74.57-.9-1.27-.63-2.63-.72-3.78-.3-2.52.92-3.68,4.05-3.19,7.69.52,3.85,4.23,5.9,7.53,4.63,3.64-1.4,4.07-5.49,2.48-8.79Z"></path></svg><span class="px-2 max-md:hidden">Sansui的博客</span></a></div><nav class="relative flex max-w-[50%] flex-[2_1_auto] items-center justify-evenly tracking-wide max-[580px]:hidden min-[580px]:max-w-97.5"><div class="bg-accent-hover pointer-events-none absolute top-[1.1em] -z-10 h-[0.4em] w-[0.4em] rounded-full" style="opacity:0"></div><div class="bg-accent-hover pointer-events-none absolute top-[1.1em] -z-10 h-[0.4em] rounded-[0.5em] " style="opacity:0"></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 " href="/" data-discover="true">文章</a></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 text-text-primary" href="/memos" data-discover="true">说说</a></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 " href="/about" data-discover="true">关于</a></div></nav><div class="flex w-52.5 flex-auto items-center justify-end max-md:w-25 [&amp;&gt;div]:mr-4"><div class="relative min-w-14.25 text-xl font-semibold min-[580px]:hidden"><div class="absolute -top-2 left-0 w-full pt-10 transition-all duration-300 invisible border-transparent "><a class="text-text-secondary my-2 block px-1 pb-1 pl-2.75 transition-all duration-500 pointer-events-none opacity-0 blur-md " href="/" data-discover="true">文章</a><a class="text-text-secondary my-2 block px-1 pb-1 pl-2.75 transition-all duration-500 pointer-events-none opacity-0 blur-md " href="/about" data-discover="true">关于</a></div><button class="text-text-primary relative flex items-center px-3">说说<svg xmlns="http://www.w3.org/2000/svg" width="1.25em" height="1.25em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down -mr-2" aria-hidden="true"><path d="m6 9 6 6 6-6"></path></svg></button></div><div class="cursor-pointer transition-colors duration-300 hidden  hover:text-accent-hover"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search" aria-hidden="true"><path d="m21 21-4.34-4.34"></path><circle cx="11" cy="11" r="8"></circle></svg></div><div class="mr-5 w-5.5"><div class="flex flex-col justify-between cursor-pointer " style="width:100%;height:1.15rem" aria-expanded="false" aria-label="Toggle menu"><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-100"></div><div class="relative h-0.5 w-full"><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-0"></div><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-0"></div></div><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-100"></div></div></div></div></header><div class="bg-bg-2 flex min-h-screen items-center justify-center"><div class="text-text-gray-2 flex flex-col items-center gap-3"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-circle animate-spin" aria-hidden="true"><path d="M21 12a9 9 0 1 1-6.219-8.56"></path></svg><span class="text-lg font-medium">Cooking...</span><span class="text-text-gray-3 text-sm">等等，卡卡西正在做饭……</span></div></div><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"unstable_optimizeDeps":false,"unstable_subResourceIntegrity":false,"v8_middleware":false,"v8_splitRouteModules":false,"v8_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-4c8363cb.js";
import * as route0 from "/assets/root-C0ep9fuI.js";
import * as route1 from "/assets/RootLayout-CHttVE2X.js";
import * as route2 from "/assets/memos-D_qq4EKy.js";
  
  window.__reactRouterRouteModules = {"root":route0,"components/RootLayout":route1,"routes/memos":route2};

import("/assets/entry.client-DkTTQJrl.js");</script><!--$?--><template id="B:1"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><div class="bg-bg border-ui-line-gray-2 fixed top-13.75 right-0 z-11 m-[0_10px] w-96 overflow-hidden rounded-xl border shadow-[0_0_12px_var(--shadow-bg)] transition-all duration-300 ease-out max-[580px]:max-h-[50%] max-[580px]:w-[96%] pointer-events-none invisible -translate-y-2.5 opacity-0 "><div class="bg-bg sticky top-0 p-4 pb-0"><input type="text" placeholder="搜索你感兴趣的内容，以空格分词" class="bg-bg text-text-primary w-full rounded-none border-none focus:outline-none focus-visible:outline-none"/></div><div class="max-h-[60vh] overflow-y-auto px-4 py-2"><div class="text-sm opacity-50"><div class="text-text-gray overflow-hidden text-sm whitespace-nowrap">输入关键词开始搜索</div></div></div></div></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_179\":-5,\"_180\":-5},\"loaderData\",{\"_3\":4},\"routes/memos\",{\"_5\":6,\"_98\":99,\"_10\":106,\"_177\":178},\"memos\",[7,23,31,40,49,57,65,73,81,90],{\"_8\":9,\"_10\":11,\"_12\":13,\"_14\":15,\"_16\":17,\"_19\":20,\"_21\":22},\"id\",\"2026-01-11 06:42:02\",\"tags\",[],\"imgs_md\",[],\"sourceFile\",\"\",\"csrIndex\",[18,18],0,\"word_count\",594,\"content_jsx\",\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: _jsx(_components.strong, {\\n        children: \\\"综艺/生活\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.a, {\\n        href: \\\"https://www.bilibili.com/video/BV1tfiFBzEhD\\\",\\n        children: \\\"あざとくて何が悪いの？有点心机又如何\\\"\\n      }), \\\" - bilibili 5的人的爱情，突然刷到看了起来……\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.a, {\\n        href: \\\"https://www.bilibili.com/video/BV1tfiFBzEhD\\\",\\n        children: \\\"一个韩国旅游博主的成都丽江之旅\\\"\\n      }), \\\" 这位是真的会拍会剪的。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"看了一下有人在说虾皮的技术更新网页文档，全是滑动交互，感觉是用 three.js 塞了很多3D模型，确实好看。不过说由此说什么等领导审美觉醒不觉醒就不必了，真的想要自己的页面3s打不开吗，打开了第一页啥信息也看不出吗。特如果是做中文设计，要用系统字体以外的字体，可能就不是三秒的问题了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"我有很喜欢的设计师的个站，但对设计师自己做的交互丰富的站有三个很刻板的印象。1是太卡了，用 JS 动画 CPU 爆炸，用 WebGL则是没有 GPU 时 CPU 爆炸，2是响应式容易不注意有一堆问题。其实还有一个是，3是信息密度太低看个什么都要划很多下，看不到重点的信息。有人会觉得硬件过剩，并没有，什么时候办公本都能做 AE 不卡了再来说硬件过剩，什么时候讨厌 Electron 教会解散了再来说硬盘和内存够用。设计是一个会用 10 倍资源去为了实现那 1 倍视觉效果的，就像剪辑里的动画一样，但设计师可不会只想要 1 倍效果，会想要 10 倍。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"最实用且有效率的方式就是，画图，图片排版，做印象效果视差等等也够了。但图片的问题是依旧得拿字体去配图像风格，到中文这边，字体又是一个巨大的坑，一个字体能放一百张图。所以最好是图像的风格也是现代的无衬线字体换个颜色就能配上了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"有设计感的站通常带有强烈的表达倾向，以至于字体语言配图全都是为表达服务的。体验是这样的效果非常酷，但也就意味着不可复用。我觉得把信息量和交互动效平衡做得很好的还算是 flatstudio.jp。他们用得很克制了。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":24,\"_10\":25,\"_12\":26,\"_14\":15,\"_16\":27,\"_19\":29,\"_21\":30},\"2026-01-10 03:19:55\",[],[],[18,28],1,495,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"现在虚拟滚动的纯 JS 方案，或多或少都有 Jitter，我指是所有包括 twitter，只不过 twitter 属于不 resize 一下看不出来。我这个页面也是这样的，resize 和 内部展开后不收起，前向重新滚到时会抖，其余情况不会。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"但是 tanstack 不一样，子元素高度为auto，前向滚动就一定抖……\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"issue 追踪： \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/TanStack/virtual/issues/659\\\",\\n        children: \\\"https://github.com/TanStack/virtual/issues/659\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"他们的算法的问题是：第一，向下滚动后再向上滚动没有占位缓存，只能使用估算值（或子元素的 style）。第二，他们的 overscan 虽然设置了值但其实是一个一个进的，每进一项都在调，这导致一直滚一直在抖。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"不过，如果子元素有明确指定 height ，占位使用子元素的 height 值，这种情况是不会抖的。所以在子元素高度自己在挂载前就算得很准的情况也可以，但复杂排版意味着你还得假挂一下去算高度。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"那，为什么不能是 measure Element 里提前去假挂一下呢？挂完了返回的 DOM 还能真挂。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"浏览器本身有 Scroll anchor 定位，直接挂到视窗前面本来也不会偏移。问题在于虚拟列表的 transform 给偏移了（要怪就怪浏览器没有负坐标吧）。前身滚动时\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"增大窗口 height：对子元素视觉0影响，不造成 jitter。子元素是 absolute transform 定位的。\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"在设定 子元素 transform 的瞬间设定 scrollTop，以批量更新\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"然后就涉及到了 React 这个纯函数祖宗之法的问题，你怎么保证useMemo后可以一起渲染？当 itemHeights 更新后，所有的子元素肯定是下一帧渲染了，但 ScrollTop 是要怎么一起更新的？\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"你不能使用 useEffect 去订阅 itemHeights，因为这个副作用会在子元素渲染完成后才能更新，那就成功 jitter 了。所以，要使用 useLayoutEffect。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":32,\"_10\":33,\"_12\":35,\"_14\":15,\"_16\":36,\"_19\":38,\"_21\":39},\"2026-01-09 03:25:00\",[34],\"社会\",[],[18,37],2,28,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: _jsx(Tag, {\\n        text: \\\"社会\\\",\\n        children: \\\"#社会\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: _jsx(_components.a, {\\n          href: \\\"https://b23.tv/lKNoN9d\\\",\\n          children: \\\"【十分钟解读社会学神书《日常生活中的自我呈现》-哔哩哔哩】\\\"\\n        })\\n      }), \\\"\\\\n\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":41,\"_10\":42,\"_12\":44,\"_14\":15,\"_16\":45,\"_19\":47,\"_21\":48},\"2026-01-08 14:14:49\",[43],\"react\",[],[18,46],3,386,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    blockquote: \\\"blockquote\\\",\\n    code: \\\"code\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    pre: \\\"pre\\\",\\n    span: \\\"span\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"回看 next mdx remote 的实现，当时我是着实不知道是为什么要分 rsc 和非 rsc。我知道 rsc 是服务端渲染的，但难道非 rsc compile 出来的组件就不能服务端渲染了吗。因为我看了下两个组件反序列化的过程可以说是一模一样一致，都是在客户端水合一下。唯一的区别就是非 rsc 把 mdx.js 暴露的全部组件都传了进去，\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsxs(_components.code, {\\n        className: \\\"hljs language-typescript\\\",\\n        children: [_jsx(_components.span, {\\n          className: \\\"hljs-comment\\\",\\n          children: \\\"// Compile Options\\\"\\n        }), \\\"\\\\n\\\", _jsx(_components.span, {\\n          className: \\\"hljs-attr\\\",\\n          children: \\\"providerImportSource\\\"\\n        }), \\\": rsc ? \\\", _jsx(_components.span, {\\n          className: \\\"hljs-literal\\\",\\n          children: \\\"undefined\\\"\\n        }), \\\" : \\\", _jsx(_components.span, {\\n          className: \\\"hljs-string\\\",\\n          children: \\\"'@mdx-js/react'\\\"\\n        }), \\\",\\\\n\\\", _jsx(_components.span, {\\n          className: \\\"hljs-comment\\\",\\n          children: \\\"// 对应 MDXRemote index 里的 \\\"\\n        }), \\\"\\\\n\\\", _jsx(_components.span, {\\n          className: \\\"hljs-keyword\\\",\\n          children: \\\"import\\\"\\n        }), \\\" * \\\", _jsx(_components.span, {\\n          className: \\\"hljs-keyword\\\",\\n          children: \\\"as\\\"\\n        }), \\\" mdx \\\", _jsx(_components.span, {\\n          className: \\\"hljs-keyword\\\",\\n          children: \\\"from\\\"\\n        }), \\\" \\\", _jsx(_components.span, {\\n          className: \\\"hljs-string\\\",\\n          children: \\\"'@mdx-js/react'\\\"\\n        }), \\\"\\\\n\\\", _jsx(_components.span, {\\n          className: \\\"hljs-comment\\\",\\n          children: \\\"// 因为反序列化后的函数字符串可能会调用到 mdx-js 的内容，也就是 useMDXComponent，RSC 不支持，所以序列化前必须指明编译参数。\\\"\\n        }), \\\"\\\\n\\\"]\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"也就是rsc 的组件实现对 mdx-js 零依赖的。所以到底有什么必要在非 RSC 里的组件里把 mdx.js 所有的组件都传进去呢。主要就是是否注入 mdx-js 库里的 \\\", _jsx(_components.code, {\\n        children: \\\"useMDXComponent\\\"\\n      }), \\\"的调用。但不编译能有什么影响呢\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"问了 Gemini，他是这么说的：\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"// 纯 Props 模式，每次用都要传，累死人\\\\n\u003cMDXContent components={{ YouTube, Tweet, Chart, ... }} /\u003e\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"看了一眼 \\\", _jsx(_components.a, {\\n        href: \\\"https://mdxjs.com/docs/using-mdx/#mdx-provider\\\",\\n        children: \\\"MDXProvider\\\"\\n      }), \\\"……其实开头就说得很清楚了：\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.blockquote, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n        children: \\\"You probably don’t need a provider. Passing components is typically  fine. Providers often only add extra weight.\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"意思就是没需求别用……所以这种小东西自己写库就可以了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"给 markdown 自定义语法和渲染，其实就是需要两部分\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"remark 插件（rehype 也行 但我觉得 remark 更简单）\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"component 渲染替换\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: _jsx(Tag, {\\n        text: \\\"react\\\",\\n        children: \\\"#react\\\"\\n      })\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":50,\"_10\":51,\"_12\":52,\"_14\":15,\"_16\":53,\"_19\":55,\"_21\":56},\"2026-01-07 10:26:00\",[],[],[18,54],4,137,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"看到一些说搞 AI 人的科普贴子，一看是部署的不是算法的，感觉有点无奈。学NLP在NLP最火的时候不搞NLP，论文不想写也就算了跟风搞应用也不想搞还能把自己饿死，跟有病一样。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"然后那种精神上想吐感并没有消失，我知道怎么解决但解决不了。不过远离对象一种烦躁的感觉消失了。什么他人即地狱（原意，不是其他人都是恶魔那个意思）。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":58,\"_10\":59,\"_12\":60,\"_14\":15,\"_16\":61,\"_19\":63,\"_21\":64},\"2026-01-06 23:15:00\",[],[],[18,62],5,32,\"\\\"use strict\\\";\\nconst {jsx: _jsx} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    p: \\\"p\\\",\\n    ...props.components\\n  };\\n  return _jsx(_components.p, {\\n    children: \\\"呕……好想吐，很难说是精神原因还是生理原因。我觉得有点偏向于精神上想吐。\\\"\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":66,\"_10\":67,\"_12\":68,\"_14\":15,\"_16\":69,\"_19\":71,\"_21\":72},\"2026-01-06 04:10:28\",[],[],[18,70],6,71,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"草，有瓜\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: _jsx(_components.a, {\\n          href: \\\"\\\",\\n          children: \\\"这是一篇号商无能狂怒的聚集地：This is a gathering place for the incompetence and rage of a number merchant\\\"\\n        })\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"全被删了。有贴子看了一眼风格\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsxs(_components.p, {\\n          children: [\\\"总结：\\\", _jsx(_components.a, {\\n            href: \\\"https://linux.do/t/topic/1408515\\\",\\n            children: \\\"https://linux.do/t/topic/1408515\\\"\\n          })]\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsxs(_components.p, {\\n          children: [\\\"贴子风格：\\\", _jsx(_components.a, {\\n            href: \\\"https://x.com/flyiiawei/status/2008124574379212830\\\",\\n            children: \\\"https://x.com/flyiiawei/status/2008124574379212830\\\"\\n          })]\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: _jsx(_components.a, {\\n            href: \\\"https://linux.do/t/topic/1408358\\\",\\n            children: \\\"https://linux.do/t/topic/1408358\\\"\\n          })\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"怎么传播广的不是骂人就是黄段子……\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",{\"_8\":74,\"_10\":75,\"_12\":76,\"_14\":15,\"_16\":77,\"_19\":79,\"_21\":80},\"2026-01-04 20:32:00\",[43],[],[18,78],7,985,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    a: \\\"a\\\",\\n    code: \\\"code\\\",\\n    h3: \\\"h3\\\",\\n    hr: \\\"hr\\\",\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.p, {\\n      children: [_jsx(Tag, {\\n        text: \\\"react\\\",\\n        children: \\\"#react\\\"\\n      }), \\\" 一个没有预料到的状态管理问题：如果组件层级 A\u003eB\u003eC，A负责获取数据源，C负责渲染。那 State 缓存数据不要给到 B。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"为什么？因为 C 同时应用 A 的更新数据和 B 的缓存数据时，B的缓存数据更新会慢一拍，因为B需要去订阅A的更新再通知C更新 props（useEffect 是异步的）。如果 C 中有 state 的初始化依赖缓存数据，那这个初始化也会慢一拍。导致渲染结果（随着缓存更新）和 C_state（只随初始化更新）不一致。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"可能会想，那 C_state 也去订阅 B 缓存就好了？不行，订阅 B 缓存，C_state 更新也还是比渲染慢一拍。此时如果渲染会更新 C_state，那就和对于 B 的订阅冲突了。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"使用缓存是副作用，谨慎处理副作用。\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"为什么有这么奇葩的结构……因为A和C都是库啊！！只能存到B。好消息是C库自己实现的，改成C库自己存数据，有数据更新后通知B了。但要是真只能写B，C不存数据，那 C 的 props\\\", _jsx(_components.strong, {\\n        children: \\\"需要全部用同步更新的缓存\\\"\\n      }), \\\"。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"这其实提到了一个叫派生状态，知乎上有说，但最终也没提出来解决办法。派生状态至今没有检测。 \\\", _jsx(_components.a, {\\n        href: \\\"https://zhuanlan.zhihu.com/p/349372515\\\",\\n        children: \\\"https://zhuanlan.zhihu.com/p/349372515\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"这是我使用 react-router clientLoader 最大的坑。非常容易遇到反模式。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Lazy import 组件\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"好好了解一下 Lazy 的概念，看 SSG 这种重 SEO 场景首屏能不能用。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"首先是要明白，Lazy 导入的组件必须被 Suspense 包裹，不然会 Throw 一个异常向上报错直到遇到了 Suspense 组件进行一个 fallback。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"其次是分情况\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"函数 await import，以 show State 加载 -\u003e 无首屏，不显示在Dom\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"Lazy import，以 show State 加载 Suspense -\u003e 无首屏，不显示在Dom，用 Lazy 属于多此一举。\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"Lazy import ，以 Suspense 加载 -\u003e 大致能用（Dom 能显示，有短时间不可交互，直到浏览器自动下载完代码分割）\\\"\\n      }), \\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"仅以 Suspense 加载 -\u003e 能用（Dom能显示，显示就能交互，没有代码分割）（RSC核心）\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"对于以上第三个点，“大致能用”是有个坑\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"如果 JS 加载慢，React 在客户端运行时发现代码没到，它可能会判定为“未准备好”，于是\\\", _jsx(_components.strong, {\\n          children: \\\"扔掉\\\"\\n        }), \\\"服务端渲染好的完美 HTML，转而显示 \\\", _jsx(_components.code, {\\n          children: \\\"Suspense\\\"\\n        }), \\\" 的 \\\", _jsx(_components.code, {\\n          children: \\\"fallback\\\"\\n        }), \\\" (即 \\\\\\\"Loading JS...\\\\\\\")。\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.strong, {\\n        children: \\\"需求2\\\"\\n      }), \\\"：需要手动点击后再下载 JS，下载 JS 过程中显示一个 Fallback 。使用 \\\", _jsx(_components.code, {\\n        children: \\\"Lazy import\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"useState\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 可做。\\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 可以让人少写一个 state 三目运算符，显得好看一点，别的没用。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.strong, {\\n        children: \\\"需求3\\\"\\n      }), \\\"： 首屏不加载，但首屏挂载后偷偷下载 JS chunk 之后用。可以直接使用 \\\", _jsx(_components.code, {\\n        children: \\\"useEffect\\\"\\n      }), \\\" 普通 import。但是这边有个问题，这个import的结果是在副作用里，你要暂时存到一个变量才能在需要的时候调用。如果嫌组件存变量占内存，可以 \\\", _jsx(_components.code, {\\n        children: \\\"useEffect\\\"\\n      }), \\\" + 顶层\\\", _jsx(_components.code, {\\n        children: \\\"Lazy import\\\"\\n      }), \\\" + \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"总之： \\\", _jsxs(_components.strong, {\\n        children: [\\\"用 \\\", _jsx(_components.code, {\\n          children: \\\"useEffect\\\"\\n        }), \\\" 触发网络请求，用 \\\", _jsx(_components.code, {\\n          children: \\\"lazy\\\"\\n        }), \\\" 管理组件引用，用 \\\", _jsx(_components.code, {\\n          children: \\\"Suspense\\\"\\n        }), \\\" 处理加载状态。\\\"]\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Suspense\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\" 的本质并不是为了服务 \\\", _jsx(_components.code, {\\n        children: \\\"lazy\\\"\\n      }), \\\" 组件的，它的本质是：\\\", _jsx(_components.strong, {\\n        children: \\\"让组件“暂停”渲染，等待某个异步操作（Promise）完成。\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Suspense 里挂载一个\\\", _jsx(_components.strong, {\\n        children: \\\"异步组件\\\"\\n      }), \\\"，就可以等异步组件有返回后再显示。比如子组件里使用 await fetch 阻塞了结果返回。而Lazy 组件，也这么一种异步组件。\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Suspense 里挂载一个带有 \\\", _jsx(_components.code, {\\n        children: \\\"use hook\\\"\\n      }), \\\" 的组件在 use hook 完成前，都会使用最近的 Suspense。\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"use hook\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"在最新的 React 版本中，推出了 \\\", _jsx(_components.code, {\\n        children: \\\"use\\\"\\n      }), \\\" Hook，它允许你在组件内部直接“解包”一个 Promise。如果 Promise 没完成，它会触发最近的 \\\", _jsx(_components.code, {\\n        children: \\\"Suspense\\\"\\n      }), \\\"。\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":82,\"_10\":83,\"_12\":85,\"_14\":15,\"_16\":86,\"_19\":88,\"_21\":89},\"2026-01-04 03:34:48\",[84],\"博客\",[],[18,87],8,799,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    li: \\\"li\\\",\\n    p: \\\"p\\\",\\n    ul: \\\"ul\\\",\\n    ...props.components\\n  }, {Tag} = _components;\\n  if (!Tag) _missingMdxReference(\\\"Tag\\\", true);\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.p, {\\n      children: [_jsx(Tag, {\\n        text: \\\"博客\\\",\\n        children: \\\"#博客\\\"\\n      }), \\\" 重构记录\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"切换路由框架为 React Router 7 做 SSG。至于为什么……一是 Next.js 虽然比较自动，但真的很慢。主要我做 Memo 页需要混合路由，并不是单纯的 SSG 或者 SPA。\\\\n天知道我为了在 Next.js 12那个基于文件系统的路由框架上整个混合渲染有多麻烦，点个什么都要靠手动劫持路由还要小心状态机防止循环渲染。Suspense 是 AppRouter 出了才有的，感觉也是很不直观。就算现在，也做不到访问 query 时劫持掉静态内容直接显示 CSR 的骨架，一定要闪一下，因为分割渲染方式的入口是组件而不是路由。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"CSS 切换为 tailiwind 预构建。我虽然不喜欢 tailwind 的丑，但是也不太想用 css in js 去水合页面，有构建时水合的开销就算了还有运行时开销。此外原生 css 也混着用。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"markdown 内容用 velite 预构建。这个管线是真的好用，但也不担心类型问题（感谢 zod），rss 和搜索索引构建和应该写哪里的问题也一块解决了。其实还是要自己引入 mdx-js 去做 compile，因为静态 memos 对 markdown 的使用方式非常特殊。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"这个博客非常多的部分都靠预构建，路由自己写是有点麻烦但写好了也是自动生成了不用再动了。我觉得也正是这些预构建的步骤变多了，生成才能快得起来了。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"另外我彻底摒弃了 memos 多个来源混合的预留接口。真的不知道发在哪个 CMS 上，还有谁天天看在博客看即时消息啊。但是啊，如果说有同样的人构建同样的博客，并且允许跨域，那确实是可以把一堆建同样博客的人的消息混在一堆的……\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"巨量 debug。你永远不知道为什么本来工作地好好的 Virtualist 换个框架变 key 后不强制刷新了。我看了很多可变高度 Virtualist 的实现，感觉还是自己的实现使用起来最傻瓜（因为自动布局逻辑简单不了，落泪，状态机很麻烦的）。网上实现全是要手动算一堆高度的，连 fixed 高度也要指定，用起来实在太蠢了。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"Memo 的 Image Browser 用 claude 迁移之后自动做了一个缩略图预览，笑死。感觉这样的话，相册页面也有着落了，但是相册页最麻烦的其实是，Memo 没有缩略图……也就是说需要超大图片展示相册以免自己一边开发着一边狂刷流量。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"SearchEngine 也改了下接口以不限制任何的 searchObj。当然匹配还是有 bug 的，但懒得测试了。以前老担心东西多了搜太慢，现在觉得这个问题永远不用担心，因为网永远更慢……怎么分割索引加快网速比客户端执行时间重要得多。\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"总之，是改了超多的，经常在发呆不知道还要改什么。\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\nfunction _missingMdxReference(id, component) {\\n  throw new Error(\\\"Expected \\\" + (component ? \\\"component\\\" : \\\"object\\\") + \\\" `\\\" + id + \\\"` to be defined: you likely forgot to import, pass, or provide it.\\\");\\n}\\n\",{\"_8\":91,\"_10\":92,\"_12\":93,\"_14\":15,\"_16\":94,\"_19\":96,\"_21\":97},\"2026-01-02 18:39:54\",[],[],[18,95],9,175,\"\\\"use strict\\\";\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = {\\n    code: \\\"code\\\",\\n    p: \\\"p\\\",\\n    pre: \\\"pre\\\",\\n    ...props.components\\n  };\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"tailwind 的局限：做不了出入非对称的动画。\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"The key difference:\\\\n- On hover: width transition has a 0.2s delay (bar appears after moving)\\\\n- On unhover: width transition has NO delay (bar shrinks immediately)\\\\nTailwind's group-hover:before:delay-200 only applies delay on hover, but the transition property itself doesn't change. I need to use CSS to handle this properly since Tailwind can't easily express different transition timings for hover vs unhover states.\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"这是 Claude 说的，我对 tailwind 的了解着实很浅。怎么说，用高层包装的东西就是会感觉有一些受限吧。并且用原生 css，非常非常明显的渲染性能更好，感觉是 DOM 匹配样式表没那么大开销，tailwind 写出来渲染是掉帧的（不应该啊已经算好了为什么要卡）……\\\"\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = props.components || ({});\\n  return MDXLayout ? _jsx(MDXLayout, {\\n    ...props,\\n    children: _jsx(_createMdxContent, {\\n      ...props\\n    })\\n  }) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",\"info\",{\"_5\":100,\"_10\":101,\"_102\":103,\"_104\":105},302,15,\"imgs\",21,\"pages\",31,[107,112,115,122,126,135,139,143,148,155,159,162,166,170,173],{\"_108\":34,\"_109\":110},\"name\",\"memoIds\",[32,111],\"2025-11-16 05:39:33\",{\"_108\":43,\"_109\":113},[41,74,114],\"2023-11-08 01:30:55\",{\"_108\":84,\"_109\":116},[82,117,118,119,120,121],\"2024-10-16 18:36:24\",\"2024-08-23 08:18:14\",\"2023-11-06 21:20:06\",\"2023-10-29 01:13:43\",\"1980-01-01 00:48:28\",{\"_108\":123,\"_109\":124},\"创意\",[125],\"2025-12-28 02:41:52\",{\"_108\":127,\"_109\":128},\"工具\",[129,130,131,132,133,134],\"2025-12-18 02:58:11\",\"2023-12-27 18:09:43\",\"2023-11-29 03:12:05\",\"2023-11-21 00:57:14\",\"2023-11-02 22:20:54\",\"2023-08-30\",{\"_108\":136,\"_109\":137},\"字体\",[138],\"2025-07-31 02:40:38\",{\"_108\":140,\"_109\":141},\"动画\",[142],\"2025-07-25 00:48:53\",{\"_108\":144,\"_109\":145},\"游戏\",[146,147],\"2025-01-05 00:51:17\",\"2024-12-08 00:12:16\",{\"_108\":149,\"_109\":150},\"沉思\",[151,152,153,154],\"2024-02-28 17:24:54\",\"2024-02-22 15:36:59\",\"2024-02-13 16:01:25\",\"2024-02-09 00:34:23\",{\"_108\":156,\"_109\":157},\"obsidian\",[158],\"2024-02-18 01:19:32\",{\"_108\":160,\"_109\":161},\"五笔输入法\",[158],{\"_108\":163,\"_109\":164},\"书\",[165],\"2024-02-16 00:17:38\",{\"_108\":167,\"_109\":168},\"故事\",[169],\"2023-12-10 06:42:56\",{\"_108\":171,\"_109\":172},\"漫画\",[119],{\"_108\":174,\"_109\":175},\"mdx\",[176],\"2023-11-05 21:04:56\",\"source\",\"SSG\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:2"></template><!--/$--></div><script>$RC("B:1","S:1")</script><div hidden id="S:2"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:2","S:2")</script></body></html>