[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_42":43,"_46":47},"post",{"_7":8,"_9":10,"_11":12,"_13":-5,"_14":15,"_16":17,"_22":23,"_24":25,"_26":27,"_28":29,"_30":31,"_33":34,"_35":36,"_40":41},"title","关于 typescript 泛型中返回值类型约束的问题","slug","2023-11-11-typescript-generatic-type-proble-ts2322","date","2023-11-11T14:26:09.000Z","description","draft",false,"metadata",{"_18":19,"_20":21},"readingTime",4,"wordCount",935.6800000000001,"excerpt","最近遇到这么一个需求。\n\n定义一个函数接口，要求其返回值类型是 type A 的任意超集。\n\n于是我按直觉写下了：\ntype A  = { a: string }\ntype FuncA  = <T extends A>() => T\nconst f: FuncA = () => {\n  return { a: \"ok\" } \n}\n\n人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。\n这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：\nType '","content_html","<p>最近遇到这么一个需求。</p>\n<blockquote>\n<p>定义一个函数接口，要求其返回值类型是 type A 的任意超集。</p>\n</blockquote>\n<p>于是我按直觉写下了：</p>\n<pre><code class=\"language-typescript\">type A  = { a: string }\ntype FuncA  = &#x3C;T extends A>() => T\nconst f: FuncA = () => {\n  return { a: \"ok\" } \n}\n</code></pre>\n<p>人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。</p>\n<p>这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：</p>\n<pre><code class=\"language-text\">Type '() => A' is not assignable to type 'FuncA'.\n  Type 'A' is not assignable to type 'T'.\n    'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322)\n</code></pre>\n<p>这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如</p>\n<pre><code class=\"language-ts\">function foo(){\n  return \"1\"\n} // 自动推断出函数的具体签名为 () => string\n</code></pre>\n<p>那为什么上面的报错例子，不能做这样的推断呢？</p>\n<pre><code class=\"language-ts\">type A  = { a: string }\ntype FuncA  = &#x3C;T extends A>() => T\nconst f: FuncA = () => {\n  return { a: \"ok\" } \n} \n/* 推断出具体的签名类似于\n() => {\n  a: string;\n  [name: string]: any\n}\n*/\n</code></pre>\n<p>也就是说，a 是必选属性，其他属性全是 optional。</p>\n<p>（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）</p>\n<p>当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？</p>\n<p>好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……</p>\n<p>我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？</p>\n<p>在 typescript 的 <a href=\"https://github.com/microsoft/TypeScript/issues/50027\">github issue</a> 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：</p>\n<blockquote>\n<p>如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 <code>()=>{}</code> ，没有prop 属性。</p>\n</blockquote>\n<p>但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：</p>\n<pre><code class=\"language-ts\">type A = () => void;\ntype B = () => void;\n\n// 类型签名为 &#x3C;T extends A | B>(value: T) => T 的实现\nfunction f1&#x3C;T extends A | B>(value: T): T {\n  return () => {};  // 推断出 T 此时是 typeof ()=>{}，也就是 ()=>{}\n}\n\nlet f: any= ()=>{}\nf.prop = \"haha\"\n\nf1(f) // 这里传参报错，因为 typeof f 和 typeof ()=>{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错\n</code></pre>\n<p>当然上面的例子返回值类型已经定了是 <code>typeof ()=>{}</code>，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。</p>\n<blockquote>\n<p>什么是 subtype？T extends A，T 就是 A 的 subtype</p>\n</blockquote>\n<p>这又引发了另一个问题：这和函数重载有什么区别？</p>\n<p>当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 <code>A</code>。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。</p>\n<p>但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。</p>\n<p>如果要解决开头的问题，大概是以下三个思路：</p>\n<ul>\n<li>定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 <code>[name: string]: any</code>。</li>\n<li>考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。</li>\n<li>根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样</li>\n</ul>\n<pre><code class=\"language-typescript\">type Extend&#x3C;T extends object> = {\n  [name: string]: any\n} &#x26; {\n  [K in keyof T]: T[K]\n}\n\ntype A  = {a: string}\ntype FuncA  = () => Extend&#x3C;A>\nconst f: FuncA = () => {\n  return { a: \"ok\", b:\"extra\"} \n} \nf().a // a is string\nf().b // b is any\n</code></pre>\n<p>总之，在目前的 typescript 中，<strong>返回值类型不能是泛型</strong>。</p>\n<p>当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。</p>\n<p>现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。</p>\n<p>说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。</p>\n<p>还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。</p>\n<hr>\n<p>可能没用的参考：</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint\">typescript - How to fix TS2322: \"could be instantiated with a different subtype of constraint 'object'\"? - Stack Overflow</a></li>\n<li><a href=\"https://github.com/microsoft/TypeScript/issues/50027\">Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript</a></li>\n</ul>","content_jsx","const{Fragment:n,jsx:s,jsxs:e}=arguments[0];function _createMdxContent(l){const a={a:\"a\",blockquote:\"blockquote\",code:\"code\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",ul:\"ul\",...l.components};return e(n,{children:[s(a.p,{children:\"最近遇到这么一个需求。\"}),\"\\n\",e(a.blockquote,{children:[\"\\n\",s(a.p,{children:\"定义一个函数接口，要求其返回值类型是 type A 的任意超集。\"}),\"\\n\"]}),\"\\n\",s(a.p,{children:\"于是我按直觉写下了：\"}),\"\\n\",s(a.pre,{children:e(a.code,{className:\"hljs language-typescript\",children:[s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" A  = { \",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-built_in\",children:\"string\"}),\" }\\n\",s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\"  = <T \",s(a.span,{className:\"hljs-keyword\",children:\"extends\"}),\" A>\",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" T\\n\",s(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",s(a.span,{className:\"hljs-attr\",children:\"f\"}),\": \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\" = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" {\\n  \",s(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" { \",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-string\",children:'\"ok\"'}),\" } \\n}\\n\"]})}),\"\\n\",s(a.p,{children:\"人来看非常简单知道是什么意思，就是返回值包含所有 a 的属性，其他属性全是可有可无的。\"}),\"\\n\",s(a.p,{children:\"这段代码扔给 GPT，它也看不出什么毛病。但事实上，在 return 时报了一个错：\"}),\"\\n\",s(a.pre,{children:s(a.code,{className:\"hljs language-text\",children:\"Type '() => A' is not assignable to type 'FuncA'.\\n  Type 'A' is not assignable to type 'T'.\\n    'A' is assignable to the constraint of type 'T', but 'T' could be instantiated with a different subtype of constraint 'A'.ts(2322)\\n\"})}),\"\\n\",s(a.p,{children:\"这个报错非常的不 helpful。因为平时， typescript 可以根据返回值推测出具体函数标注。比如\"}),\"\\n\",s(a.pre,{children:e(a.code,{className:\"hljs language-ts\",children:[s(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",s(a.span,{className:\"hljs-title function_\",children:\"foo\"}),\"(\",s(a.span,{className:\"hljs-params\"}),\"){\\n  \",s(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",s(a.span,{className:\"hljs-string\",children:'\"1\"'}),\"\\n} \",s(a.span,{className:\"hljs-comment\",children:\"// 自动推断出函数的具体签名为 () => string\"}),\"\\n\"]})}),\"\\n\",s(a.p,{children:\"那为什么上面的报错例子，不能做这样的推断呢？\"}),\"\\n\",s(a.pre,{children:e(a.code,{className:\"hljs language-ts\",children:[s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" A  = { \",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-built_in\",children:\"string\"}),\" }\\n\",s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\"  = <T \",s(a.span,{className:\"hljs-keyword\",children:\"extends\"}),\" A>\",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" T\\n\",s(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",s(a.span,{className:\"hljs-attr\",children:\"f\"}),\": \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\" = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" {\\n  \",s(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" { \",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-string\",children:'\"ok\"'}),\" } \\n} \\n\",s(a.span,{className:\"hljs-comment\",children:\"/* 推断出具体的签名类似于\\n() => {\\n  a: string;\\n  [name: string]: any\\n}\\n*/\"}),\"\\n\"]})}),\"\\n\",s(a.p,{children:\"也就是说，a 是必选属性，其他属性全是 optional。\"}),\"\\n\",s(a.p,{children:\"（先不讨论 Object 的 key 可以是 Symbol，只是为了看起来好理解，我只写了 string。要写全这里又要多写一个类型推断。）\"}),\"\\n\",s(a.p,{children:\"当然这里又引发了另一个问题：你为什么不直接把 type A 定义附加任意可选属性？\"}),\"\\n\",s(a.p,{children:\"好问题，这是一个正常的解决 TS2322 问题的思路。但是我就是想知道为什么泛型推断不能直接做这个……\"}),\"\\n\",s(a.p,{children:\"我查了很多资料，没有人完美解释这个问题。但有一个相似的问题：如何让参数和返回值持有相同的泛型类型？\"}),\"\\n\",e(a.p,{children:[\"在 typescript 的 \",s(a.a,{href:\"https://github.com/microsoft/TypeScript/issues/50027\",children:\"github issue\"}),\" 里有详细的案例说明，务必看看，很好懂，说是故意这么设计的。这里我将理由简短概括如下：\"]}),\"\\n\",e(a.blockquote,{children:[\"\\n\",e(a.p,{children:[\"如果 f 是上有一个额外的属性 prop，编译器如果推导出了返回值类型成 typeof f。之后你调用 f.prop，静态编译不会报错，但实际上有一个 runtime error，因为你的真实的返回值只是一个 \",s(a.code,{children:\"()=>{}\"}),\" ，没有prop 属性。\"]}),\"\\n\"]}),\"\\n\",s(a.p,{children:\"但个人觉得这里静态编译应该报错，并不是一个 runtime 错误。前面说了，typescript 可以对返回值进行静态的类型的检查。以上面 issue 为例，理想的报错设计是长这样：\"}),\"\\n\",s(a.pre,{children:e(a.code,{className:\"hljs language-ts\",children:[s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" A = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" \",s(a.span,{className:\"hljs-built_in\",children:\"void\"}),\";\\n\",s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" B = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" \",s(a.span,{className:\"hljs-built_in\",children:\"void\"}),\";\\n\\n\",s(a.span,{className:\"hljs-comment\",children:\"// 类型签名为 <T extends A | B>(value: T) => T 的实现\"}),\"\\n\",s(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" f1<T \",s(a.span,{className:\"hljs-keyword\",children:\"extends\"}),\" A | B>(\",s(a.span,{className:\"hljs-attr\",children:\"value\"}),\": T): T {\\n  \",s(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" {};  \",s(a.span,{className:\"hljs-comment\",children:\"// 推断出 T 此时是 typeof ()=>{}，也就是 ()=>{}\"}),\"\\n}\\n\\n\",s(a.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",s(a.span,{className:\"hljs-attr\",children:\"f\"}),\": \",s(a.span,{className:\"hljs-built_in\",children:\"any\"}),\"= \",s(a.span,{className:\"hljs-function\",children:\"()=>\"}),\"{}\\nf.\",s(a.span,{className:\"hljs-property\",children:\"prop\"}),\" = \",s(a.span,{className:\"hljs-string\",children:'\"haha\"'}),\"\\n\\n\",s(a.span,{className:\"hljs-title function_\",children:\"f1\"}),\"(f) \",s(a.span,{className:\"hljs-comment\",children:\"// 这里传参报错，因为 typeof f 和 typeof ()=>{} 不一致。本质上就是 ts2322 描述的问题，但不应该在上面报错\"}),\"\\n\"]})}),\"\\n\",e(a.p,{children:[\"当然上面的例子返回值类型已经定了是 \",s(a.code,{children:\"typeof ()=>{}\"}),\"，返回值再标注 T 显得十分多此一举。但是 f1 对只是对这个函数签名的一种实现。完全可以实现对这个函数签名有不同的实现，返回不同的 subtype。\"]}),\"\\n\",e(a.blockquote,{children:[\"\\n\",s(a.p,{children:\"什么是 subtype？T extends A，T 就是 A 的 subtype\"}),\"\\n\"]}),\"\\n\",s(a.p,{children:\"这又引发了另一个问题：这和函数重载有什么区别？\"}),\"\\n\",e(a.p,{children:[\"当然有区别啊，最大的区别就是我能定义一个统一的函数接口，只要返回值满足最基本的约束 \",s(a.code,{children:\"A\"}),\"。但可以是返回不同的 subtype，实现也分开写到不同的文件里，类似于 oop 语言中返回所有某基类的派生类。这才是完全体。\"]}),\"\\n\",s(a.p,{children:\"但现在的 typescript 完全做不到这一点，返回值只能是一个非常具体的 type，要么就抛出一个毫无说服力的 ts2322 错误。\"}),\"\\n\",s(a.p,{children:\"如果要解决开头的问题，大概是以下三个思路：\"}),\"\\n\",e(a.ul,{children:[\"\\n\",e(a.li,{children:[\"定义 A 时，把所有可能要用到的属性都写到可选属性里，或直接 \",s(a.code,{children:\"[name: string]: any\"}),\"。\"]}),\"\\n\",s(a.li,{children:\"考虑业务场景，其他未知属性不留下会影响到什么吗。99% 的场景是没有必要的，也就是说这个需求就是没意义的。剩下的 1% 我没有遇到/想到。\"}),\"\\n\",s(a.li,{children:\"根据输入参数的 T 写一个类型推导，手动将返回的类型设置为 a 的具体扩展类型。类似这样\"}),\"\\n\"]}),\"\\n\",s(a.pre,{children:e(a.code,{className:\"hljs language-typescript\",children:[s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" \",s(a.span,{className:\"hljs-title class_\",children:\"Extend\"}),\"<T \",s(a.span,{className:\"hljs-keyword\",children:\"extends\"}),\" \",s(a.span,{className:\"hljs-built_in\",children:\"object\"}),\"> = {\\n  [\",s(a.span,{className:\"hljs-attr\",children:\"name\"}),\": \",s(a.span,{className:\"hljs-built_in\",children:\"string\"}),\"]: \",s(a.span,{className:\"hljs-built_in\",children:\"any\"}),\"\\n} & {\\n  [K \",s(a.span,{className:\"hljs-keyword\",children:\"in\"}),\" keyof T]: T[K]\\n}\\n\\n\",s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" A  = {\",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-built_in\",children:\"string\"}),\"}\\n\",s(a.span,{className:\"hljs-keyword\",children:\"type\"}),\" \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\"  = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" \",s(a.span,{className:\"hljs-title class_\",children:\"Extend\"}),\"<A>\\n\",s(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",s(a.span,{className:\"hljs-attr\",children:\"f\"}),\": \",s(a.span,{className:\"hljs-title class_\",children:\"FuncA\"}),\" = \",s(a.span,{className:\"hljs-function\",children:\"() =>\"}),\" {\\n  \",s(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" { \",s(a.span,{className:\"hljs-attr\",children:\"a\"}),\": \",s(a.span,{className:\"hljs-string\",children:'\"ok\"'}),\", \",s(a.span,{className:\"hljs-attr\",children:\"b\"}),\":\",s(a.span,{className:\"hljs-string\",children:'\"extra\"'}),\"} \\n} \\n\",s(a.span,{className:\"hljs-title function_\",children:\"f\"}),\"().\",s(a.span,{className:\"hljs-property\",children:\"a\"}),\" \",s(a.span,{className:\"hljs-comment\",children:\"// a is string\"}),\"\\n\",s(a.span,{className:\"hljs-title function_\",children:\"f\"}),\"().\",s(a.span,{className:\"hljs-property\",children:\"b\"}),\" \",s(a.span,{className:\"hljs-comment\",children:\"// b is any\"}),\"\\n\"]})}),\"\\n\",e(a.p,{children:[\"总之，在目前的 typescript 中，\",s(a.strong,{children:\"返回值类型不能是泛型\"}),\"。\"]}),\"\\n\",s(a.p,{children:\"当然这样也失去了扩展的类型检查，等于是用了函数的签名来检查的，和返回值的类型一点关系也没有。\"}),\"\\n\",s(a.p,{children:\"现在 typescript 的静态检查器其实已经做了一些运行时的功能，比如条件语句判断以排除属性。但是，这些像运行时一样的检查只在静态类型不明确时才起作用。就这个 if，我已经遇到了好几次无法判断的 bug ，清空缓存并重启才恢复。\"}),\"\\n\",s(a.p,{children:\"说回第二点，既然你允许传了任意值，也就说明在你这个库中，你也不知道其他附加值具体是拿来干什么的，大多无非遍历一下再过滤一下。如果是静态类型检查器来遍历，诶诶扩展属性怎么全是 any。最终还得用 JS 的运行时来做这个事情……所以有拿来做什么的话早就在 A 里增加 optional 属性了。这也是为什么说 99% 的场景这个需求其实不存在。\"}),\"\\n\",s(a.p,{children:\"还有一个更重要的原因，那就是，ts 的类型体操，实在太他妈难写了。\"}),\"\\n\",s(a.hr,{}),\"\\n\",s(a.p,{children:\"可能没用的参考：\"}),\"\\n\",e(a.ul,{children:[\"\\n\",s(a.li,{children:s(a.a,{href:\"https://stackoverflow.com/questions/56505560/how-to-fix-ts2322-could-be-instantiated-with-a-different-subtype-of-constraint\",children:\"typescript - How to fix TS2322: \\\"could be instantiated with a different subtype of constraint 'object'\\\"? - Stack Overflow\"})}),\"\\n\",s(a.li,{children:s(a.a,{href:\"https://github.com/microsoft/TypeScript/issues/50027\",children:\"Could be instantiated with a different subtype of constraint · Issue #50027 · microsoft/TypeScript\"})}),\"\\n\"]})]})}return{default:function(n={}){const{wrapper:e}=n.components||{};return e?s(e,{...n,children:s(_createMdxContent,{...n})}):_createMdxContent(n)}};","toc",[],"tags",[32],"typescript","categories","学习","keywords",[32,37,38,39],"ts","generic type","ts2322，泛型约束","permalink","/posts/2023-11-11-typescript-generatic-type-proble-ts2322","prevPost",{"_7":44,"_9":45},"大概是关于五笔打字更慢的一点碎碎念？","thoughts-about-wubi-im","nextPost",{"_7":48,"_9":49},"重读《小王子》","2023-10-09-the-little-prince-review"]
