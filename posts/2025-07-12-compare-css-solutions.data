[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_105":106,"_109":110},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_17":18,"_23":24,"_25":26,"_27":28,"_29":30,"_93":94,"_96":97,"_98":99,"_103":104},"title","踩了一圈 CSS 构建方案的坑","slug","2025-07-12-compare-css-solutions","date","2025-07-12T04:49:09.000Z","description","前端代码中质量最薄弱的一环","draft",false,"metadata",{"_19":20,"_21":22},"readingTime",5,"wordCount",1394.88,"excerpt","css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）\nCSS类复用粒度\n我自己把 css 选择器（类）的复用粒度分三个层级。\n组件类\n粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字\n.wrapper\n.container\n.list-item\n\n组件化的选择器下面通常有很多条的 css。\n功能类\n通常是共用的样式或状态，比如\n.open\n.close\n.ligh","content_html","<p>css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）</p>\n<h2>CSS类复用粒度</h2>\n<p>我自己把 css 选择器（类）的复用粒度分三个层级。</p>\n<h3>组件类</h3>\n<p>粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字</p>\n<pre><code class=\"language-css\">.wrapper\n.container\n.list-item\n</code></pre>\n<p>组件化的选择器下面通常有很多条的 css。</p>\n<h3>功能类</h3>\n<p>通常是共用的样式或状态，比如</p>\n<pre><code class=\"language-css\">.open\n.close\n.light\n.dark\n.glass-effect\n</code></pre>\n<p>这个看起来好像和组件类不冲突，但硬说的话组件类其实应该是这样</p>\n<pre><code class=\"language-css\">.container.open { 此处将 .open 的所有样式全覆盖 }\n.container.close { 此处将 .close 的所有样式全覆盖 }\n.container.light { 此处将 .light 的所有样式全覆盖 }\n.container.dark { 此处将 .dark 的所有样式全覆盖 }\n</code></pre>\n<p>组件类的状态严格在组件的 scope 下。功能类则是可以不限 Scope 的复用。</p>\n<p>这 CSS 容易混乱的根源。在工程维护角度，功能类是最不敢乱动的类，不知道动了后哪里样式就会出问题。但在设计角度，用功能类复用一些状态又确实很方便，统一设计也好用。比如增加统一的圆角、描边、阴影样式。</p>\n<p>功能类的优缺点是一体两面——图像的只有主观的好看与否，没有客观的对错。</p>\n<h3>原子类</h3>\n<p>定义海量常用的基础样式类，在 class 上直接写类名就能获得对应效果。就是 tailwind css。</p>\n<p>原子类相较于功能类粒度更小，也不会轻易改动 css 属性。</p>\n<pre><code class=\"language-css\">.flex\n.col-1\n.text-sm\n</code></pre>\n<h2>方案</h2>\n<p>通常来说，一个库的样式会着重在一个某一个粒度上。</p>\n<h3>原生 css</h3>\n<p>用原生 css 时通常会以 <strong>组件化</strong> 的粒度为主，带极少的功能类。现在配合 css 变量使用。早期的网页简单，一个 CSS 文件就能搞定全站，设计上并没有考虑项目变得越来越复杂后的实践。</p>\n<p><strong>优点</strong>：性能好，扁平的结构利好小项目。适合写研究新样式。</p>\n<p><strong>缺点</strong>：过于扁平，大量工程化后易屎山，存在样式与 DOM 分离带来的维护混乱。</p>\n<h3>SCSS</h3>\n<p>古法预处理器，可能多层嵌套 css，可组合。是 <strong>组件化</strong> 的粒度。在 CSS.module 出来前，用 SCSS 分割 Scope 挺好用。</p>\n<p><strong>优点</strong>：结构非常清晰</p>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>编译后的选择器很长一串，从浏览器渲染角度，匹配DOM是耗性能的</li>\n<li>难以应对复杂项目 DOM 结构的改变，需要考虑扁平化 + 命名，但这样做和原生 CSS 的维护体验也不相上下。</li>\n</ol>\n<h3>CSS Module</h3>\n<p>CSS Module 是完全 <strong>组件化</strong> 的粒度。相比起 SCSS 的样式与 DOM 分离，CSS Module 为组件内部样式耦合，组件间样式分离。</p>\n<p><strong>优点：</strong> 在组件粒度分割合理的情况下，清晰易维护。</p>\n<p><strong>缺点</strong>：依赖预构建，写类名写起来太磨叽了。整体我用得不多没法评价。</p>\n<pre><code class=\"language-jsx\">const Button = () => {\n  return (\n    &#x3C;button className={styles.button}>\n      Click me\n    &#x3C;/button>\n  );\n};\n</code></pre>\n<h3>BootStrap</h3>\n<p><strong>组件化</strong> 为主，少量原子化修饰的预制样式库，拿来即用是不错的。早期 CSS 框架大多是指预制样式，和预构建的库有本质区别。</p>\n<h3>Tailwind css</h3>\n<p>完全原子化的神奇之库，通过编译可以有功能类和组件类。它更像是重新定义了 css 语法。</p>\n<p><strong>优点</strong></p>\n<ol>\n<li>灵活，快，好看</li>\n<li>工具链齐全，可以裁剪掉不用的原子类。</li>\n</ol>\n<p><strong>缺点</strong></p>\n<ol>\n<li>稍微要写复杂一点的样式，DOM 就会被一大堆 class 埋没。</li>\n<li>从浏览器渲染角度，匹配、合并大量 CSS 样式是需要更多性能开销的</li>\n<li>要做到同种样式的复用，必须组合原子类，变成功能类或组件类，否则维护起来相当麻烦。这似乎违背了用 tailwind css 的初衷，熟悉了 css 的不如直接自己用 css 手撮功能类和组件类。</li>\n<li>其实我是 tailwind 黑，嗯。但无法否认开发时确实很快很方便。</li>\n</ol>\n<pre><code class=\"language-jsx\">function Card({ title, description, imageUrl, imageAlt }) {\n  return (\n    &#x3C;div className=\"max-w-sm rounded overflow-hidden shadow-lg\">\n      &#x3C;img className=\"w-full\" src={imageUrl} alt={imageAlt} />\n      &#x3C;div className=\"px-6 py-4\">\n        &#x3C;div className=\"font-bold text-xl mb-2\">{title}&#x3C;/div>\n        &#x3C;p className=\"text-gray-700 text-base\">{description}&#x3C;/p>\n      &#x3C;/div>\n      &#x3C;div className=\"px-6 pt-4 pb-2\">\n        &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#photography&#x3C;/span>\n        &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#travel&#x3C;/span>\n        &#x3C;span className=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#adventure&#x3C;/span>\n      &#x3C;/div>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>原生 css in js</h3>\n<p>指 JS Object 转译为 CSS。由于写起来太不像 CSS，复杂的功能写起来过于不直观 ，我直接 PASS。</p>\n<pre><code class=\"language-jsx\">const InlineStyleExample = () => {\n  const myStyle = {\n    color: 'blue',\n    backgroundColor: 'lightgray',\n    padding: '10px',\n    borderRadius: '5px'\n  };\n\n  return (\n    &#x3C;div style={myStyle}>\n      &#x3C;p style={{ fontSize: '18px', fontWeight: 'bold' }}>\n        This text is styled with inline CSS.\n      &#x3C;/p>\n    &#x3C;/div>\n  );\n};\n</code></pre>\n<h3>Styled-components</h3>\n<p><strong>组件化</strong>的 CSS in JS 方案，写起来像 CSS 实际是 JS。支持客户端动态修改 CSS 具体属性（其他方案做状态改变主要依靠 selector 的匹配）</p>\n<p><strong>优点</strong>：</p>\n<p>灵活好拓展，比如主题管理不仅仅是颜色，还可以是图片资源一类的。</p>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>因为是 JS 转 CSS，服务器编译慢和客户端渲染慢得选一个</li>\n<li>React 的 useContext 要被废弃了，而 styled-components 严重依赖此 hook，导致进入了维护状态。JS 框架发展太快了。</li>\n</ol>\n<pre><code class=\"language-jsx\">import styled from 'styled-components';\n\n// Create a styled button component\nconst StyledButton = styled.button`\n  background-color: blue;\n  font-size: 16px;\n  padding: 10px 20px;\n  border-radius: 5px;\n\n  &#x26;:hover {\n    background-color: darkblue;\n  }\n`;\n\nfunction App() {\n  return (\n    &#x3C;div>\n      &#x3C;StyledButton>Click Me&#x3C;/StyledButton>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<h3>Linaria</h3>\n<p>自定义 <strong>功能类</strong> 的 CSS in js 方案，同时也支持 <strong>组件化</strong> 写法。生成的是完全静态的 css，样式值的复用靠变量，片段的复用靠 <code>css</code> 生成的类。</p>\n<p><strong>优点</strong>：</p>\n<p>是预构建方案，在服务端渲染。和原始的 CSS 写法和思路差不多。</p>\n<p><strong>缺点</strong>：</p>\n<ol>\n<li>\n<p>值复用靠变量，但是由于是 <strong>静态 css</strong>，这个并不会变。所以变量插值<strong>其实是常量</strong>。比如下面的 font-size 并不会变化。</p>\n<pre><code class=\"language-jsx\">const fontSize = 16;\nconst Title = styled.h1`\n  font-size: ${fontSize}px;\n`\n</code></pre>\n<p>也就是说，你如果想在客户端随意改变字体，用 context/zustand 这种 runtime 的 fontSize，这样写报错。不过，Linaria 允许你借助 react 的 props 和 <code>styled</code> 组件来实现客户端的值变化。</p>\n<pre><code class=\"language-jsx\">const Title = styled.h1`\n  font-size: ${props => props.size}px;\n`\nexport default function MyComponent() {\n  const fontSize = useAppStore(state => state.fontSize)\n  return &#x3C;Title fontSize={fontSize}>Hello&#x3C;/Title>\n}\n</code></pre>\n<p>相当于生成</p>\n<pre><code class=\"language-jsx\">&#x3C;h1\n  className=\"_title_xyz\"\n  style={{ '--linaria-font-size': `${size}px` }}\n>\n</code></pre>\n<p>那这和 styled-components 写起来已经差不多了。而且要做主题化的值都得用快要废弃的 <code>useContext</code> API。只不过 linaria 改的 style 属性，styled 是改的 css  API。改 style 属性其实已经不能算静态了。</p>\n</li>\n<li>\n<p>组件间的<strong>样式复用方案</strong>只有原生的 CSS 方案，上述的奇妙客户端插值做不了这个需求。假设，你要做一个主题化的对话框的卡片阴影，只能使用原生 css 类中加原生 css 变量。上述动态改变样式的因为依赖 props，只能使用 <code>styled</code> 的写法，但这样就会把 html 标签了也继承了，不同的样式也无法随意组合。这也是为什么我说 Linaria 是原生 css 的替代，而不是 styled-components 的替代，构建方式就决定他们差得太了远。</p>\n</li>\n<li>\n<p>基于2，导致你写组件又要检查 <code>styled</code> 又要确认 <code>css</code> 类又要检查 JSX classname 的顺序。如果用组件继承会被迫连 DOM 类型都继承。</p>\n</li>\n<li>\n<p>使用功能类有点像原子化，又完全不如 tailwind 已经给你预设好一堆东西的效率。写类名和 cssmodule 一样，太磨叽了</p>\n</li>\n</ol>\n<p>我博客本想迁移至此方案，但由于工作量实在巨大而放弃。linaria 主要还是解决了个命名空间冲突的问题，想用得更深入一点就会四不像。</p>\n<pre><code class=\"language-jsx\">import { css } from '@linaria/core';\n\nconst eleStyle = css`\n  color: red;\n  font-size: 3rem;\n  &#x26;:hover {\n    color: blue;\n  }\n`;\n\nfunction App() {\n  return &#x3C;h1 className={eleStyle}>Hello Linaria!&#x3C;/h1>;\n}\n\nexport default App;\n</code></pre>\n<h2>构建组建库</h2>\n<p>每一个 CSS 方案都有对应的构建组件库的实践。 <a href=\"https://github.com/shadcn-ui/ui\">shadcn</a> 是基于 tailwind 构建组件库实践。</p>\n<h2>CSS 框架选择要素</h2>\n<ol>\n<li>样式复用</li>\n<li>样式组合</li>\n<li>动态样式</li>\n<li>主题切换</li>\n<li>代码提示</li>\n<li>自动裁剪</li>\n<li>随意重构</li>\n<li>渲染性能</li>\n<li>实践的统一性</li>\n</ol>\n<p>最重要的还是自己的需求。</p>","content_jsx","const{Fragment:s,jsx:n,jsxs:l}=arguments[0];function _createMdxContent(e){const a={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",...e.components};return l(s,{children:[n(a.p,{children:\"css 的写法一直算比较混乱的。层叠的样式表与 DOM 结构的分离看似清晰，但也因此容易产生屎山，组合太自由，哪些选择器用了哪些选择器没用，共用的嵌套的，分离的。今天小编就带你一探究竟（……）\"}),\"\\n\",n(a.h2,{id:\"css类复用粒度\",children:\"CSS类复用粒度\"}),\"\\n\",n(a.p,{children:\"我自己把 css 选择器（类）的复用粒度分三个层级。\"}),\"\\n\",n(a.h3,{id:\"组件类\",children:\"组件类\"}),\"\\n\",n(a.p,{children:\"粒度最大的层级，通常按组件级别语义化。选择器一般是下面这些名字\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-css\",children:[n(a.span,{className:\"hljs-selector-class\",children:\".wrapper\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".container\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".list-item\"}),\"\\n\"]})}),\"\\n\",n(a.p,{children:\"组件化的选择器下面通常有很多条的 css。\"}),\"\\n\",n(a.h3,{id:\"功能类\",children:\"功能类\"}),\"\\n\",n(a.p,{children:\"通常是共用的样式或状态，比如\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-css\",children:[n(a.span,{className:\"hljs-selector-class\",children:\".open\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".close\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".light\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".dark\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".glass-effect\"}),\"\\n\"]})}),\"\\n\",n(a.p,{children:\"这个看起来好像和组件类不冲突，但硬说的话组件类其实应该是这样\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-css\",children:[n(a.span,{className:\"hljs-selector-class\",children:\".container\"}),n(a.span,{className:\"hljs-selector-class\",children:\".open\"}),\" { 此处将 \",n(a.span,{className:\"hljs-selector-class\",children:\".open\"}),\" 的所有样式全覆盖 }\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".container\"}),n(a.span,{className:\"hljs-selector-class\",children:\".close\"}),\" { 此处将 \",n(a.span,{className:\"hljs-selector-class\",children:\".close\"}),\" 的所有样式全覆盖 }\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".container\"}),n(a.span,{className:\"hljs-selector-class\",children:\".light\"}),\" { 此处将 \",n(a.span,{className:\"hljs-selector-class\",children:\".light\"}),\" 的所有样式全覆盖 }\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".container\"}),n(a.span,{className:\"hljs-selector-class\",children:\".dark\"}),\" { 此处将 \",n(a.span,{className:\"hljs-selector-class\",children:\".dark\"}),\" 的所有样式全覆盖 }\\n\"]})}),\"\\n\",n(a.p,{children:\"组件类的状态严格在组件的 scope 下。功能类则是可以不限 Scope 的复用。\"}),\"\\n\",n(a.p,{children:\"这 CSS 容易混乱的根源。在工程维护角度，功能类是最不敢乱动的类，不知道动了后哪里样式就会出问题。但在设计角度，用功能类复用一些状态又确实很方便，统一设计也好用。比如增加统一的圆角、描边、阴影样式。\"}),\"\\n\",n(a.p,{children:\"功能类的优缺点是一体两面——图像的只有主观的好看与否，没有客观的对错。\"}),\"\\n\",n(a.h3,{id:\"原子类\",children:\"原子类\"}),\"\\n\",n(a.p,{children:\"定义海量常用的基础样式类，在 class 上直接写类名就能获得对应效果。就是 tailwind css。\"}),\"\\n\",n(a.p,{children:\"原子类相较于功能类粒度更小，也不会轻易改动 css 属性。\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-css\",children:[n(a.span,{className:\"hljs-selector-class\",children:\".flex\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".col-1\"}),\"\\n\",n(a.span,{className:\"hljs-selector-class\",children:\".text-sm\"}),\"\\n\"]})}),\"\\n\",n(a.h2,{id:\"方案\",children:\"方案\"}),\"\\n\",n(a.p,{children:\"通常来说，一个库的样式会着重在一个某一个粒度上。\"}),\"\\n\",n(a.h3,{id:\"原生-css\",children:\"原生 css\"}),\"\\n\",l(a.p,{children:[\"用原生 css 时通常会以 \",n(a.strong,{children:\"组件化\"}),\" 的粒度为主，带极少的功能类。现在配合 css 变量使用。早期的网页简单，一个 CSS 文件就能搞定全站，设计上并没有考虑项目变得越来越复杂后的实践。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"优点\"}),\"：性能好，扁平的结构利好小项目。适合写研究新样式。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"缺点\"}),\"：过于扁平，大量工程化后易屎山，存在样式与 DOM 分离带来的维护混乱。\"]}),\"\\n\",n(a.h3,{id:\"scss\",children:\"SCSS\"}),\"\\n\",l(a.p,{children:[\"古法预处理器，可能多层嵌套 css，可组合。是 \",n(a.strong,{children:\"组件化\"}),\" 的粒度。在 CSS.module 出来前，用 SCSS 分割 Scope 挺好用。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"优点\"}),\"：结构非常清晰\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"缺点\"}),\"：\"]}),\"\\n\",l(a.ol,{children:[\"\\n\",n(a.li,{children:\"编译后的选择器很长一串，从浏览器渲染角度，匹配DOM是耗性能的\"}),\"\\n\",n(a.li,{children:\"难以应对复杂项目 DOM 结构的改变，需要考虑扁平化 + 命名，但这样做和原生 CSS 的维护体验也不相上下。\"}),\"\\n\"]}),\"\\n\",n(a.h3,{id:\"css-module\",children:\"CSS Module\"}),\"\\n\",l(a.p,{children:[\"CSS Module 是完全 \",n(a.strong,{children:\"组件化\"}),\" 的粒度。相比起 SCSS 的样式与 DOM 分离，CSS Module 为组件内部样式耦合，组件间样式分离。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"优点：\"}),\" 在组件粒度分割合理的情况下，清晰易维护。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"缺点\"}),\"：依赖预构建，写类名写起来太磨叽了。整体我用得不多没法评价。\"]}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"Button\"}),\" = (\",n(a.span,{className:\"hljs-params\"}),\") => {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" (\\n    \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"button\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{styles.button}\"}),\">\"]}),\"\\n      Click me\\n    \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"button\"}),\">\"]})]}),\"\\n  );\\n};\\n\"]})}),\"\\n\",n(a.h3,{id:\"bootstrap\",children:\"BootStrap\"}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"组件化\"}),\" 为主，少量原子化修饰的预制样式库，拿来即用是不错的。早期 CSS 框架大多是指预制样式，和预构建的库有本质区别。\"]}),\"\\n\",n(a.h3,{id:\"tailwind-css\",children:\"Tailwind css\"}),\"\\n\",n(a.p,{children:\"完全原子化的神奇之库，通过编译可以有功能类和组件类。它更像是重新定义了 css 语法。\"}),\"\\n\",n(a.p,{children:n(a.strong,{children:\"优点\"})}),\"\\n\",l(a.ol,{children:[\"\\n\",n(a.li,{children:\"灵活，快，好看\"}),\"\\n\",n(a.li,{children:\"工具链齐全，可以裁剪掉不用的原子类。\"}),\"\\n\"]}),\"\\n\",n(a.p,{children:n(a.strong,{children:\"缺点\"})}),\"\\n\",l(a.ol,{children:[\"\\n\",n(a.li,{children:\"稍微要写复杂一点的样式，DOM 就会被一大堆 class 埋没。\"}),\"\\n\",n(a.li,{children:\"从浏览器渲染角度，匹配、合并大量 CSS 样式是需要更多性能开销的\"}),\"\\n\",n(a.li,{children:\"要做到同种样式的复用，必须组合原子类，变成功能类或组件类，否则维护起来相当麻烦。这似乎违背了用 tailwind css 的初衷，熟悉了 css 的不如直接自己用 css 手撮功能类和组件类。\"}),\"\\n\",n(a.li,{children:\"其实我是 tailwind 黑，嗯。但无法否认开发时确实很快很方便。\"}),\"\\n\"]}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"Card\"}),\"(\",n(a.span,{className:\"hljs-params\",children:\"{ title, description, imageUrl, imageAlt }\"}),\") {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" (\\n    \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"max-w-sm rounded overflow-hidden shadow-lg\"'}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"img\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"w-full\"'}),\" \",n(a.span,{className:\"hljs-attr\",children:\"src\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{imageUrl}\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"alt\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{imageAlt}\"}),\" />\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"px-6 py-4\"'}),\">\"]}),\"\\n        \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"font-bold text-xl mb-2\"'}),\">\"]}),\"{title}\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"\\n        \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"p\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"text-gray-700 text-base\"'}),\">\"]}),\"{description}\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"p\"}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"px-6 pt-4 pb-2\"'}),\">\"]}),\"\\n        \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\"'}),\">\"]}),\"#photography\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\">\"]}),\"\\n        \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\"'}),\">\"]}),\"#travel\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\">\"]}),\"\\n        \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:'\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\"'}),\">\"]}),\"#adventure\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"span\"}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"\\n    \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]})]}),\"\\n  );\\n}\\n\"]})}),\"\\n\",n(a.h3,{id:\"原生-css-in-js\",children:\"原生 css in js\"}),\"\\n\",n(a.p,{children:\"指 JS Object 转译为 CSS。由于写起来太不像 CSS，复杂的功能写起来过于不直观 ，我直接 PASS。\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"InlineStyleExample\"}),\" = (\",n(a.span,{className:\"hljs-params\"}),\") => {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" myStyle = {\\n    \",n(a.span,{className:\"hljs-attr\",children:\"color\"}),\": \",n(a.span,{className:\"hljs-string\",children:\"'blue'\"}),\",\\n    \",n(a.span,{className:\"hljs-attr\",children:\"backgroundColor\"}),\": \",n(a.span,{className:\"hljs-string\",children:\"'lightgray'\"}),\",\\n    \",n(a.span,{className:\"hljs-attr\",children:\"padding\"}),\": \",n(a.span,{className:\"hljs-string\",children:\"'10px'\"}),\",\\n    \",n(a.span,{className:\"hljs-attr\",children:\"borderRadius\"}),\": \",n(a.span,{className:\"hljs-string\",children:\"'5px'\"}),\"\\n  };\\n\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" (\\n    \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"style\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{myStyle}\"}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"p\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"style\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{{\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"fontSize:\"}),\" '\",n(a.span,{className:\"hljs-attr\",children:\"18px\"}),\"', \",n(a.span,{className:\"hljs-attr\",children:\"fontWeight:\"}),\" '\",n(a.span,{className:\"hljs-attr\",children:\"bold\"}),\"' }}>\"]}),\"\\n        This text is styled with inline CSS.\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"p\"}),\">\"]}),\"\\n    \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]})]}),\"\\n  );\\n};\\n\"]})}),\"\\n\",n(a.h3,{id:\"styled-components\",children:\"Styled-components\"}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"组件化\"}),\"的 CSS in JS 方案，写起来像 CSS 实际是 JS。支持客户端动态修改 CSS 具体属性（其他方案做状态改变主要依靠 selector 的匹配）\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"优点\"}),\"：\"]}),\"\\n\",n(a.p,{children:\"灵活好拓展，比如主题管理不仅仅是颜色，还可以是图片资源一类的。\"}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"缺点\"}),\"：\"]}),\"\\n\",l(a.ol,{children:[\"\\n\",n(a.li,{children:\"因为是 JS 转 CSS，服务器编译慢和客户端渲染慢得选一个\"}),\"\\n\",n(a.li,{children:\"React 的 useContext 要被废弃了，而 styled-components 严重依赖此 hook，导致进入了维护状态。JS 框架发展太快了。\"}),\"\\n\"]}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"import\"}),\" styled \",n(a.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",n(a.span,{className:\"hljs-string\",children:\"'styled-components'\"}),\";\\n\\n\",n(a.span,{className:\"hljs-comment\",children:\"// Create a styled button component\"}),\"\\n\",n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",n(a.span,{className:\"hljs-title class_\",children:\"StyledButton\"}),\" = styled.\",n(a.span,{className:\"hljs-property\",children:\"button\"}),n(a.span,{className:\"hljs-string\",children:\"`\\n  background-color: blue;\\n  font-size: 16px;\\n  padding: 10px 20px;\\n  border-radius: 5px;\\n\\n  &:hover {\\n    background-color: darkblue;\\n  }\\n`\"}),\";\\n\\n\",n(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"App\"}),\"(\",n(a.span,{className:\"hljs-params\"}),\") {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" (\\n    \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"\\n      \",l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"StyledButton\"}),\">\"]}),\"Click Me\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"StyledButton\"}),\">\"]}),\"\\n    \",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"div\"}),\">\"]})]}),\"\\n  );\\n}\\n\"]})}),\"\\n\",n(a.h3,{id:\"linaria\",children:\"Linaria\"}),\"\\n\",l(a.p,{children:[\"自定义 \",n(a.strong,{children:\"功能类\"}),\" 的 CSS in js 方案，同时也支持 \",n(a.strong,{children:\"组件化\"}),\" 写法。生成的是完全静态的 css，样式值的复用靠变量，片段的复用靠 \",n(a.code,{children:\"css\"}),\" 生成的类。\"]}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"优点\"}),\"：\"]}),\"\\n\",n(a.p,{children:\"是预构建方案，在服务端渲染。和原始的 CSS 写法和思路差不多。\"}),\"\\n\",l(a.p,{children:[n(a.strong,{children:\"缺点\"}),\"：\"]}),\"\\n\",l(a.ol,{children:[\"\\n\",l(a.li,{children:[\"\\n\",l(a.p,{children:[\"值复用靠变量，但是由于是 \",n(a.strong,{children:\"静态 css\"}),\"，这个并不会变。所以变量插值\",n(a.strong,{children:\"其实是常量\"}),\"。比如下面的 font-size 并不会变化。\"]}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" fontSize = \",n(a.span,{className:\"hljs-number\",children:\"16\"}),\";\\n\",n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",n(a.span,{className:\"hljs-title class_\",children:\"Title\"}),\" = styled.\",n(a.span,{className:\"hljs-property\",children:\"h1\"}),l(a.span,{className:\"hljs-string\",children:[\"`\\n  font-size: \",n(a.span,{className:\"hljs-subst\",children:\"${fontSize}\"}),\"px;\\n`\"]}),\"\\n\"]})}),\"\\n\",l(a.p,{children:[\"也就是说，你如果想在客户端随意改变字体，用 context/zustand 这种 runtime 的 fontSize，这样写报错。不过，Linaria 允许你借助 react 的 props 和 \",n(a.code,{children:\"styled\"}),\" 组件来实现客户端的值变化。\"]}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",n(a.span,{className:\"hljs-title class_\",children:\"Title\"}),\" = styled.\",n(a.span,{className:\"hljs-property\",children:\"h1\"}),l(a.span,{className:\"hljs-string\",children:[\"`\\n  font-size: \",n(a.span,{className:\"hljs-subst\",children:\"${props => props.size}\"}),\"px;\\n`\"]}),\"\\n\",n(a.span,{className:\"hljs-keyword\",children:\"export\"}),\" \",n(a.span,{className:\"hljs-keyword\",children:\"default\"}),\" \",n(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"MyComponent\"}),\"(\",n(a.span,{className:\"hljs-params\"}),\") {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" fontSize = \",n(a.span,{className:\"hljs-title function_\",children:\"useAppStore\"}),\"(\",l(a.span,{className:\"hljs-function\",children:[n(a.span,{className:\"hljs-params\",children:\"state\"}),\" =>\"]}),\" state.\",n(a.span,{className:\"hljs-property\",children:\"fontSize\"}),\")\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"Title\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"fontSize\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{fontSize}\"}),\">\"]}),\"Hello\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"Title\"}),\">\"]})]}),\"\\n}\\n\"]})}),\"\\n\",n(a.p,{children:\"相当于生成\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[\"<h1\\n  className=\",n(a.span,{className:\"hljs-string\",children:'\"_title_xyz\"'}),\"\\n  style={{ \",n(a.span,{className:\"hljs-string\",children:\"'--linaria-font-size'\"}),\": \",l(a.span,{className:\"hljs-string\",children:[\"`\",n(a.span,{className:\"hljs-subst\",children:\"${size}\"}),\"px`\"]}),\" }}\\n>\\n\"]})}),\"\\n\",l(a.p,{children:[\"那这和 styled-components 写起来已经差不多了。而且要做主题化的值都得用快要废弃的 \",n(a.code,{children:\"useContext\"}),\" API。只不过 linaria 改的 style 属性，styled 是改的 css  API。改 style 属性其实已经不能算静态了。\"]}),\"\\n\"]}),\"\\n\",l(a.li,{children:[\"\\n\",l(a.p,{children:[\"组件间的\",n(a.strong,{children:\"样式复用方案\"}),\"只有原生的 CSS 方案，上述的奇妙客户端插值做不了这个需求。假设，你要做一个主题化的对话框的卡片阴影，只能使用原生 css 类中加原生 css 变量。上述动态改变样式的因为依赖 props，只能使用 \",n(a.code,{children:\"styled\"}),\" 的写法，但这样就会把 html 标签了也继承了，不同的样式也无法随意组合。这也是为什么我说 Linaria 是原生 css 的替代，而不是 styled-components 的替代，构建方式就决定他们差得太了远。\"]}),\"\\n\"]}),\"\\n\",l(a.li,{children:[\"\\n\",l(a.p,{children:[\"基于2，导致你写组件又要检查 \",n(a.code,{children:\"styled\"}),\" 又要确认 \",n(a.code,{children:\"css\"}),\" 类又要检查 JSX classname 的顺序。如果用组件继承会被迫连 DOM 类型都继承。\"]}),\"\\n\"]}),\"\\n\",l(a.li,{children:[\"\\n\",n(a.p,{children:\"使用功能类有点像原子化，又完全不如 tailwind 已经给你预设好一堆东西的效率。写类名和 cssmodule 一样，太磨叽了\"}),\"\\n\"]}),\"\\n\"]}),\"\\n\",n(a.p,{children:\"我博客本想迁移至此方案，但由于工作量实在巨大而放弃。linaria 主要还是解决了个命名空间冲突的问题，想用得更深入一点就会四不像。\"}),\"\\n\",n(a.pre,{children:l(a.code,{className:\"hljs language-jsx\",children:[n(a.span,{className:\"hljs-keyword\",children:\"import\"}),\" { css } \",n(a.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",n(a.span,{className:\"hljs-string\",children:\"'@linaria/core'\"}),\";\\n\\n\",n(a.span,{className:\"hljs-keyword\",children:\"const\"}),\" eleStyle = css`\",l(a.span,{className:\"css\",children:[\"\\n  \",n(a.span,{className:\"hljs-attribute\",children:\"color\"}),\": red;\\n  \",n(a.span,{className:\"hljs-attribute\",children:\"font-size\"}),\": \",n(a.span,{className:\"hljs-number\",children:\"3rem\"}),\";\\n  &\",n(a.span,{className:\"hljs-selector-pseudo\",children:\":hover\"}),\" {\\n    \",n(a.span,{className:\"hljs-attribute\",children:\"color\"}),\": blue;\\n  }\\n`\"]}),\";\\n\\n\",n(a.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",n(a.span,{className:\"hljs-title function_\",children:\"App\"}),\"(\",n(a.span,{className:\"hljs-params\"}),\") {\\n  \",n(a.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",l(a.span,{className:\"xml\",children:[l(a.span,{className:\"hljs-tag\",children:[\"<\",n(a.span,{className:\"hljs-name\",children:\"h1\"}),\" \",n(a.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",n(a.span,{className:\"hljs-string\",children:\"{eleStyle}\"}),\">\"]}),\"Hello Linaria!\",l(a.span,{className:\"hljs-tag\",children:[\"</\",n(a.span,{className:\"hljs-name\",children:\"h1\"}),\">\"]})]}),\";\\n}\\n\\n\",n(a.span,{className:\"hljs-keyword\",children:\"export\"}),\" \",n(a.span,{className:\"hljs-keyword\",children:\"default\"}),\" \",n(a.span,{className:\"hljs-title class_\",children:\"App\"}),\";\\n\"]})}),\"\\n\",n(a.h2,{id:\"构建组建库\",children:\"构建组建库\"}),\"\\n\",l(a.p,{children:[\"每一个 CSS 方案都有对应的构建组件库的实践。 \",n(a.a,{href:\"https://github.com/shadcn-ui/ui\",children:\"shadcn\"}),\" 是基于 tailwind 构建组件库实践。\"]}),\"\\n\",n(a.h2,{id:\"css-框架选择要素\",children:\"CSS 框架选择要素\"}),\"\\n\",l(a.ol,{children:[\"\\n\",n(a.li,{children:\"样式复用\"}),\"\\n\",n(a.li,{children:\"样式组合\"}),\"\\n\",n(a.li,{children:\"动态样式\"}),\"\\n\",n(a.li,{children:\"主题切换\"}),\"\\n\",n(a.li,{children:\"代码提示\"}),\"\\n\",n(a.li,{children:\"自动裁剪\"}),\"\\n\",n(a.li,{children:\"随意重构\"}),\"\\n\",n(a.li,{children:\"渲染性能\"}),\"\\n\",n(a.li,{children:\"实践的统一性\"}),\"\\n\"]}),\"\\n\",n(a.p,{children:\"最重要的还是自己的需求。\"})]})}return{default:function(s={}){const{wrapper:l}=s.components||{};return l?n(l,{...s,children:n(_createMdxContent,{...s})}):_createMdxContent(s)}};","toc",[31,49,85,89],{"_7":32,"_33":34,"_35":36},"CSS类复用粒度","url","#css类复用粒度","items",[37,41,45],{"_7":38,"_33":39,"_35":40},"组件类","#组件类",[],{"_7":42,"_33":43,"_35":44},"功能类","#功能类",[],{"_7":46,"_33":47,"_35":48},"原子类","#原子类",[],{"_7":50,"_33":51,"_35":52},"方案","#方案",[53,57,61,65,69,73,77,81],{"_7":54,"_33":55,"_35":56},"原生 css","#原生-css",[],{"_7":58,"_33":59,"_35":60},"SCSS","#scss",[],{"_7":62,"_33":63,"_35":64},"CSS Module","#css-module",[],{"_7":66,"_33":67,"_35":68},"BootStrap","#bootstrap",[],{"_7":70,"_33":71,"_35":72},"Tailwind css","#tailwind-css",[],{"_7":74,"_33":75,"_35":76},"原生 css in js","#原生-css-in-js",[],{"_7":78,"_33":79,"_35":80},"Styled-components","#styled-components",[],{"_7":82,"_33":83,"_35":84},"Linaria","#linaria",[],{"_7":86,"_33":87,"_35":88},"构建组建库","#构建组建库",[],{"_7":90,"_33":91,"_35":92},"CSS 框架选择要素","#css-框架选择要素",[],"tags",[95],"CSS","categories","学习","keywords",[95,58,100,101,102,82],"Bootstrap","tailwind","styled-components","permalink","/posts/2025-07-12-compare-css-solutions","prevPost",{"_7":107,"_9":108},"uv 管理 conda 项目依赖","2025-07-24-embed-python-with-uv","nextPost",{"_7":111,"_9":112},"Steam 假入库是怎么做的","2025-04-22-techs-about-steam-crack"]
