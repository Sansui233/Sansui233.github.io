[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_72":73,"_76":77},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_17":18,"_23":24,"_25":26,"_27":28,"_29":30,"_61":62,"_64":65,"_66":67,"_70":71},"title","uv 管理 conda 项目依赖","slug","2025-07-24-embed-python-with-uv","date","2025-07-24T12:12:32.000Z","description","沐神都解决不了的……","draft",false,"metadata",{"_19":20,"_21":22},"readingTime",3,"wordCount",756.08,"excerpt","conda 的问题\nPython 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。\n\nconda 的问题在于\n\nrequirements.txt 全手写！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。\n依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python ","content_html","<h2>conda 的问题</h2>\n<p>Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。</p>\n<p><img src=\"https://img-cf.sansui233.com/imgs/2025/07/202507242029977.webp\" alt=\"沐神都解决不了的\"></p>\n<p>conda 的问题在于</p>\n<ol>\n<li>requirements.txt <strong>全手写</strong>！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。</li>\n<li>依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python 发了论文和仓库就跑的项目是很多的。安装一个旧项目导致之前安装 numpy 被卸载，然后整个项目就垮掉。这种情况相当之多，又解决两个小时的依赖问题。</li>\n<li>（至少我不愿意看到）电脑里十几个相同版本的 torch 和 cuda。当时的硬盘还只有 256G，多装几个 torch 无法接受，嗯……</li>\n</ol>\n<p>直到现在都还是这样的，大家主打一个能跑完实验就行。包的更新是激进的，包管理是落后的。在几年前有人说用 PDM，后面有 poetry。这两是不用再手写 <code>requirements.txt</code> 了，依赖也会自动 resolve 不会覆盖来覆盖去的，但还是会装十几个 torch。直到 uv 开始用硬链接进行包管理。</p>\n<h2>uv 之于 conda 项目</h2>\n<p>uv 接管 python 界的依赖管理按理说已经没什么问题。但实际情况是，很多项目还是在用 conda。除非哪天 torch 和 HF 都把 uv 设置为首推，否则就得一直与  conda 存在的问题战斗。</p>\n<h3>1. 不提供 venv 的项目</h3>\n<p>用于研究的项目一般都是不提供的打包好的环境的，主要是太大了，每个人设备情况也不一样。所以下载后第一件事是</p>\n<pre><code class=\"language-sh\">uv venv\n./.venv/Script/activate\n</code></pre>\n<p>如果这个项目不再更新了，或者是打算迁移到 uv，可以直接使用 uv 的方式管理依赖。uv 会自动维护 <code>pyproject.toml</code> 和 <code>uv.lock</code> 文件。</p>\n<pre><code>uv add -r requirements.in -c requirements.txt\n</code></pre>\n<p>如果这个项目，他还在更新，你时不时就得去拉一下分支。这时候最好用 <code>uv pip</code> 。至于依赖混乱问题，听天由命吧。<del>跑得起来就得了</del></p>\n<pre><code>uv pip install -r requirement.txt\n</code></pre>\n<h3>2. 提供 venv 的项目</h3>\n<p>提供 venv 的项目通常是给人用的，b 站的整合包一大堆。这种已经配好环境的项目也意味着你最好只用 pip。通常还是非常原始地调用 pip</p>\n<pre><code>./.venv/python -m pip install xxx\n</code></pre>\n<p>……等于说又开始了安装十几份 torch 的依赖管理模式。用 uv 是可以重复利用缓存的。这个时候 uv 的问题在于无法接管 python 环境，需要设置一下环境变量：</p>\n<pre><code class=\"language-sh\">export UV_PYTHON=\"./.venv/python\"\nuv pip list\n</code></pre>\n<p>然后就可以利用 uv 的缓存了。</p>\n<p>当然，依赖混乱问题使用 <code>uv pip</code> 是无法避免的。这对于发行版也是一种麻烦。因为发行版的环境全给你配好了，但有的项目设计了插件系统，插件系统又需要装插件的 requirement.txt，安一个许久没更新的插件让主项目废掉的情况也不是不可能……</p>\n<p>如果让插件作者指定的兼容版本？只靠规范做不到，必须像MC那样检查版本号，不更新版本号就不放行。这样就算不更新代码了，也得倒逼作者每个版本都进行一次（至少是与主项目的）依赖兼容性测试。</p>\n<p>我觉得以当前 python 的运行方式，不 lock 子依赖的版本，这个问题是没法解决的。</p>\n<h2>uv 管理 torch 下载源</h2>\n<p>通常而言，在不指定 index 时 uv add torch 是去 pypi 或清华镜像源找 CPU 版本。如果打算每个项目都采用一样的 torch 版本 和 cuda ——</p>\n<h3>uv 创建的新项目</h3>\n<p>共用的 <code>uv.toml</code> 指定下载源。</p>\n<p>Linux 在 <code>.config/uv/</code> 下，Windows 在 <code>%APPDATA%/uv/</code> 下。</p>\n<pre><code class=\"language-toml\">[[index]]\nurl = \"https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/\"\ndefault = true\n[[index]]\nname = \"pytorch-cu128\"\nurl = \"https://download.pytorch.org/whl/cu128\"\nexplicit = true\n</code></pre>\n<p>项目级别的 <code>pyproject.toml</code></p>\n<pre><code class=\"language-toml\">dependencies = [\n  \"torch>=2.8.0\",\n  \"torchvision>=0.23.0\",\n  \"torchaudio>=2.8.0\",\n]\n\n[tool.uv.sources]\ntorch = [\n  { index = \"pytorch-cu128\"},\n]\ntorchvision = [\n  { index = \"pytorch-cu128\"},\n]\ntorchaudio = [\n  { index = \"pytorch-cu128\"},\n]\n</code></pre>\n<p>然后执行 <code>uv sync</code> 安装。</p>\n<h3>uv pip 管理老项目</h3>\n<p>直接指定命令行 的 <code>--index-url</code> 和 <code>--torch-backend</code></p>\n<pre><code class=\"language-shell\">uv pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126 --torch-backend=cu126\n</code></pre>\n<p>和用 pip 的方式差不多，区别是会硬链接到集中的缓存，不会重复占用十几份 torch。当然。该有的依赖冲突还是会有的。<del>关键是装好后就不要更新了</del></p>","content_jsx","const{Fragment:n,jsx:e,jsxs:c}=arguments[0];function _createMdxContent(l){const r={code:\"code\",del:\"del\",h2:\"h2\",h3:\"h3\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",...l.components};return c(n,{children:[e(r.h2,{id:\"conda-的问题\",children:\"conda 的问题\"}),\"\\n\",e(r.p,{children:\"Python 新项目使用 uv 管理容易，但是总是有一些老项目不用。 conda 包管理一直以来都是 AI 的标配。我用 python 99% 都是在扒别人代码运行。这就导致了我运行了多少个项目，就装了多少份 torch……硬盘再大也经不起十几次折腾。\"}),\"\\n\",e(r.img,{src:\"https://img-cf.sansui233.com/imgs/2025/07/202507242029977.webp\",alt:\"沐神都解决不了的\"}),\"\\n\",e(r.p,{children:\"conda 的问题在于\"}),\"\\n\",c(r.ol,{children:[\"\\n\",c(r.li,{children:[\"requirements.txt \",e(r.strong,{children:\"全手写\"}),\"！很多人可能忘更新配置，导致扒拉下来缺库运行不了，先解决一个小时的依赖问题再说。\"]}),\"\\n\",e(r.li,{children:\"依赖和安装顺序强相关。比如项目需要更新的 numpy，但你可能要装个别的项目的库，python 发了论文和仓库就跑的项目是很多的。安装一个旧项目导致之前安装 numpy 被卸载，然后整个项目就垮掉。这种情况相当之多，又解决两个小时的依赖问题。\"}),\"\\n\",e(r.li,{children:\"（至少我不愿意看到）电脑里十几个相同版本的 torch 和 cuda。当时的硬盘还只有 256G，多装几个 torch 无法接受，嗯……\"}),\"\\n\"]}),\"\\n\",c(r.p,{children:[\"直到现在都还是这样的，大家主打一个能跑完实验就行。包的更新是激进的，包管理是落后的。在几年前有人说用 PDM，后面有 poetry。这两是不用再手写 \",e(r.code,{children:\"requirements.txt\"}),\" 了，依赖也会自动 resolve 不会覆盖来覆盖去的，但还是会装十几个 torch。直到 uv 开始用硬链接进行包管理。\"]}),\"\\n\",e(r.h2,{id:\"uv-之于-conda-项目\",children:\"uv 之于 conda 项目\"}),\"\\n\",e(r.p,{children:\"uv 接管 python 界的依赖管理按理说已经没什么问题。但实际情况是，很多项目还是在用 conda。除非哪天 torch 和 HF 都把 uv 设置为首推，否则就得一直与  conda 存在的问题战斗。\"}),\"\\n\",e(r.h3,{id:\"1-不提供-venv-的项目\",children:\"1. 不提供 venv 的项目\"}),\"\\n\",e(r.p,{children:\"用于研究的项目一般都是不提供的打包好的环境的，主要是太大了，每个人设备情况也不一样。所以下载后第一件事是\"}),\"\\n\",e(r.pre,{children:e(r.code,{className:\"hljs language-sh\",children:\"uv venv\\n./.venv/Script/activate\\n\"})}),\"\\n\",c(r.p,{children:[\"如果这个项目不再更新了，或者是打算迁移到 uv，可以直接使用 uv 的方式管理依赖。uv 会自动维护 \",e(r.code,{children:\"pyproject.toml\"}),\" 和 \",e(r.code,{children:\"uv.lock\"}),\" 文件。\"]}),\"\\n\",e(r.pre,{children:e(r.code,{children:\"uv add -r requirements.in -c requirements.txt\\n\"})}),\"\\n\",c(r.p,{children:[\"如果这个项目，他还在更新，你时不时就得去拉一下分支。这时候最好用 \",e(r.code,{children:\"uv pip\"}),\" 。至于依赖混乱问题，听天由命吧。\",e(r.del,{children:\"跑得起来就得了\"})]}),\"\\n\",e(r.pre,{children:e(r.code,{children:\"uv pip install -r requirement.txt\\n\"})}),\"\\n\",e(r.h3,{id:\"2-提供-venv-的项目\",children:\"2. 提供 venv 的项目\"}),\"\\n\",e(r.p,{children:\"提供 venv 的项目通常是给人用的，b 站的整合包一大堆。这种已经配好环境的项目也意味着你最好只用 pip。通常还是非常原始地调用 pip\"}),\"\\n\",e(r.pre,{children:e(r.code,{children:\"./.venv/python -m pip install xxx\\n\"})}),\"\\n\",e(r.p,{children:\"……等于说又开始了安装十几份 torch 的依赖管理模式。用 uv 是可以重复利用缓存的。这个时候 uv 的问题在于无法接管 python 环境，需要设置一下环境变量：\"}),\"\\n\",e(r.pre,{children:c(r.code,{className:\"hljs language-sh\",children:[e(r.span,{className:\"hljs-built_in\",children:\"export\"}),\" UV_PYTHON=\",e(r.span,{className:\"hljs-string\",children:'\"./.venv/python\"'}),\"\\nuv pip list\\n\"]})}),\"\\n\",e(r.p,{children:\"然后就可以利用 uv 的缓存了。\"}),\"\\n\",c(r.p,{children:[\"当然，依赖混乱问题使用 \",e(r.code,{children:\"uv pip\"}),\" 是无法避免的。这对于发行版也是一种麻烦。因为发行版的环境全给你配好了，但有的项目设计了插件系统，插件系统又需要装插件的 requirement.txt，安一个许久没更新的插件让主项目废掉的情况也不是不可能……\"]}),\"\\n\",e(r.p,{children:\"如果让插件作者指定的兼容版本？只靠规范做不到，必须像MC那样检查版本号，不更新版本号就不放行。这样就算不更新代码了，也得倒逼作者每个版本都进行一次（至少是与主项目的）依赖兼容性测试。\"}),\"\\n\",e(r.p,{children:\"我觉得以当前 python 的运行方式，不 lock 子依赖的版本，这个问题是没法解决的。\"}),\"\\n\",e(r.h2,{id:\"uv-管理-torch-下载源\",children:\"uv 管理 torch 下载源\"}),\"\\n\",e(r.p,{children:\"通常而言，在不指定 index 时 uv add torch 是去 pypi 或清华镜像源找 CPU 版本。如果打算每个项目都采用一样的 torch 版本 和 cuda ——\"}),\"\\n\",e(r.h3,{id:\"uv-创建的新项目\",children:\"uv 创建的新项目\"}),\"\\n\",c(r.p,{children:[\"共用的 \",e(r.code,{children:\"uv.toml\"}),\" 指定下载源。\"]}),\"\\n\",c(r.p,{children:[\"Linux 在 \",e(r.code,{children:\".config/uv/\"}),\" 下，Windows 在 \",e(r.code,{children:\"%APPDATA%/uv/\"}),\" 下。\"]}),\"\\n\",e(r.pre,{children:c(r.code,{className:\"hljs language-toml\",children:[e(r.span,{className:\"hljs-section\",children:\"[[index]]\"}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"url\"}),\" = \",e(r.span,{className:\"hljs-string\",children:'\"https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/\"'}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"default\"}),\" = \",e(r.span,{className:\"hljs-literal\",children:\"true\"}),\"\\n\",e(r.span,{className:\"hljs-section\",children:\"[[index]]\"}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"name\"}),\" = \",e(r.span,{className:\"hljs-string\",children:'\"pytorch-cu128\"'}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"url\"}),\" = \",e(r.span,{className:\"hljs-string\",children:'\"https://download.pytorch.org/whl/cu128\"'}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"explicit\"}),\" = \",e(r.span,{className:\"hljs-literal\",children:\"true\"}),\"\\n\"]})}),\"\\n\",c(r.p,{children:[\"项目级别的 \",e(r.code,{children:\"pyproject.toml\"})]}),\"\\n\",e(r.pre,{children:c(r.code,{className:\"hljs language-toml\",children:[e(r.span,{className:\"hljs-attr\",children:\"dependencies\"}),\" = [\\n  \",e(r.span,{className:\"hljs-string\",children:'\"torch>=2.8.0\"'}),\",\\n  \",e(r.span,{className:\"hljs-string\",children:'\"torchvision>=0.23.0\"'}),\",\\n  \",e(r.span,{className:\"hljs-string\",children:'\"torchaudio>=2.8.0\"'}),\",\\n]\\n\\n\",e(r.span,{className:\"hljs-section\",children:\"[tool.uv.sources]\"}),\"\\n\",e(r.span,{className:\"hljs-attr\",children:\"torch\"}),\" = [\\n  { index = \",e(r.span,{className:\"hljs-string\",children:'\"pytorch-cu128\"'}),\"},\\n]\\n\",e(r.span,{className:\"hljs-attr\",children:\"torchvision\"}),\" = [\\n  { index = \",e(r.span,{className:\"hljs-string\",children:'\"pytorch-cu128\"'}),\"},\\n]\\n\",e(r.span,{className:\"hljs-attr\",children:\"torchaudio\"}),\" = [\\n  { index = \",e(r.span,{className:\"hljs-string\",children:'\"pytorch-cu128\"'}),\"},\\n]\\n\"]})}),\"\\n\",c(r.p,{children:[\"然后执行 \",e(r.code,{children:\"uv sync\"}),\" 安装。\"]}),\"\\n\",e(r.h3,{id:\"uv-pip-管理老项目\",children:\"uv pip 管理老项目\"}),\"\\n\",c(r.p,{children:[\"直接指定命令行 的 \",e(r.code,{children:\"--index-url\"}),\" 和 \",e(r.code,{children:\"--torch-backend\"})]}),\"\\n\",e(r.pre,{children:e(r.code,{className:\"hljs language-shell\",children:\"uv pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu126 --torch-backend=cu126\\n\"})}),\"\\n\",c(r.p,{children:[\"和用 pip 的方式差不多，区别是会硬链接到集中的缓存，不会重复占用十几份 torch。当然。该有的依赖冲突还是会有的。\",e(r.del,{children:\"关键是装好后就不要更新了\"})]})]})}return{default:function(n={}){const{wrapper:c}=n.components||{};return c?e(c,{...n,children:e(_createMdxContent,{...n})}):_createMdxContent(n)}};","toc",[31,37,49],{"_7":32,"_33":34,"_35":36},"conda 的问题","url","#conda-的问题","items",[],{"_7":38,"_33":39,"_35":40},"uv 之于 conda 项目","#uv-之于-conda-项目",[41,45],{"_7":42,"_33":43,"_35":44},"1. 不提供 venv 的项目","#1-不提供-venv-的项目",[],{"_7":46,"_33":47,"_35":48},"2. 提供 venv 的项目","#2-提供-venv-的项目",[],{"_7":50,"_33":51,"_35":52},"uv 管理 torch 下载源","#uv-管理-torch-下载源",[53,57],{"_7":54,"_33":55,"_35":56},"uv 创建的新项目","#uv-创建的新项目",[],{"_7":58,"_33":59,"_35":60},"uv pip 管理老项目","#uv-pip-管理老项目",[],"tags",[63],"python","categories","学习","keywords",[63,68,69],"包管理","uv","permalink","/posts/2025-07-24-embed-python-with-uv","prevPost",{"_7":74,"_9":75},"Better Web Typography for a Better Web 中文版","2025-12-30-Better-Web-Typography-for-a-Better-Web-Chinese-Version","nextPost",{"_7":78,"_9":79},"踩了一圈 CSS 构建方案的坑","2025-07-12-compare-css-solutions"]
