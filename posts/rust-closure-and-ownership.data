[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_69":70,"_72":73},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_17":18,"_23":24,"_25":26,"_27":28,"_29":30,"_57":58,"_60":61,"_62":63,"_67":68},"title","理解 Rust 闭包与环境变量所有权","slug","rust-closure-and-ownership","date","2022-06-13T16:00:00.000Z","description","B站反查用户弹幕小记","draft",false,"metadata",{"_19":20,"_21":22},"readingTime",6,"wordCount",1467.5600000000002,"excerpt","本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。\n阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。\n什么是 Rust 的闭包\nRust 中的闭包是一种函数。与 Rust 普通函数不同，它可以捕获函数外部的变量并使用。\n基本语法：|参数列表| {函数体}\nfn main() {\r\n    let x = 1;\r\n","content_html","<p>本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。</p>\n<p>阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。</p>\n<h2>什么是 Rust 的闭包</h2>\n<p>Rust 中的闭包是<strong>一种函数</strong>。与 Rust 普通函数不同，它可以<strong>捕获函数外部的变量并使用</strong>。</p>\n<p>基本语法：<code>|参数列表| {函数体}</code></p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = 1;\r\n    let sum = |y: i32| { x + y }; // 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\r\n    println!(\"{}\", sum(99)); // 输出 100\r\n\r\n    let sum2 = |y :i32| x + y + 1; // 也可以省略花括号\r\n    println!(\"{}\", sum2(99)); // 输出 101\r\n}\n</code></pre>\n<blockquote>\n<p>说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 <code>let x = 1;</code> ，为闭包外部的变量。</p>\n</blockquote>\n<p>像 <code>x</code> 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“<strong>环境变量</strong>”。</p>\n<h2>闭包中环境变量的所有权</h2>\n<p>有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式</p>\n<ol>\n<li>所有权 move（默认行为）。</li>\n<li>可变借用，形式为 <code>&#x26;mut param</code></li>\n<li>不可变借用 ，形式为 <code>&#x26;param</code></li>\n</ol>\n<blockquote>\n<p>上述为 rust 所有权基础知识，不再赘述。</p>\n</blockquote>\n<p>普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 <strong>捕获当前环境变量</strong> 的功能。</p>\n<p><strong>捕获当前环境变量</strong> 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：</p>\n<ol>\n<li>所有权 move</li>\n<li>可变借用</li>\n<li>不可变借用</li>\n</ol>\n<p>具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。</p>\n<p>回顾上面的例子，对于环境变量 <code>x</code> ，首先排除了所有权 move。</p>\n<pre><code class=\"language-rust\">    let x = 1;\r\n    let sum = |y: i32| { x + y }; // 使用了 x\r\n    println!(\"{}\", sum(99)); // 输出 100\r\n\r\n    let sum2 = |y :i32| x + y + 1; // 再次使用了 x\r\n    println!(\"{}\", sum2(99)); // 输出 101\n</code></pre>\n<blockquote>\n<p>说明： <code>x</code> 在 sum1 中使用后，还能在 sum2 中再次使用，说明 <code>x</code> 所有权没有 move。</p>\n</blockquote>\n<p>实际上，上述例子的 <code>x</code> 在闭包中是作为 <strong>不可变借用</strong> 使用的，<strong>因为这个闭包实现了 <code>Fn</code> trait</strong>。</p>\n<h2>闭包的三种 traits</h2>\n<p>闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。</p>\n<p>三种 traits 如下（划重点，请背下来）：</p>\n<ol>\n<li><code>FnOnce</code>：表示此闭包调用时会获取环境变量所有权（<strong>所有权 move</strong>)。因此取名 <code>FnOnce</code>，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。</li>\n<li><code>FnMut</code> ：表示此闭包调用时会对环境变量进行<strong>可变借用</strong>，可能会修改环境变量</li>\n<li><code>Fn</code> ： 表示此闭包调用时会对环境变量进行<strong>不可变借用</strong>，不会修改环境变量</li>\n</ol>\n<p>并且，<strong>一个闭包可以同时实现多个 traits</strong>。比如实现了 <code>Fn</code> 的闭包也一定实现了 <code>FnOnce</code> （后续解释）。</p>\n<p>上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：</p>\n<blockquote>\n<p>“实现了 <code>Fn</code> 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 <code>FnOnce</code> ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”</p>\n</blockquote>\n<p>但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 <code>FnOnce</code>（所有权 move） ，但并没有调用 <code>FnOnce</code> 的 call 函数，而是调用了 <code>Fn</code>(不可变借用) 的 call 函数。</p>\n<pre><code class=\"language-rust\">pub trait Fn&#x3C;Args> : FnMut&#x3C;Args> {\r\n    extern \"rust-call\" fn call(&#x26;self, args: Args) -> Self::Output;\r\n}\r\n\r\npub trait FnMut&#x3C;Args> : FnOnce&#x3C;Args> {\r\n    extern \"rust-call\" fn call_mut(&#x26;mut self, args: Args) -> Self::Output;\r\n}\r\n\r\npub trait FnOnce&#x3C;Args> {\r\n    type Output;\r\n\r\n    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\r\n}\n</code></pre>\n<blockquote>\n<p>分析：如果 <code>FnOnce</code> 的 call 函数被调用，则直接传入了 <code>self</code> ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 <code>Fn</code> 的 call 函数传入的是不可变借用 <code>&#x26;self</code>。</p>\n</blockquote>\n<p>并且会发现， <code>Fn</code> 的前提是实现了 <code>FnMut</code> , <code>FnMut</code> 的前提是实现了 <code>FnOnce</code> 。</p>\n<ul>\n<li>从继承关系来讲： <code>Fn</code> 继承 <code>FnMut</code> 继承 <code>FnOnce</code></li>\n<li>从访问变量的权限范围来讲： <code>Fn</code> &#x3C; <code>FnMut</code> &#x3C; <code>FnOnce</code></li>\n</ul>\n<p>也可以说，<strong>闭包就算实现了 <code>FnOnce</code> 也不一定会用到所有权 move，因为可能还实现了 <code>Fn</code> ，那么环境变量的所有权会按 <code>Fn</code> 处理</strong>。</p>\n<hr>\n<p>由于上述继承关系，如果定义一个普通函数，参数需要传入 <code>FnOnce</code> ，实际上也可以传入 <code>Fn</code> 。</p>\n<pre><code class=\"language-rust\">fn fn_once&#x3C;F>(func: F)\r\nwhere\r\n    F: FnOnce(usize) -> bool, // 传入闭包\r\n{\r\n    println!(\"{}\", func(3));\r\n}\r\n\r\nfn main() {\r\n    let x = vec![1, 2, 3];\r\n    let closure = |z|{z == x.len()}; // 此闭包实现了 Fn、 FnMut 和 FnOnce\r\n    fn_once(closure); // Fn 可传入标注为 FnOnce 的参数\r\n    println!(\"{:?}\", x); // x 还能用，所有权没转移\r\n\r\n    let closure2 = move |z|{z == x.len()}; //  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部\r\n    fn_once(closure2); // 传入 FnOnce\r\n    println!(\"{:?}\", x); // 报错，x 已经没了\r\n}\n</code></pre>\n<blockquote>\n<p>说明：fn_once 需要接收 <code>FnOnce</code> 的闭包作为参数，但传入 <code>Fn</code> 也是合理的，编译器也会按照 <code>Fn</code> 的调用方式处理为不可变借用，并不会因为标注着 <code>FnOnce</code> 而变成所有权 move。</p>\n</blockquote>\n<blockquote>\n<p>闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅</p>\n</blockquote>\n<h2>闭包实现三种 traits</h2>\n<p>上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。</p>\n<p>闭包实现 traits 是<strong>隐式</strong>的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。</p>\n<ol>\n<li>实现<code>FnOnce</code></li>\n</ol>\n<p>所有的闭包都自动实现了 <code>FnOnce</code> 。不用特别做什么。</p>\n<p>但更普遍的情况是，定义闭包时会顺带实现 <code>Fn</code> 或者 <code>FnMut</code> 。如果想要只实现 <code>FnOnce</code>，不要实现另外两个，需要用 <code>move</code> 。这个关键字会强制转移所有权，使闭包无法满足 <code>FnMut</code> 和 <code>Fn</code> 的条件。</p>\n<ul>\n<li>例：只实现了 <code>FnOnce</code> 的闭包</li>\n</ul>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = [1,2,3];\r\n    \r\n    let closure2 = move |z|{z == x.len()}; // 只实现了 FnOnce，所有权转移\r\n    closure2(2);\r\n    \r\n    println!(\"{:?}\", x); // 报错，x 所有权被转移\r\n}\n</code></pre>\n<ol start=\"2\">\n<li>实现<code>FnMut</code></li>\n</ol>\n<p>在闭包中修改外部变量，即实现了 <code>FnMut</code> （自然也实现了 <code>FnOnce</code> ），同时没有实现 <code>Fn</code> 。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let mut x = vec![1,2,3];\r\n\r\n    let mut closure = ||{x.push(4);}; // 修改了外部的 x, 实现了 FnMut， x 所有权没有转移\r\n    closure();\r\n    \r\n    println!(\"{:?}\", x);\r\n}\n</code></pre>\n<ol start=\"3\">\n<li>实现<code>Fn</code></li>\n</ol>\n<p>在闭包中访问外部变量，不做任何修改，即实现了 <code>Fn</code> （自然也实现了 <code>FnMut</code> 和 <code>FnOnce</code>）。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let s = String::new();\r\n\r\n    let update_string =  || println!(\"{}\",s); // 访问外部的 s, 实现了 Fn\r\n\r\n    exec(update_string);\r\n    exec1(update_string);\r\n    exec2(update_string);\r\n}\r\n\r\nfn exec&#x3C;F: FnOnce()>(f: F)  { // Fn 也可以传到 FnOnce 类型\r\n    f() // 调用的是 Fn，所有权不会转移\r\n}\r\n\r\nfn exec1&#x3C;F: FnMut()>(mut f: F)  { // Fn 也可以传到 FnMut 类型\r\n    f()\r\n}\r\n\r\nfn exec2&#x3C;F: Fn()>(f: F)  {\r\n    f()\r\n}\n</code></pre>\n<h2>闭包自身的所有权</h2>\n<p>上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？</p>\n<p>答案是，<code>Fn</code> 是 Copy，<code>FnMut</code> 和 <code>FnOnce</code> 是所有权 Move。</p>\n<pre><code class=\"language-rust\">fn main() {\r\n    let x = vec![1,2,3];\r\n\r\n    let closure = |z:usize|{ z == x.len()}; // 实现了 Fn\r\n    outter(closure); // 通过\r\n    outter(closure); // 通过\r\n\r\n    let closure2 = |z:usize|{ x.push(4);z == x.len()}; // 实现了 FnMut\r\n    outter(closure2); // 通过\r\n    outter(closure2); // 报错, closure2 的所有权已被转移\r\n}\r\n\r\nfn outter&#x3C;T>(mut func: T)\r\nwhere T: FnMut(usize) -> bool { // Fn 可以传到 FnMut 标注的参数上\r\n    let a = func;\r\n}\n</code></pre>\n<p>这是非常合理的，对应着 Rust 借用的规则</p>\n<blockquote>\n<p>在同一时间点，对于同一个变量，<strong>要么</strong>只能有一个可变借用(FnMut)，<strong>要么</strong>只能有<strong>多个不可变借用</strong>(Fn)。</p>\n</blockquote>\n<p>至于 <code>FnOnce</code>，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。</p>\n<h2>一些建议</h2>\n<p>如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。</p>\n<p>另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。</p>\n<p>如果仍然难懂，可评论提出，后续改进。</p>","content_jsx","const{Fragment:n,jsx:e,jsxs:l}=arguments[0];function _createMdxContent(s){const c={blockquote:\"blockquote\",code:\"code\",h2:\"h2\",hr:\"hr\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",ul:\"ul\",...s.components};return l(n,{children:[e(c.p,{children:\"本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。\"}),\"\\n\",e(c.p,{children:\"阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。\"}),\"\\n\",e(c.h2,{id:\"什么是-rust-的闭包\",children:\"什么是 Rust 的闭包\"}),\"\\n\",l(c.p,{children:[\"Rust 中的闭包是\",e(c.strong,{children:\"一种函数\"}),\"。与 Rust 普通函数不同，它可以\",e(c.strong,{children:\"捕获函数外部的变量并使用\"}),\"。\"]}),\"\\n\",l(c.p,{children:[\"基本语法：\",e(c.code,{children:\"|参数列表| {函数体}\"})]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = \",e(c.span,{className:\"hljs-number\",children:\"1\"}),\";\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"sum\"}),\" = |y: \",e(c.span,{className:\"hljs-type\",children:\"i32\"}),\"| { x + y }; \",e(c.span,{className:\"hljs-comment\",children:\"// 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\", \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"sum\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"99\"}),\")); \",e(c.span,{className:\"hljs-comment\",children:\"// 输出 100\"}),\"\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"sum2\"}),\" = |y :\",e(c.span,{className:\"hljs-type\",children:\"i32\"}),\"| x + y + \",e(c.span,{className:\"hljs-number\",children:\"1\"}),\"; \",e(c.span,{className:\"hljs-comment\",children:\"// 也可以省略花括号\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\", \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"sum2\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"99\"}),\")); \",e(c.span,{className:\"hljs-comment\",children:\"// 输出 101\"}),\"\\r\\n}\\n\"]})}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 \",e(c.code,{children:\"let x = 1;\"}),\" ，为闭包外部的变量。\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"像 \",e(c.code,{children:\"x\"}),\" 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“\",e(c.strong,{children:\"环境变量\"}),\"”。\"]}),\"\\n\",e(c.h2,{id:\"闭包中环境变量的所有权\",children:\"闭包中环境变量的所有权\"}),\"\\n\",e(c.p,{children:\"有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式\"}),\"\\n\",l(c.ol,{children:[\"\\n\",e(c.li,{children:\"所有权 move（默认行为）。\"}),\"\\n\",l(c.li,{children:[\"可变借用，形式为 \",e(c.code,{children:\"&mut param\"})]}),\"\\n\",l(c.li,{children:[\"不可变借用 ，形式为 \",e(c.code,{children:\"&param\"})]}),\"\\n\"]}),\"\\n\",l(c.blockquote,{children:[\"\\n\",e(c.p,{children:\"上述为 rust 所有权基础知识，不再赘述。\"}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 \",e(c.strong,{children:\"捕获当前环境变量\"}),\" 的功能。\"]}),\"\\n\",l(c.p,{children:[e(c.strong,{children:\"捕获当前环境变量\"}),\" 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：\"]}),\"\\n\",l(c.ol,{children:[\"\\n\",e(c.li,{children:\"所有权 move\"}),\"\\n\",e(c.li,{children:\"可变借用\"}),\"\\n\",e(c.li,{children:\"不可变借用\"}),\"\\n\"]}),\"\\n\",e(c.p,{children:\"具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。\"}),\"\\n\",l(c.p,{children:[\"回顾上面的例子，对于环境变量 \",e(c.code,{children:\"x\"}),\" ，首先排除了所有权 move。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[\"    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = \",e(c.span,{className:\"hljs-number\",children:\"1\"}),\";\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"sum\"}),\" = |y: \",e(c.span,{className:\"hljs-type\",children:\"i32\"}),\"| { x + y }; \",e(c.span,{className:\"hljs-comment\",children:\"// 使用了 x\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\", \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"sum\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"99\"}),\")); \",e(c.span,{className:\"hljs-comment\",children:\"// 输出 100\"}),\"\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"sum2\"}),\" = |y :\",e(c.span,{className:\"hljs-type\",children:\"i32\"}),\"| x + y + \",e(c.span,{className:\"hljs-number\",children:\"1\"}),\"; \",e(c.span,{className:\"hljs-comment\",children:\"// 再次使用了 x\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\", \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"sum2\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"99\"}),\")); \",e(c.span,{className:\"hljs-comment\",children:\"// 输出 101\"}),\"\\n\"]})}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"说明： \",e(c.code,{children:\"x\"}),\" 在 sum1 中使用后，还能在 sum2 中再次使用，说明 \",e(c.code,{children:\"x\"}),\" 所有权没有 move。\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"实际上，上述例子的 \",e(c.code,{children:\"x\"}),\" 在闭包中是作为 \",e(c.strong,{children:\"不可变借用\"}),\" 使用的，\",l(c.strong,{children:[\"因为这个闭包实现了 \",e(c.code,{children:\"Fn\"}),\" trait\"]}),\"。\"]}),\"\\n\",e(c.h2,{id:\"闭包的三种-traits\",children:\"闭包的三种 traits\"}),\"\\n\",e(c.p,{children:\"闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。\"}),\"\\n\",e(c.p,{children:\"三种 traits 如下（划重点，请背下来）：\"}),\"\\n\",l(c.ol,{children:[\"\\n\",l(c.li,{children:[e(c.code,{children:\"FnOnce\"}),\"：表示此闭包调用时会获取环境变量所有权（\",e(c.strong,{children:\"所有权 move\"}),\")。因此取名 \",e(c.code,{children:\"FnOnce\"}),\"，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。\"]}),\"\\n\",l(c.li,{children:[e(c.code,{children:\"FnMut\"}),\" ：表示此闭包调用时会对环境变量进行\",e(c.strong,{children:\"可变借用\"}),\"，可能会修改环境变量\"]}),\"\\n\",l(c.li,{children:[e(c.code,{children:\"Fn\"}),\" ： 表示此闭包调用时会对环境变量进行\",e(c.strong,{children:\"不可变借用\"}),\"，不会修改环境变量\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"并且，\",e(c.strong,{children:\"一个闭包可以同时实现多个 traits\"}),\"。比如实现了 \",e(c.code,{children:\"Fn\"}),\" 的闭包也一定实现了 \",e(c.code,{children:\"FnOnce\"}),\" （后续解释）。\"]}),\"\\n\",e(c.p,{children:\"上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：\"}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"“实现了 \",e(c.code,{children:\"Fn\"}),\" 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 \",e(c.code,{children:\"FnOnce\"}),\" ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 \",e(c.code,{children:\"FnOnce\"}),\"（所有权 move） ，但并没有调用 \",e(c.code,{children:\"FnOnce\"}),\" 的 call 函数，而是调用了 \",e(c.code,{children:\"Fn\"}),\"(不可变借用) 的 call 函数。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"pub\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"trait\"}),\" \",e(c.span,{className:\"hljs-title class_\",children:\"Fn\"}),\"<Args> : \",e(c.span,{className:\"hljs-built_in\",children:\"FnMut\"}),\"<Args> {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"extern\"}),\" \",e(c.span,{className:\"hljs-string\",children:'\"rust-call\"'}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"call\"}),\"(&\",e(c.span,{className:\"hljs-keyword\",children:\"self\"}),\", args: Args) \",e(c.span,{className:\"hljs-punctuation\",children:\"->\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"Self\"}),\"::Output;\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"pub\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"trait\"}),\" \",e(c.span,{className:\"hljs-title class_\",children:\"FnMut\"}),\"<Args> : \",e(c.span,{className:\"hljs-built_in\",children:\"FnOnce\"}),\"<Args> {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"extern\"}),\" \",e(c.span,{className:\"hljs-string\",children:'\"rust-call\"'}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"call_mut\"}),\"(&\",e(c.span,{className:\"hljs-keyword\",children:\"mut\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"self\"}),\", args: Args) \",e(c.span,{className:\"hljs-punctuation\",children:\"->\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"Self\"}),\"::Output;\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"pub\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"trait\"}),\" \",e(c.span,{className:\"hljs-title class_\",children:\"FnOnce\"}),\"<Args> {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"type\"}),\" \",e(c.span,{className:\"hljs-title class_\",children:\"Output\"}),\";\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"extern\"}),\" \",e(c.span,{className:\"hljs-string\",children:'\"rust-call\"'}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"call_once\"}),\"(\",e(c.span,{className:\"hljs-keyword\",children:\"self\"}),\", args: Args) \",e(c.span,{className:\"hljs-punctuation\",children:\"->\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"Self\"}),\"::Output;\\r\\n}\\n\"]})}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"分析：如果 \",e(c.code,{children:\"FnOnce\"}),\" 的 call 函数被调用，则直接传入了 \",e(c.code,{children:\"self\"}),\" ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 \",e(c.code,{children:\"Fn\"}),\" 的 call 函数传入的是不可变借用 \",e(c.code,{children:\"&self\"}),\"。\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"并且会发现， \",e(c.code,{children:\"Fn\"}),\" 的前提是实现了 \",e(c.code,{children:\"FnMut\"}),\" , \",e(c.code,{children:\"FnMut\"}),\" 的前提是实现了 \",e(c.code,{children:\"FnOnce\"}),\" 。\"]}),\"\\n\",l(c.ul,{children:[\"\\n\",l(c.li,{children:[\"从继承关系来讲： \",e(c.code,{children:\"Fn\"}),\" 继承 \",e(c.code,{children:\"FnMut\"}),\" 继承 \",e(c.code,{children:\"FnOnce\"})]}),\"\\n\",l(c.li,{children:[\"从访问变量的权限范围来讲： \",e(c.code,{children:\"Fn\"}),\" < \",e(c.code,{children:\"FnMut\"}),\" < \",e(c.code,{children:\"FnOnce\"})]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"也可以说，\",l(c.strong,{children:[\"闭包就算实现了 \",e(c.code,{children:\"FnOnce\"}),\" 也不一定会用到所有权 move，因为可能还实现了 \",e(c.code,{children:\"Fn\"}),\" ，那么环境变量的所有权会按 \",e(c.code,{children:\"Fn\"}),\" 处理\"]}),\"。\"]}),\"\\n\",e(c.hr,{}),\"\\n\",l(c.p,{children:[\"由于上述继承关系，如果定义一个普通函数，参数需要传入 \",e(c.code,{children:\"FnOnce\"}),\" ，实际上也可以传入 \",e(c.code,{children:\"Fn\"}),\" 。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"fn_once\"}),\"<F>(func: F)\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"where\"}),\"\\r\\n    F: \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"FnOnce\"}),\"(\",e(c.span,{className:\"hljs-type\",children:\"usize\"}),\") \",e(c.span,{className:\"hljs-punctuation\",children:\"->\"}),\" \",e(c.span,{className:\"hljs-type\",children:\"bool\"}),\", \",e(c.span,{className:\"hljs-comment\",children:\"// 传入闭包\"}),\"\\r\\n{\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\", \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"func\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"3\"}),\"));\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = \",e(c.span,{className:\"hljs-built_in\",children:\"vec!\"}),\"[\",e(c.span,{className:\"hljs-number\",children:\"1\"}),\", \",e(c.span,{className:\"hljs-number\",children:\"2\"}),\", \",e(c.span,{className:\"hljs-number\",children:\"3\"}),\"];\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"closure\"}),\" = |z|{z == x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"len\"}),\"()}; \",e(c.span,{className:\"hljs-comment\",children:\"// 此闭包实现了 Fn、 FnMut 和 FnOnce\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"fn_once\"}),\"(closure); \",e(c.span,{className:\"hljs-comment\",children:\"// Fn 可传入标注为 FnOnce 的参数\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{:?}\"'}),\", x); \",e(c.span,{className:\"hljs-comment\",children:\"// x 还能用，所有权没转移\"}),\"\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"closure2\"}),\" = \",e(c.span,{className:\"hljs-keyword\",children:\"move\"}),\" |z|{z == x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"len\"}),\"()}; \",e(c.span,{className:\"hljs-comment\",children:\"//  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"fn_once\"}),\"(closure2); \",e(c.span,{className:\"hljs-comment\",children:\"// 传入 FnOnce\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{:?}\"'}),\", x); \",e(c.span,{className:\"hljs-comment\",children:\"// 报错，x 已经没了\"}),\"\\r\\n}\\n\"]})}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"说明：fn_once 需要接收 \",e(c.code,{children:\"FnOnce\"}),\" 的闭包作为参数，但传入 \",e(c.code,{children:\"Fn\"}),\" 也是合理的，编译器也会按照 \",e(c.code,{children:\"Fn\"}),\" 的调用方式处理为不可变借用，并不会因为标注着 \",e(c.code,{children:\"FnOnce\"}),\" 而变成所有权 move。\"]}),\"\\n\"]}),\"\\n\",l(c.blockquote,{children:[\"\\n\",e(c.p,{children:\"闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅\"}),\"\\n\"]}),\"\\n\",e(c.h2,{id:\"闭包实现三种-traits\",children:\"闭包实现三种 traits\"}),\"\\n\",e(c.p,{children:\"上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。\"}),\"\\n\",l(c.p,{children:[\"闭包实现 traits 是\",e(c.strong,{children:\"隐式\"}),\"的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。\"]}),\"\\n\",l(c.ol,{children:[\"\\n\",l(c.li,{children:[\"实现\",e(c.code,{children:\"FnOnce\"})]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"所有的闭包都自动实现了 \",e(c.code,{children:\"FnOnce\"}),\" 。不用特别做什么。\"]}),\"\\n\",l(c.p,{children:[\"但更普遍的情况是，定义闭包时会顺带实现 \",e(c.code,{children:\"Fn\"}),\" 或者 \",e(c.code,{children:\"FnMut\"}),\" 。如果想要只实现 \",e(c.code,{children:\"FnOnce\"}),\"，不要实现另外两个，需要用 \",e(c.code,{children:\"move\"}),\" 。这个关键字会强制转移所有权，使闭包无法满足 \",e(c.code,{children:\"FnMut\"}),\" 和 \",e(c.code,{children:\"Fn\"}),\" 的条件。\"]}),\"\\n\",l(c.ul,{children:[\"\\n\",l(c.li,{children:[\"例：只实现了 \",e(c.code,{children:\"FnOnce\"}),\" 的闭包\"]}),\"\\n\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = [\",e(c.span,{className:\"hljs-number\",children:\"1\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"2\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"3\"}),\"];\\r\\n    \\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"closure2\"}),\" = \",e(c.span,{className:\"hljs-keyword\",children:\"move\"}),\" |z|{z == x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"len\"}),\"()}; \",e(c.span,{className:\"hljs-comment\",children:\"// 只实现了 FnOnce，所有权转移\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"closure2\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"2\"}),\");\\r\\n    \\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{:?}\"'}),\", x); \",e(c.span,{className:\"hljs-comment\",children:\"// 报错，x 所有权被转移\"}),\"\\r\\n}\\n\"]})}),\"\\n\",l(c.ol,{start:\"2\",children:[\"\\n\",l(c.li,{children:[\"实现\",e(c.code,{children:\"FnMut\"})]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"在闭包中修改外部变量，即实现了 \",e(c.code,{children:\"FnMut\"}),\" （自然也实现了 \",e(c.code,{children:\"FnOnce\"}),\" ），同时没有实现 \",e(c.code,{children:\"Fn\"}),\" 。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"mut \"}),e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = \",e(c.span,{className:\"hljs-built_in\",children:\"vec!\"}),\"[\",e(c.span,{className:\"hljs-number\",children:\"1\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"2\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"3\"}),\"];\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-keyword\",children:\"mut \"}),e(c.span,{className:\"hljs-variable\",children:\"closure\"}),\" = ||{x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"push\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"4\"}),\");}; \",e(c.span,{className:\"hljs-comment\",children:\"// 修改了外部的 x, 实现了 FnMut， x 所有权没有转移\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"closure\"}),\"();\\r\\n    \\r\\n    \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{:?}\"'}),\", x);\\r\\n}\\n\"]})}),\"\\n\",l(c.ol,{start:\"3\",children:[\"\\n\",l(c.li,{children:[\"实现\",e(c.code,{children:\"Fn\"})]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"在闭包中访问外部变量，不做任何修改，即实现了 \",e(c.code,{children:\"Fn\"}),\" （自然也实现了 \",e(c.code,{children:\"FnMut\"}),\" 和 \",e(c.code,{children:\"FnOnce\"}),\"）。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"s\"}),\" = \",e(c.span,{className:\"hljs-type\",children:\"String\"}),\"::\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"new\"}),\"();\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"update_string\"}),\" =  || \",e(c.span,{className:\"hljs-built_in\",children:\"println!\"}),\"(\",e(c.span,{className:\"hljs-string\",children:'\"{}\"'}),\",s); \",e(c.span,{className:\"hljs-comment\",children:\"// 访问外部的 s, 实现了 Fn\"}),\"\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"exec\"}),\"(update_string);\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"exec1\"}),\"(update_string);\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"exec2\"}),\"(update_string);\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"exec\"}),\"<F: \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"FnOnce\"}),\"()>(f: F)  { \",e(c.span,{className:\"hljs-comment\",children:\"// Fn 也可以传到 FnOnce 类型\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"f\"}),\"() \",e(c.span,{className:\"hljs-comment\",children:\"// 调用的是 Fn，所有权不会转移\"}),\"\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"exec1\"}),\"<F: \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"FnMut\"}),\"()>(\",e(c.span,{className:\"hljs-keyword\",children:\"mut\"}),\" f: F)  { \",e(c.span,{className:\"hljs-comment\",children:\"// Fn 也可以传到 FnMut 类型\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"f\"}),\"()\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"exec2\"}),\"<F: \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"Fn\"}),\"()>(f: F)  {\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"f\"}),\"()\\r\\n}\\n\"]})}),\"\\n\",e(c.h2,{id:\"闭包自身的所有权\",children:\"闭包自身的所有权\"}),\"\\n\",e(c.p,{children:\"上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？\"}),\"\\n\",l(c.p,{children:[\"答案是，\",e(c.code,{children:\"Fn\"}),\" 是 Copy，\",e(c.code,{children:\"FnMut\"}),\" 和 \",e(c.code,{children:\"FnOnce\"}),\" 是所有权 Move。\"]}),\"\\n\",e(c.pre,{children:l(c.code,{className:\"hljs language-rust\",children:[e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"main\"}),\"() {\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"x\"}),\" = \",e(c.span,{className:\"hljs-built_in\",children:\"vec!\"}),\"[\",e(c.span,{className:\"hljs-number\",children:\"1\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"2\"}),\",\",e(c.span,{className:\"hljs-number\",children:\"3\"}),\"];\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"closure\"}),\" = |z:\",e(c.span,{className:\"hljs-type\",children:\"usize\"}),\"|{ z == x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"len\"}),\"()}; \",e(c.span,{className:\"hljs-comment\",children:\"// 实现了 Fn\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"outter\"}),\"(closure); \",e(c.span,{className:\"hljs-comment\",children:\"// 通过\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"outter\"}),\"(closure); \",e(c.span,{className:\"hljs-comment\",children:\"// 通过\"}),\"\\r\\n\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"closure2\"}),\" = |z:\",e(c.span,{className:\"hljs-type\",children:\"usize\"}),\"|{ x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"push\"}),\"(\",e(c.span,{className:\"hljs-number\",children:\"4\"}),\");z == x.\",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"len\"}),\"()}; \",e(c.span,{className:\"hljs-comment\",children:\"// 实现了 FnMut\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"outter\"}),\"(closure2); \",e(c.span,{className:\"hljs-comment\",children:\"// 通过\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"outter\"}),\"(closure2); \",e(c.span,{className:\"hljs-comment\",children:\"// 报错, closure2 的所有权已被转移\"}),\"\\r\\n}\\r\\n\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"fn\"}),\" \",e(c.span,{className:\"hljs-title function_\",children:\"outter\"}),\"<T>(\",e(c.span,{className:\"hljs-keyword\",children:\"mut\"}),\" func: T)\\r\\n\",e(c.span,{className:\"hljs-keyword\",children:\"where\"}),\" T: \",e(c.span,{className:\"hljs-title function_ invoke__\",children:\"FnMut\"}),\"(\",e(c.span,{className:\"hljs-type\",children:\"usize\"}),\") \",e(c.span,{className:\"hljs-punctuation\",children:\"->\"}),\" \",e(c.span,{className:\"hljs-type\",children:\"bool\"}),\" { \",e(c.span,{className:\"hljs-comment\",children:\"// Fn 可以传到 FnMut 标注的参数上\"}),\"\\r\\n    \",e(c.span,{className:\"hljs-keyword\",children:\"let\"}),\" \",e(c.span,{className:\"hljs-variable\",children:\"a\"}),\" = func;\\r\\n}\\n\"]})}),\"\\n\",e(c.p,{children:\"这是非常合理的，对应着 Rust 借用的规则\"}),\"\\n\",l(c.blockquote,{children:[\"\\n\",l(c.p,{children:[\"在同一时间点，对于同一个变量，\",e(c.strong,{children:\"要么\"}),\"只能有一个可变借用(FnMut)，\",e(c.strong,{children:\"要么\"}),\"只能有\",e(c.strong,{children:\"多个不可变借用\"}),\"(Fn)。\"]}),\"\\n\"]}),\"\\n\",l(c.p,{children:[\"至于 \",e(c.code,{children:\"FnOnce\"}),\"，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。\"]}),\"\\n\",e(c.h2,{id:\"一些建议\",children:\"一些建议\"}),\"\\n\",e(c.p,{children:\"如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。\"}),\"\\n\",e(c.p,{children:\"另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。\"}),\"\\n\",e(c.p,{children:\"如果仍然难懂，可评论提出，后续改进。\"})]})}return{default:function(n={}){const{wrapper:l}=n.components||{};return l?e(l,{...n,children:e(_createMdxContent,{...n})}):_createMdxContent(n)}};","toc",[31,37,41,45,49,53],{"_7":32,"_33":34,"_35":36},"什么是 Rust 的闭包","url","#什么是-rust-的闭包","items",[],{"_7":38,"_33":39,"_35":40},"闭包中环境变量的所有权","#闭包中环境变量的所有权",[],{"_7":42,"_33":43,"_35":44},"闭包的三种 traits","#闭包的三种-traits",[],{"_7":46,"_33":47,"_35":48},"闭包实现三种 traits","#闭包实现三种-traits",[],{"_7":50,"_33":51,"_35":52},"闭包自身的所有权","#闭包自身的所有权",[],{"_7":54,"_33":55,"_35":56},"一些建议","#一些建议",[],"tags",[59],"Rust","categories","学习","keywords",[59,64,65,66],"闭包","Closure","所有权","permalink","/posts/rust-closure-and-ownership","prevPost",{"_7":71,"_9":71},"记一道题排列组合题解","nextPost",{"_7":74,"_9":74},"PPT母版的制作与使用方法"]
