<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EDE15EB3W8"></script><title>理解 Rust 闭包与环境变量所有权</title><meta name="description" content="B站反查用户弹幕小记"/><meta name="keywords" content="Rust, 闭包, Closure, 所有权, Rust, 学习"/><meta name="author" content="Sansui"/><meta property="og:title" content="理解 Rust 闭包与环境变量所有权"/><meta property="og:description" content="B站反查用户弹幕小记"/><meta property="og:type" content="article"/><meta property="og:url" content="https://sansui233.com/posts/rust-closure-and-ownership"/><meta property="article:published_time" content="2022-06-13T16:00:00.000Z"/><meta property="article:author" content="Sansui"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="理解 Rust 闭包与环境变量所有权"/><meta name="twitter:description" content="B站反查用户弹幕小记"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link rel="modulepreload" href="/assets/manifest-d60f763c.js"/><link rel="modulepreload" href="/assets/entry.client-DkTTQJrl.js"/><link rel="modulepreload" href="/assets/chunk-JMJ3UQ3L-BVFOw7ai.js"/><link rel="modulepreload" href="/assets/index-HqdIF0eP.js"/><link rel="modulepreload" href="/assets/root-BTnctABI.js"/><link rel="modulepreload" href="/assets/i18nInstance-DPKwMV5N.js"/><link rel="modulepreload" href="/assets/i18n-C8hHMX00.js"/><link rel="modulepreload" href="/assets/RootLayout-DE8aOQ2E.js"/><link rel="modulepreload" href="/assets/throttle-DwQFwEus.js"/><link rel="modulepreload" href="/assets/index-CHWdbJsA.js"/><link rel="modulepreload" href="/assets/use-appstate-wXf1X0hJ.js"/><link rel="modulepreload" href="/assets/posts._slug-Cjebqe66.js"/><link rel="modulepreload" href="/assets/MDXComponent-BzBGnsZ7.js"/><link rel="modulepreload" href="/assets/use-date-i18n-CH95KIPY.js"/><link rel="modulepreload" href="/assets/folder-Dg4Z__4I.js"/><link rel="stylesheet" href="/assets/root-CljjewJY.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&amp;display=swap"/><link rel="stylesheet" href="/assets/posts-CMWrxi_F.css"/><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-EDE15EB3W8', {
                page_path: window.location.pathname,
              });
            </script></head><body><div id="initial-progress" style="position:fixed;top:0;left:0;height:2px;width:0;background:var(--accent);z-index:9999;animation:progressLoading 3s ease-out forwards"></div><!--$?--><template id="B:0"></template><!--/$--><section class="bg-bg/90 fixed inset-0 z-8 h-full w-full overflow-auto backdrop-blur-[6px] transition-all duration-500 ease-[cubic-bezier(0.46,0,0.08,1.11)] pointer-events-none opacity-0 "><div class="relative mx-auto pt-32 pb-23 text-center font-bold"><h1 class="
    transition-all duration-1000 ease-out transform
    delay-0
    opacity-0 -translate-y-8
  "><span class="relative inline-block">SANSUI的博客<span class="bg-accent-hover absolute bottom-0 left-0 -z-10 h-[0.5em] w-full rounded-[0.5em] mix-blend-overlay"></span></span></h1><div class="mt-8 
    transition-all duration-1000 ease-out transform
    delay-100
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110">系统外观</span></div><div class="mt-4 
    transition-all duration-1000 ease-out transform
    delay-200
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110"><a href="/categories" data-discover="true">分类标签</a></span></div><div class="mt-4 
    transition-all duration-1000 ease-out transform
    delay-300
    opacity-0 -translate-y-8
  "><span class="hover:text-accent-hover relative inline-block cursor-pointer text-[1.625rem] leading-11 transition-transform duration-300 ease-out hover:scale-110"><a href="/atom.xml">RSS</a></span></div><div class="pt-12 text-[10px] font-normal 
    transition-all duration-1000 ease-out transform
    delay-400
    opacity-0 -translate-y-8
  "><div class="my-4 flex items-center justify-center"><a href="https://github.com/sansui233" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="mailto:sansuilnm@gmail.com" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail" aria-hidden="true"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"></path><rect x="2" y="4" width="20" height="16" rx="2"></rect></svg></a><a href="/rss" class="text-text-primary hover:text-accent-hover mx-1 transition-colors [&amp;&gt;svg]:h-6 [&amp;&gt;svg]:w-6" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss" aria-hidden="true"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></div><div class="mx-auto my-4 leading-relaxed">© Sansui 2026<br/>All rights reserved</div></div></div><div class="fixed top-5.5 right-5 z-5 h-5 w-6"><div class="flex flex-col justify-between cursor-pointer " style="width:1rem;height:1rem" aria-expanded="true" aria-label="Toggle menu"><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-0"></div><div class="relative h-0.5 w-full"><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-45"></div><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out -rotate-45"></div></div><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-0"></div></div></div></section><header class="bg-bg/60 fixed z-10 box-content flex h-15.75 w-full items-center justify-between backdrop-blur-[6px] transition-transform duration-500 ease-out translate-y-0 "><div class="w-52.5 flex-auto items-center justify-start font-semibold max-md:w-25"><a class="flex items-center px-4" href="/" data-discover="true"><svg fill="currentColor" id="flat-neko" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72" width="36" class="shrink-0"><path d="m68.24,44.97c.54-.13.86-.68.73-1.21m0,0c-.13-.54-.68-.86-1.21-.73l-4.61,1.15c1.06-5.18.9-11.77-1.14-20.18,0-7-1.45-14.23-3.24-14.91-1.99-.75-11.76,5.91-12.76,8.91-7-2-13-2-20,0-1-3-10.77-9.66-12.76-8.91-1.79.67-3.24,7.91-3.24,14.91-2.05,8.41-2.2,15-1.14,20.18l-4.61-1.15c-.54-.13-1.08.19-1.21.73-.13.54.19,1.08.73,1.21l5.64,1.41c.33,1.14.72,2.21,1.18,3.2l-4.67.42c-.55.05-.96.54-.91,1.09.05.52.48.91,1,.91.03,0,.06,0,.09,0l5.49-.5c.44.75.92,1.46,1.42,2.11l-4.32,1.44c-.52.17-.81.74-.63,1.26.14.42.53.68.95.68.1,0,.21-.02.32-.05l5.08-1.69c6.8,7.11,17.32,7.75,21.6,7.75s14.8-.63,21.6-7.75l5.08,1.69c.11.04.21.05.32.05.42,0,.81-.26.95-.68.17-.52-.11-1.09-.63-1.26l-4.32-1.44c.51-.66.98-1.36,1.42-2.11l5.49.5s.06,0,.09,0c.51,0,.95-.39,1-.91.05-.55-.36-1.04-.91-1.09l-4.67-.42c.45-.99.84-2.06,1.18-3.2l5.64-1.41m-47.24,1.03c-5-1-7-5-6-10,.81-4.04,4.59-7.63,9-7,4.39.63,6.81,4.04,6.64,8.74-.18,4.98-4.64,9.26-9.64,8.26Zm21.45,1.28c-.64.32-1.36.48-2.09.48-.67,0-1.36-.14-2.01-.41-.94-.39-1.74-1.01-2.35-1.83-.61.81-1.41,1.44-2.35,1.83-1.37.57-2.87.54-4.1-.07-.49-.25-.69-.85-.45-1.34.25-.49.85-.69,1.34-.45.7.35,1.61.36,2.44.02,1.01-.42,1.78-1.28,2.16-2.44.03-.09.08-.17.13-.25-.7-.31-1.18-1.01-1.18-1.82,0-1.1.9-2,2-2s2,.9,2,2c0,.81-.49,1.51-1.18,1.82.05.08.1.16.13.25.38,1.15,1.15,2.02,2.16,2.44.83.34,1.74.34,2.44-.02.49-.25,1.09-.05,1.34.45s.05,1.09-.45,1.34Zm8.55-1.28c-5,1-9.46-3.28-9.64-8.26-.17-4.71,2.25-8.11,6.64-8.74,4.41-.63,8.19,2.96,9,7,1,5-1,9-6,10Z"></path><path d="m26,33c-.55,0-1-.45-1-1,0-.45.3-.81.7-.94-.16-.09-.32-.19-.5-.25-2.2-.81-5.2.19-6.82,3.53-1.6,3.29-1.17,7.39,2.48,8.79,3.31,1.27,7.01-.77,7.53-4.63.35-2.62-.16-4.96-1.41-6.41-.04.51-.46.92-.98.92Z"></path><path d="m53.62,34.34c-.45-.93-1.02-1.66-1.64-2.24-.05.51-.46.9-.98.9-.55,0-1-.45-1-1,0-.4.24-.74.57-.9-1.27-.63-2.63-.72-3.78-.3-2.52.92-3.68,4.05-3.19,7.69.52,3.85,4.23,5.9,7.53,4.63,3.64-1.4,4.07-5.49,2.48-8.79Z"></path></svg><span class="px-2 max-md:hidden">Sansui的博客</span></a></div><nav class="relative flex max-w-[50%] flex-[2_1_auto] items-center justify-evenly tracking-wide max-[580px]:hidden min-[580px]:max-w-97.5"><div class="bg-accent-hover pointer-events-none absolute top-[1.1em] -z-10 h-[0.4em] w-[0.4em] rounded-full" style="opacity:0"></div><div class="bg-accent-hover pointer-events-none absolute top-[1.1em] -z-10 h-[0.4em] rounded-[0.5em] " style="opacity:0"></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 text-text-primary" href="/" data-discover="true">文章</a></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 " href="/memos" data-discover="true">说说</a></div><div class="px-2 pt-0.5 font-semibold"><a class="hover:text-accent relative transition-colors duration-300 " href="/about" data-discover="true">关于</a></div></nav><div class="flex w-52.5 flex-auto items-center justify-end max-md:w-25 [&amp;&gt;div]:mr-4"><div class="relative min-w-14.25 text-xl font-semibold min-[580px]:hidden"><div class="absolute -top-2 left-0 w-full pt-10 transition-all duration-300 invisible border-transparent "><a class="text-text-secondary my-2 block px-1 pb-1 pl-2.75 transition-all duration-500 pointer-events-none opacity-0 blur-md " href="/memos" data-discover="true">说说</a><a class="text-text-secondary my-2 block px-1 pb-1 pl-2.75 transition-all duration-500 pointer-events-none opacity-0 blur-md " href="/about" data-discover="true">关于</a></div><button class="text-text-primary relative flex items-center px-3">文章<svg xmlns="http://www.w3.org/2000/svg" width="1.25em" height="1.25em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down -mr-2" aria-hidden="true"><path d="m6 9 6 6 6-6"></path></svg></button></div><div class="cursor-pointer transition-colors duration-300   hover:text-accent-hover"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search" aria-hidden="true"><path d="m21 21-4.34-4.34"></path><circle cx="11" cy="11" r="8"></circle></svg></div><div class="mr-5 w-5.5"><div class="flex flex-col justify-between cursor-pointer " style="width:100%;height:1.15rem" aria-expanded="false" aria-label="Toggle menu"><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-100"></div><div class="relative h-0.5 w-full"><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-0"></div><div class="absolute top-0 left-0 h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out rotate-0"></div></div><div class="h-[2px] w-full rounded-sm bg-text-primary transition-all duration-300 ease-in-out opacity-100"></div></div></div></div></header><div class="text-accent h-15.75 w-full pt-2.5 text-center font-serif text-[10px] italic opacity-60">人活着就是为了卡卡西</div><div class="mx-auto w-170 px-5 py-15 max-xl:w-[calc(100%-480px)] max-xl:max-w-170 max-lg:w-auto max-lg:max-w-170 max-sm:w-full max-sm:py-12"><article><h1 class="mt-0 mb-0 text-center">理解 Rust 闭包与环境变量所有权</h1><div class="mt-4 text-center text-sm font-semibold text-[#989898]">2022年6月14日</div><div class="mt-4 mb-6 pb-6 text-center text-sm font-semibold"><div class="inline-block max-w-1/2"><span class="pr-2 text-sm leading-6"><a class="text-text-primary hover:text-accent transition-colors" href="/categories/学习" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="1.1em" height="1.1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-folder mr-0.5 ml-2 inline pb-0.5" aria-hidden="true"><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"></path></svg>学习</a></span><span class="text-sm leading-none"><a class="bg-tag-bg text-text-secondary hover:bg-accent-hover m-px inline-block rounded-full px-2 py-1 transition-colors" href="/tags/Rust" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="0.875em" height="0.875em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-tag mr-0.5 inline" aria-hidden="true"><path d="M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z"></path><circle cx="7.5" cy="7.5" r=".5" fill="currentColor"></circle></svg>Rust</a></span></div></div><section><div class="text-right text-sm opacity-50"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eye mr-1 mb-0.5" aria-hidden="true"><path d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"></path><circle cx="12" cy="12" r="3"></circle></svg><span class="waline-pageview-count mr-1" data-path="/posts/rust-closure-and-ownership"></span>阅读<span class="hover:text-accent cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-square mr-1 mb-0.5 ml-4" aria-hidden="true"><path d="M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z"></path></svg><span class="waline-comment-count mr-1" data-path="/posts/rust-closure-and-ownership"></span>评论</span></div></section><div class="markdown-wrapper"></div><section><div class="mt-16 text-right text-sm opacity-50">更新于 <!-- -->2022-06-13</div></section><div class="my-16 flex flex-wrap items-center justify-between"><div class="flex-1"><a class="group inline-flex items-center py-1" href="/posts/记一道题排列组合题解" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left -translate-y-px" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg><span class="relative mx-2">记一道题排列组合题解<span class="absolute bottom-0 left-0 h-0.5 w-0 rounded bg-accent-hover transition-[width] duration-1000 ease-[cubic-bezier(0.34,0.04,0.03,1.4)] group-hover:w-full"></span></span></a></div><div class="flex-1"><a class="group inline-flex items-center justify-end py-1 w-full" href="/posts/PPT母版的制作与使用方法" data-discover="true"><span class="relative mx-2">PPT母版的制作与使用方法<span class="absolute bottom-0 left-0 h-0.5 w-0 rounded bg-accent-hover transition-[width] duration-1000 ease-[cubic-bezier(0.34,0.04,0.03,1.4)] group-hover:w-full"></span></span><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right -translate-y-px" aria-hidden="true"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg></a></div></div></article><!--$--><div id="waline">Waline</div><!--/$--></div><aside class="/* Desktop positioning */ fixed left-[78%] z-5 w-72 max-w-72 overflow-auto transition-[top] duration-300 xl:animate-[fadeInRight_0.3s_ease] top-32 max-h-[calc(100vh-8rem)] /* Tablet: narrower */ /* Mobile: drawer from bottom/right */ max-lg:bg-bg max-lg:shadow-float-menu max-lg:border-ui-line-gray-3 max-xl:left-[76%] max-xl:w-60 max-lg:top-auto max-lg:right-2 max-lg:bottom-34 max-lg:left-auto max-lg:max-h-[calc(100vh-8rem-9rem)] max-lg:w-75 max-lg:rounded-lg max-lg:border max-lg:transition-all max-lg:duration-300 max-lg:pointer-events-none max-lg:translate-x-full max-lg:opacity-0 /* Small mobile: full width drawer from bottom */ max-sm:right-[2%] max-sm:bottom-0 max-sm:max-h-[60vh] max-sm:w-[96%] max-sm:max-w-none max-sm:translate-x-0 max-sm:translate-y-full "><div class="max-lg:bg-bg sticky top-0 z-9 mb-2 pt-4 pr-4 pb-2 pl-8 text-xl font-bold max-lg:pr-4 max-lg:pl-8">目录<button class="text-text-gray-2 hover:text-accent float-right hidden cursor-pointer text-[1rem] max-lg:block invisible "><svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="1.5em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x" aria-hidden="true"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg></button></div><nav class="pr-4 pb-4 pl-8 max-lg:px-6 max-lg:pr-4 max-lg:pl-8"><div class="relative"><a href="#什么是-rust-的闭包" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">什么是 Rust 的闭包</span></a><a href="#闭包中环境变量的所有权" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">闭包中环境变量的所有权</span></a><a href="#闭包的三种-traits" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">闭包的三种 traits</span></a><a href="#闭包实现三种-traits" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">闭包实现三种 traits</span></a><a href="#闭包自身的所有权" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">闭包自身的所有权</span></a><a href="#一些建议" style="padding-left:0em" class="toc-link "><span class="transition-shadow duration-500">一些建议</span></a></div></nav></aside><button class="text-text-gray-2 bg-tag-bg hover:text-text-primary active:bg-accent-hover active:text-text-primary fixed right-4 bottom-8 z-5 h-10 w-10 cursor-pointer rounded-[0.625rem] border-0 text-xl backdrop-blur-sm transition-colors max-lg:block hidden "><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2" aria-hidden="true"><path d="M4 5h16"></path><path d="M4 12h16"></path><path d="M4 19h16"></path></svg></button><footer class="pt-6 pb-2.5 text-center text-[10px] text-text-secondary "><nav><a href="https://github.com/sansui233" class="inline-block mx-2 hover:text-accent-hover transition-colors duration-200" target="_blank" rel="noopener noreferrer" aria-label="Github"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github w-6 h-6" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="mailto:sansuilnm@gmail.com" class="inline-block mx-2 hover:text-accent-hover transition-colors duration-200" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail w-6 h-6" aria-hidden="true"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"></path><rect x="2" y="4" width="20" height="16" rx="2"></rect></svg></a><a href="/rss" class="inline-block mx-2 hover:text-accent-hover transition-colors duration-200" aria-label="RSS"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-rss w-6 h-6" aria-hidden="true"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a></nav><div class="my-6 mx-auto tracking-[0.2px]">© Sansui 2026<!-- --> <br/> <!-- -->All rights reserved</div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", null)</script><script>window.__reactRouterContext = {"basename":"/","future":{"unstable_optimizeDeps":false,"unstable_subResourceIntegrity":false,"v8_middleware":false,"v8_splitRouteModules":false,"v8_viteEnvironmentApi":false},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-d60f763c.js";
import * as route0 from "/assets/root-BTnctABI.js";
import * as route1 from "/assets/RootLayout-DE8aOQ2E.js";
import * as route2 from "/assets/posts._slug-Cjebqe66.js";
  
  window.__reactRouterRouteModules = {"root":route0,"components/RootLayout":route1,"routes/posts.$slug":route2};

import("/assets/entry.client-DkTTQJrl.js");</script><!--$?--><template id="B:1"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><div class="bg-bg border-ui-line-gray-2 fixed top-13.75 right-0 z-11 m-[0_10px] w-96 overflow-hidden rounded-xl border shadow-[0_0_12px_var(--shadow-bg)] transition-all duration-300 ease-out max-[580px]:max-h-[50%] max-[580px]:w-[96%] pointer-events-none invisible -translate-y-2.5 opacity-0 "><div class="bg-bg sticky top-0 p-4 pb-0"><input type="text" placeholder="搜索你感兴趣的内容，以空格分词" class="bg-bg text-text-primary w-full rounded-none border-none focus:outline-none focus-visible:outline-none"/></div><div class="max-h-[60vh] overflow-y-auto px-4 py-2"><div class="text-sm opacity-50"><div class="text-text-gray overflow-hidden text-sm whitespace-nowrap">输入关键词开始搜索</div></div></div></div></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_75\":-5,\"_76\":-5},\"loaderData\",{\"_3\":4},\"routes/posts.$slug\",{\"_5\":6,\"_69\":70,\"_72\":73},\"post\",{\"_7\":8,\"_9\":10,\"_11\":12,\"_13\":14,\"_15\":16,\"_17\":18,\"_23\":24,\"_25\":26,\"_27\":28,\"_29\":30,\"_57\":58,\"_60\":61,\"_62\":63,\"_67\":68},\"title\",\"理解 Rust 闭包与环境变量所有权\",\"slug\",\"rust-closure-and-ownership\",\"date\",\"2022-06-13T16:00:00.000Z\",\"description\",\"B站反查用户弹幕小记\",\"draft\",false,\"metadata\",{\"_19\":20,\"_21\":22},\"readingTime\",6,\"wordCount\",1467.5600000000002,\"excerpt\",\"本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。\\n阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。\\n什么是 Rust 的闭包\\nRust 中的闭包是一种函数。与 Rust 普通函数不同，它可以捕获函数外部的变量并使用。\\n基本语法：|参数列表| {函数体}\\nfn main() {\\r\\n    let x = 1;\\r\\n\",\"content_html\",\"\u003cp\u003e本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。\u003c/p\u003e\\n\u003cp\u003e阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。\u003c/p\u003e\\n\u003ch2\u003e什么是 Rust 的闭包\u003c/h2\u003e\\n\u003cp\u003eRust 中的闭包是\u003cstrong\u003e一种函数\u003c/strong\u003e。与 Rust 普通函数不同，它可以\u003cstrong\u003e捕获函数外部的变量并使用\u003c/strong\u003e。\u003c/p\u003e\\n\u003cp\u003e基本语法：\u003ccode\u003e|参数列表| {函数体}\u003c/code\u003e\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn main() {\\r\\n    let x = 1;\\r\\n    let sum = |y: i32| { x + y }; // 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\\r\\n    println!(\\\"{}\\\", sum(99)); // 输出 100\\r\\n\\r\\n    let sum2 = |y :i32| x + y + 1; // 也可以省略花括号\\r\\n    println!(\\\"{}\\\", sum2(99)); // 输出 101\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 \u003ccode\u003elet x = 1;\u003c/code\u003e ，为闭包外部的变量。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e像 \u003ccode\u003ex\u003c/code\u003e 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“\u003cstrong\u003e环境变量\u003c/strong\u003e”。\u003c/p\u003e\\n\u003ch2\u003e闭包中环境变量的所有权\u003c/h2\u003e\\n\u003cp\u003e有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e所有权 move（默认行为）。\u003c/li\u003e\\n\u003cli\u003e可变借用，形式为 \u003ccode\u003e\u0026#x26;mut param\u003c/code\u003e\u003c/li\u003e\\n\u003cli\u003e不可变借用 ，形式为 \u003ccode\u003e\u0026#x26;param\u003c/code\u003e\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e上述为 rust 所有权基础知识，不再赘述。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 \u003cstrong\u003e捕获当前环境变量\u003c/strong\u003e 的功能。\u003c/p\u003e\\n\u003cp\u003e\u003cstrong\u003e捕获当前环境变量\u003c/strong\u003e 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e所有权 move\u003c/li\u003e\\n\u003cli\u003e可变借用\u003c/li\u003e\\n\u003cli\u003e不可变借用\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。\u003c/p\u003e\\n\u003cp\u003e回顾上面的例子，对于环境变量 \u003ccode\u003ex\u003c/code\u003e ，首先排除了所有权 move。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003e    let x = 1;\\r\\n    let sum = |y: i32| { x + y }; // 使用了 x\\r\\n    println!(\\\"{}\\\", sum(99)); // 输出 100\\r\\n\\r\\n    let sum2 = |y :i32| x + y + 1; // 再次使用了 x\\r\\n    println!(\\\"{}\\\", sum2(99)); // 输出 101\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e说明： \u003ccode\u003ex\u003c/code\u003e 在 sum1 中使用后，还能在 sum2 中再次使用，说明 \u003ccode\u003ex\u003c/code\u003e 所有权没有 move。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e实际上，上述例子的 \u003ccode\u003ex\u003c/code\u003e 在闭包中是作为 \u003cstrong\u003e不可变借用\u003c/strong\u003e 使用的，\u003cstrong\u003e因为这个闭包实现了 \u003ccode\u003eFn\u003c/code\u003e trait\u003c/strong\u003e。\u003c/p\u003e\\n\u003ch2\u003e闭包的三种 traits\u003c/h2\u003e\\n\u003cp\u003e闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。\u003c/p\u003e\\n\u003cp\u003e三种 traits 如下（划重点，请背下来）：\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e\u003ccode\u003eFnOnce\u003c/code\u003e：表示此闭包调用时会获取环境变量所有权（\u003cstrong\u003e所有权 move\u003c/strong\u003e)。因此取名 \u003ccode\u003eFnOnce\u003c/code\u003e，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。\u003c/li\u003e\\n\u003cli\u003e\u003ccode\u003eFnMut\u003c/code\u003e ：表示此闭包调用时会对环境变量进行\u003cstrong\u003e可变借用\u003c/strong\u003e，可能会修改环境变量\u003c/li\u003e\\n\u003cli\u003e\u003ccode\u003eFn\u003c/code\u003e ： 表示此闭包调用时会对环境变量进行\u003cstrong\u003e不可变借用\u003c/strong\u003e，不会修改环境变量\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e并且，\u003cstrong\u003e一个闭包可以同时实现多个 traits\u003c/strong\u003e。比如实现了 \u003ccode\u003eFn\u003c/code\u003e 的闭包也一定实现了 \u003ccode\u003eFnOnce\u003c/code\u003e （后续解释）。\u003c/p\u003e\\n\u003cp\u003e上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：\u003c/p\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e“实现了 \u003ccode\u003eFn\u003c/code\u003e 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 \u003ccode\u003eFnOnce\u003c/code\u003e ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 \u003ccode\u003eFnOnce\u003c/code\u003e（所有权 move） ，但并没有调用 \u003ccode\u003eFnOnce\u003c/code\u003e 的 call 函数，而是调用了 \u003ccode\u003eFn\u003c/code\u003e(不可变借用) 的 call 函数。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003epub trait Fn\u0026#x3C;Args\u003e : FnMut\u0026#x3C;Args\u003e {\\r\\n    extern \\\"rust-call\\\" fn call(\u0026#x26;self, args: Args) -\u003e Self::Output;\\r\\n}\\r\\n\\r\\npub trait FnMut\u0026#x3C;Args\u003e : FnOnce\u0026#x3C;Args\u003e {\\r\\n    extern \\\"rust-call\\\" fn call_mut(\u0026#x26;mut self, args: Args) -\u003e Self::Output;\\r\\n}\\r\\n\\r\\npub trait FnOnce\u0026#x3C;Args\u003e {\\r\\n    type Output;\\r\\n\\r\\n    extern \\\"rust-call\\\" fn call_once(self, args: Args) -\u003e Self::Output;\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e分析：如果 \u003ccode\u003eFnOnce\u003c/code\u003e 的 call 函数被调用，则直接传入了 \u003ccode\u003eself\u003c/code\u003e ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 \u003ccode\u003eFn\u003c/code\u003e 的 call 函数传入的是不可变借用 \u003ccode\u003e\u0026#x26;self\u003c/code\u003e。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e并且会发现， \u003ccode\u003eFn\u003c/code\u003e 的前提是实现了 \u003ccode\u003eFnMut\u003c/code\u003e , \u003ccode\u003eFnMut\u003c/code\u003e 的前提是实现了 \u003ccode\u003eFnOnce\u003c/code\u003e 。\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e从继承关系来讲： \u003ccode\u003eFn\u003c/code\u003e 继承 \u003ccode\u003eFnMut\u003c/code\u003e 继承 \u003ccode\u003eFnOnce\u003c/code\u003e\u003c/li\u003e\\n\u003cli\u003e从访问变量的权限范围来讲： \u003ccode\u003eFn\u003c/code\u003e \u0026#x3C; \u003ccode\u003eFnMut\u003c/code\u003e \u0026#x3C; \u003ccode\u003eFnOnce\u003c/code\u003e\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003e也可以说，\u003cstrong\u003e闭包就算实现了 \u003ccode\u003eFnOnce\u003c/code\u003e 也不一定会用到所有权 move，因为可能还实现了 \u003ccode\u003eFn\u003c/code\u003e ，那么环境变量的所有权会按 \u003ccode\u003eFn\u003c/code\u003e 处理\u003c/strong\u003e。\u003c/p\u003e\\n\u003chr\u003e\\n\u003cp\u003e由于上述继承关系，如果定义一个普通函数，参数需要传入 \u003ccode\u003eFnOnce\u003c/code\u003e ，实际上也可以传入 \u003ccode\u003eFn\u003c/code\u003e 。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn fn_once\u0026#x3C;F\u003e(func: F)\\r\\nwhere\\r\\n    F: FnOnce(usize) -\u003e bool, // 传入闭包\\r\\n{\\r\\n    println!(\\\"{}\\\", func(3));\\r\\n}\\r\\n\\r\\nfn main() {\\r\\n    let x = vec![1, 2, 3];\\r\\n    let closure = |z|{z == x.len()}; // 此闭包实现了 Fn、 FnMut 和 FnOnce\\r\\n    fn_once(closure); // Fn 可传入标注为 FnOnce 的参数\\r\\n    println!(\\\"{:?}\\\", x); // x 还能用，所有权没转移\\r\\n\\r\\n    let closure2 = move |z|{z == x.len()}; //  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部\\r\\n    fn_once(closure2); // 传入 FnOnce\\r\\n    println!(\\\"{:?}\\\", x); // 报错，x 已经没了\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e说明：fn_once 需要接收 \u003ccode\u003eFnOnce\u003c/code\u003e 的闭包作为参数，但传入 \u003ccode\u003eFn\u003c/code\u003e 也是合理的，编译器也会按照 \u003ccode\u003eFn\u003c/code\u003e 的调用方式处理为不可变借用，并不会因为标注着 \u003ccode\u003eFnOnce\u003c/code\u003e 而变成所有权 move。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003ch2\u003e闭包实现三种 traits\u003c/h2\u003e\\n\u003cp\u003e上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。\u003c/p\u003e\\n\u003cp\u003e闭包实现 traits 是\u003cstrong\u003e隐式\u003c/strong\u003e的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003e实现\u003ccode\u003eFnOnce\u003c/code\u003e\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e所有的闭包都自动实现了 \u003ccode\u003eFnOnce\u003c/code\u003e 。不用特别做什么。\u003c/p\u003e\\n\u003cp\u003e但更普遍的情况是，定义闭包时会顺带实现 \u003ccode\u003eFn\u003c/code\u003e 或者 \u003ccode\u003eFnMut\u003c/code\u003e 。如果想要只实现 \u003ccode\u003eFnOnce\u003c/code\u003e，不要实现另外两个，需要用 \u003ccode\u003emove\u003c/code\u003e 。这个关键字会强制转移所有权，使闭包无法满足 \u003ccode\u003eFnMut\u003c/code\u003e 和 \u003ccode\u003eFn\u003c/code\u003e 的条件。\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e例：只实现了 \u003ccode\u003eFnOnce\u003c/code\u003e 的闭包\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn main() {\\r\\n    let x = [1,2,3];\\r\\n    \\r\\n    let closure2 = move |z|{z == x.len()}; // 只实现了 FnOnce，所有权转移\\r\\n    closure2(2);\\r\\n    \\r\\n    println!(\\\"{:?}\\\", x); // 报错，x 所有权被转移\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003col start=\\\"2\\\"\u003e\\n\u003cli\u003e实现\u003ccode\u003eFnMut\u003c/code\u003e\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e在闭包中修改外部变量，即实现了 \u003ccode\u003eFnMut\u003c/code\u003e （自然也实现了 \u003ccode\u003eFnOnce\u003c/code\u003e ），同时没有实现 \u003ccode\u003eFn\u003c/code\u003e 。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn main() {\\r\\n    let mut x = vec![1,2,3];\\r\\n\\r\\n    let mut closure = ||{x.push(4);}; // 修改了外部的 x, 实现了 FnMut， x 所有权没有转移\\r\\n    closure();\\r\\n    \\r\\n    println!(\\\"{:?}\\\", x);\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003col start=\\\"3\\\"\u003e\\n\u003cli\u003e实现\u003ccode\u003eFn\u003c/code\u003e\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e在闭包中访问外部变量，不做任何修改，即实现了 \u003ccode\u003eFn\u003c/code\u003e （自然也实现了 \u003ccode\u003eFnMut\u003c/code\u003e 和 \u003ccode\u003eFnOnce\u003c/code\u003e）。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn main() {\\r\\n    let s = String::new();\\r\\n\\r\\n    let update_string =  || println!(\\\"{}\\\",s); // 访问外部的 s, 实现了 Fn\\r\\n\\r\\n    exec(update_string);\\r\\n    exec1(update_string);\\r\\n    exec2(update_string);\\r\\n}\\r\\n\\r\\nfn exec\u0026#x3C;F: FnOnce()\u003e(f: F)  { // Fn 也可以传到 FnOnce 类型\\r\\n    f() // 调用的是 Fn，所有权不会转移\\r\\n}\\r\\n\\r\\nfn exec1\u0026#x3C;F: FnMut()\u003e(mut f: F)  { // Fn 也可以传到 FnMut 类型\\r\\n    f()\\r\\n}\\r\\n\\r\\nfn exec2\u0026#x3C;F: Fn()\u003e(f: F)  {\\r\\n    f()\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003ch2\u003e闭包自身的所有权\u003c/h2\u003e\\n\u003cp\u003e上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？\u003c/p\u003e\\n\u003cp\u003e答案是，\u003ccode\u003eFn\u003c/code\u003e 是 Copy，\u003ccode\u003eFnMut\u003c/code\u003e 和 \u003ccode\u003eFnOnce\u003c/code\u003e 是所有权 Move。\u003c/p\u003e\\n\u003cpre\u003e\u003ccode class=\\\"language-rust\\\"\u003efn main() {\\r\\n    let x = vec![1,2,3];\\r\\n\\r\\n    let closure = |z:usize|{ z == x.len()}; // 实现了 Fn\\r\\n    outter(closure); // 通过\\r\\n    outter(closure); // 通过\\r\\n\\r\\n    let closure2 = |z:usize|{ x.push(4);z == x.len()}; // 实现了 FnMut\\r\\n    outter(closure2); // 通过\\r\\n    outter(closure2); // 报错, closure2 的所有权已被转移\\r\\n}\\r\\n\\r\\nfn outter\u0026#x3C;T\u003e(mut func: T)\\r\\nwhere T: FnMut(usize) -\u003e bool { // Fn 可以传到 FnMut 标注的参数上\\r\\n    let a = func;\\r\\n}\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003e这是非常合理的，对应着 Rust 借用的规则\u003c/p\u003e\\n\u003cblockquote\u003e\\n\u003cp\u003e在同一时间点，对于同一个变量，\u003cstrong\u003e要么\u003c/strong\u003e只能有一个可变借用(FnMut)，\u003cstrong\u003e要么\u003c/strong\u003e只能有\u003cstrong\u003e多个不可变借用\u003c/strong\u003e(Fn)。\u003c/p\u003e\\n\u003c/blockquote\u003e\\n\u003cp\u003e至于 \u003ccode\u003eFnOnce\u003c/code\u003e，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。\u003c/p\u003e\\n\u003ch2\u003e一些建议\u003c/h2\u003e\\n\u003cp\u003e如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。\u003c/p\u003e\\n\u003cp\u003e另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。\u003c/p\u003e\\n\u003cp\u003e如果仍然难懂，可评论提出，后续改进。\u003c/p\u003e\",\"content_jsx\",\"const{Fragment:n,jsx:e,jsxs:l}=arguments[0];function _createMdxContent(s){const c={blockquote:\\\"blockquote\\\",code:\\\"code\\\",h2:\\\"h2\\\",hr:\\\"hr\\\",li:\\\"li\\\",ol:\\\"ol\\\",p:\\\"p\\\",pre:\\\"pre\\\",span:\\\"span\\\",strong:\\\"strong\\\",ul:\\\"ul\\\",...s.components};return l(n,{children:[e(c.p,{children:\\\"本文将以（自认为）最简单易懂的方式讲述 Rust 中的闭包与环境变量所有权的关系。在现存的类似中文教程中，要么语言表述歧义太大，逻辑上难以理清；要么试图把事情总结得过于复杂。实际上闭包对于环境变量所有权的处理规则是非常简单的。\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"阅读本文需要的基础： Rust 变量的所有权、引用与借用、函数、traits。\\\"}),\\\"\\\\n\\\",e(c.h2,{id:\\\"什么是-rust-的闭包\\\",children:\\\"什么是 Rust 的闭包\\\"}),\\\"\\\\n\\\",l(c.p,{children:[\\\"Rust 中的闭包是\\\",e(c.strong,{children:\\\"一种函数\\\"}),\\\"。与 Rust 普通函数不同，它可以\\\",e(c.strong,{children:\\\"捕获函数外部的变量并使用\\\"}),\\\"。\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"基本语法：\\\",e(c.code,{children:\\\"|参数列表| {函数体}\\\"})]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\";\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"sum\\\"}),\\\" = |y: \\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"i32\\\"}),\\\"| { x + y }; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 说明： 闭包 sum 接收一个参数 y，且捕获前面的 x = 1, 返回 x + y\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\", \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"sum\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"99\\\"}),\\\")); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 输出 100\\\"}),\\\"\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"sum2\\\"}),\\\" = |y :\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"i32\\\"}),\\\"| x + y + \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\"; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 也可以省略花括号\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\", \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"sum2\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"99\\\"}),\\\")); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 输出 101\\\"}),\\\"\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"说明： 闭包 sum 接收一个参数 y，返回 x + y。其中 x 是第一行定义的 \\\",e(c.code,{children:\\\"let x = 1;\\\"}),\\\" ，为闭包外部的变量。\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"像 \\\",e(c.code,{children:\\\"x\\\"}),\\\" 这样在定义在闭包外部、可被闭包直接访问的变量，我们称为“\\\",e(c.strong,{children:\\\"环境变量\\\"}),\\\"”。\\\"]}),\\\"\\\\n\\\",e(c.h2,{id:\\\"闭包中环境变量的所有权\\\",children:\\\"闭包中环境变量的所有权\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"有 rust 基础的人应该知道，普通的 rust 函数的传入参数有三种形式\\\"}),\\\"\\\\n\\\",l(c.ol,{children:[\\\"\\\\n\\\",e(c.li,{children:\\\"所有权 move（默认行为）。\\\"}),\\\"\\\\n\\\",l(c.li,{children:[\\\"可变借用，形式为 \\\",e(c.code,{children:\\\"\u0026mut param\\\"})]}),\\\"\\\\n\\\",l(c.li,{children:[\\\"不可变借用 ，形式为 \\\",e(c.code,{children:\\\"\u0026param\\\"})]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",e(c.p,{children:\\\"上述为 rust 所有权基础知识，不再赘述。\\\"}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"普通的 rust 函数可以使用参数，但无法使用环境变量。闭包则加上了 \\\",e(c.strong,{children:\\\"捕获当前环境变量\\\"}),\\\" 的功能。\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[e(c.strong,{children:\\\"捕获当前环境变量\\\"}),\\\" 仅仅是指闭包 “知道有哪些环境变量”。闭包在使用环境变量时，依然可能会对环境变量执行三种操作：\\\"]}),\\\"\\\\n\\\",l(c.ol,{children:[\\\"\\\\n\\\",e(c.li,{children:\\\"所有权 move\\\"}),\\\"\\\\n\\\",e(c.li,{children:\\\"可变借用\\\"}),\\\"\\\\n\\\",e(c.li,{children:\\\"不可变借用\\\"}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",e(c.p,{children:\\\"具体是执行了哪种操作呢？这个问题就比较复杂了，我们可以从上面的例子出发。\\\"}),\\\"\\\\n\\\",l(c.p,{children:[\\\"回顾上面的例子，对于环境变量 \\\",e(c.code,{children:\\\"x\\\"}),\\\" ，首先排除了所有权 move。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[\\\"    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\";\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"sum\\\"}),\\\" = |y: \\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"i32\\\"}),\\\"| { x + y }; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 使用了 x\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\", \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"sum\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"99\\\"}),\\\")); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 输出 100\\\"}),\\\"\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"sum2\\\"}),\\\" = |y :\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"i32\\\"}),\\\"| x + y + \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\"; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 再次使用了 x\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\", \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"sum2\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"99\\\"}),\\\")); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 输出 101\\\"}),\\\"\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"说明： \\\",e(c.code,{children:\\\"x\\\"}),\\\" 在 sum1 中使用后，还能在 sum2 中再次使用，说明 \\\",e(c.code,{children:\\\"x\\\"}),\\\" 所有权没有 move。\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"实际上，上述例子的 \\\",e(c.code,{children:\\\"x\\\"}),\\\" 在闭包中是作为 \\\",e(c.strong,{children:\\\"不可变借用\\\"}),\\\" 使用的，\\\",l(c.strong,{children:[\\\"因为这个闭包实现了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" trait\\\"]}),\\\"。\\\"]}),\\\"\\\\n\\\",e(c.h2,{id:\\\"闭包的三种-traits\\\",children:\\\"闭包的三种 traits\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"闭包是一种函数，它的三种 traits 恰好对应了三种处理所有权的方式。\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"三种 traits 如下（划重点，请背下来）：\\\"}),\\\"\\\\n\\\",l(c.ol,{children:[\\\"\\\\n\\\",l(c.li,{children:[e(c.code,{children:\\\"FnOnce\\\"}),\\\"：表示此闭包调用时会获取环境变量所有权（\\\",e(c.strong,{children:\\\"所有权 move\\\"}),\\\")。因此取名 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\"，表示此闭包只能执行一次，因为再次执行时，环境变量可能由于之前所有权 move 过，已经没法用了。\\\"]}),\\\"\\\\n\\\",l(c.li,{children:[e(c.code,{children:\\\"FnMut\\\"}),\\\" ：表示此闭包调用时会对环境变量进行\\\",e(c.strong,{children:\\\"可变借用\\\"}),\\\"，可能会修改环境变量\\\"]}),\\\"\\\\n\\\",l(c.li,{children:[e(c.code,{children:\\\"Fn\\\"}),\\\" ： 表示此闭包调用时会对环境变量进行\\\",e(c.strong,{children:\\\"不可变借用\\\"}),\\\"，不会修改环境变量\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"并且，\\\",e(c.strong,{children:\\\"一个闭包可以同时实现多个 traits\\\"}),\\\"。比如实现了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的闭包也一定实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" （后续解释）。\\\"]}),\\\"\\\\n\\\",e(c.p,{children:\\\"上面是从“对环境变量如何处理所有权” 来解释三个 traits，大部分教程也是这么写，但个人并不推荐完全按这样去理解。因为上述表述中，三个 traits 看起来是互不重叠的（实际并非如此），导致可能会出现这样的疑问：\\\"}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"“实现了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的闭包说是对环境变量进行了不可变借用，那怎么还能同时实现 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" ，去获取环境变量的所有权呢？到底是仅仅进行不可变借用，还是获取了所有权呢？”\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"但是看三个 traits 的源代码，可以直接回答上述问题：是不可变借用。虽然确实也实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\"（所有权 move） ，但并没有调用 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 的 call 函数，而是调用了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\"(不可变借用) 的 call 函数。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"pub\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"trait\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title class_\\\",children:\\\"Fn\\\"}),\\\"\u003cArgs\u003e : \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"FnMut\\\"}),\\\"\u003cArgs\u003e {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"extern\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"rust-call\\\"'}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"call\\\"}),\\\"(\u0026\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"self\\\"}),\\\", args: Args) \\\",e(c.span,{className:\\\"hljs-punctuation\\\",children:\\\"-\u003e\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"Self\\\"}),\\\"::Output;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"pub\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"trait\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title class_\\\",children:\\\"FnMut\\\"}),\\\"\u003cArgs\u003e : \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"FnOnce\\\"}),\\\"\u003cArgs\u003e {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"extern\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"rust-call\\\"'}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"call_mut\\\"}),\\\"(\u0026\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"mut\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"self\\\"}),\\\", args: Args) \\\",e(c.span,{className:\\\"hljs-punctuation\\\",children:\\\"-\u003e\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"Self\\\"}),\\\"::Output;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"pub\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"trait\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title class_\\\",children:\\\"FnOnce\\\"}),\\\"\u003cArgs\u003e {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"type\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title class_\\\",children:\\\"Output\\\"}),\\\";\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"extern\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"rust-call\\\"'}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"call_once\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"self\\\"}),\\\", args: Args) \\\",e(c.span,{className:\\\"hljs-punctuation\\\",children:\\\"-\u003e\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"Self\\\"}),\\\"::Output;\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"分析：如果 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 的 call 函数被调用，则直接传入了 \\\",e(c.code,{children:\\\"self\\\"}),\\\" ，也就是获取了当前的环境变量的所有权，自然运行一次后回被销毁。而 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的 call 函数传入的是不可变借用 \\\",e(c.code,{children:\\\"\u0026self\\\"}),\\\"。\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"并且会发现， \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的前提是实现了 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" , \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 的前提是实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 。\\\"]}),\\\"\\\\n\\\",l(c.ul,{children:[\\\"\\\\n\\\",l(c.li,{children:[\\\"从继承关系来讲： \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 继承 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 继承 \\\",e(c.code,{children:\\\"FnOnce\\\"})]}),\\\"\\\\n\\\",l(c.li,{children:[\\\"从访问变量的权限范围来讲： \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" \u003c \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" \u003c \\\",e(c.code,{children:\\\"FnOnce\\\"})]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"也可以说，\\\",l(c.strong,{children:[\\\"闭包就算实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 也不一定会用到所有权 move，因为可能还实现了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" ，那么环境变量的所有权会按 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 处理\\\"]}),\\\"。\\\"]}),\\\"\\\\n\\\",e(c.hr,{}),\\\"\\\\n\\\",l(c.p,{children:[\\\"由于上述继承关系，如果定义一个普通函数，参数需要传入 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" ，实际上也可以传入 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"fn_once\\\"}),\\\"\u003cF\u003e(func: F)\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"where\\\"}),\\\"\\\\r\\\\n    F: \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"FnOnce\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"usize\\\"}),\\\") \\\",e(c.span,{className:\\\"hljs-punctuation\\\",children:\\\"-\u003e\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"bool\\\"}),\\\", \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 传入闭包\\\"}),\\\"\\\\r\\\\n{\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\", \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"func\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"3\\\"}),\\\"));\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"vec!\\\"}),\\\"[\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\", \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"2\\\"}),\\\", \\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"3\\\"}),\\\"];\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure\\\"}),\\\" = |z|{z == x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"len\\\"}),\\\"()}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 此闭包实现了 Fn、 FnMut 和 FnOnce\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"fn_once\\\"}),\\\"(closure); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// Fn 可传入标注为 FnOnce 的参数\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{:?}\\\"'}),\\\", x); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// x 还能用，所有权没转移\\\"}),\\\"\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure2\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"move\\\"}),\\\" |z|{z == x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"len\\\"}),\\\"()}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"//  此闭包只实现了 FnOnce，因为 x 被强制转移所有权到闭包内部\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"fn_once\\\"}),\\\"(closure2); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 传入 FnOnce\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{:?}\\\"'}),\\\", x); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 报错，x 已经没了\\\"}),\\\"\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"说明：fn_once 需要接收 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 的闭包作为参数，但传入 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 也是合理的，编译器也会按照 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的调用方式处理为不可变借用，并不会因为标注着 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 而变成所有权 move。\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",e(c.p,{children:\\\"闭包对所有权的处理并不会随着标注改变，标注仅仅是为了取悦编译器 ——鲁迅\\\"}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",e(c.h2,{id:\\\"闭包实现三种-traits\\\",children:\\\"闭包实现三种 traits\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"上述例子中，直接标注了闭包实现了三种 traits，但并没有具体说明为什么这么写就是实现了三种 traits。这是本节需要说明的内容。\\\"}),\\\"\\\\n\\\",l(c.p,{children:[\\\"闭包实现 traits 是\\\",e(c.strong,{children:\\\"隐式\\\"}),\\\"的。也就是说，你不用（也没法）标注这个闭包是实现的哪个 traits。具体实现了哪些 traits 是根据你的闭包写法决定的。\\\"]}),\\\"\\\\n\\\",l(c.ol,{children:[\\\"\\\\n\\\",l(c.li,{children:[\\\"实现\\\",e(c.code,{children:\\\"FnOnce\\\"})]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"所有的闭包都自动实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 。不用特别做什么。\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"但更普遍的情况是，定义闭包时会顺带实现 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 或者 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 。如果想要只实现 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\"，不要实现另外两个，需要用 \\\",e(c.code,{children:\\\"move\\\"}),\\\" 。这个关键字会强制转移所有权，使闭包无法满足 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 和 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 的条件。\\\"]}),\\\"\\\\n\\\",l(c.ul,{children:[\\\"\\\\n\\\",l(c.li,{children:[\\\"例：只实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 的闭包\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = [\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"2\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"3\\\"}),\\\"];\\\\r\\\\n    \\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure2\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"move\\\"}),\\\" |z|{z == x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"len\\\"}),\\\"()}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 只实现了 FnOnce，所有权转移\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"closure2\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"2\\\"}),\\\");\\\\r\\\\n    \\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{:?}\\\"'}),\\\", x); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 报错，x 所有权被转移\\\"}),\\\"\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.ol,{start:\\\"2\\\",children:[\\\"\\\\n\\\",l(c.li,{children:[\\\"实现\\\",e(c.code,{children:\\\"FnMut\\\"})]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"在闭包中修改外部变量，即实现了 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" （自然也实现了 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" ），同时没有实现 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"mut \\\"}),e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"vec!\\\"}),\\\"[\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"2\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"3\\\"}),\\\"];\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"mut \\\"}),e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure\\\"}),\\\" = ||{x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"push\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"4\\\"}),\\\");}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 修改了外部的 x, 实现了 FnMut， x 所有权没有转移\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"closure\\\"}),\\\"();\\\\r\\\\n    \\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{:?}\\\"'}),\\\", x);\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",l(c.ol,{start:\\\"3\\\",children:[\\\"\\\\n\\\",l(c.li,{children:[\\\"实现\\\",e(c.code,{children:\\\"Fn\\\"})]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"在闭包中访问外部变量，不做任何修改，即实现了 \\\",e(c.code,{children:\\\"Fn\\\"}),\\\" （自然也实现了 \\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 和 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\"）。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"s\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"String\\\"}),\\\"::\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"new\\\"}),\\\"();\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"update_string\\\"}),\\\" =  || \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"println!\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-string\\\",children:'\\\"{}\\\"'}),\\\",s); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 访问外部的 s, 实现了 Fn\\\"}),\\\"\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"exec\\\"}),\\\"(update_string);\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"exec1\\\"}),\\\"(update_string);\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"exec2\\\"}),\\\"(update_string);\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"exec\\\"}),\\\"\u003cF: \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"FnOnce\\\"}),\\\"()\u003e(f: F)  { \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// Fn 也可以传到 FnOnce 类型\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"f\\\"}),\\\"() \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 调用的是 Fn，所有权不会转移\\\"}),\\\"\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"exec1\\\"}),\\\"\u003cF: \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"FnMut\\\"}),\\\"()\u003e(\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"mut\\\"}),\\\" f: F)  { \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// Fn 也可以传到 FnMut 类型\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"f\\\"}),\\\"()\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"exec2\\\"}),\\\"\u003cF: \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"Fn\\\"}),\\\"()\u003e(f: F)  {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"f\\\"}),\\\"()\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",e(c.h2,{id:\\\"闭包自身的所有权\\\",children:\\\"闭包自身的所有权\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"上述讨论的是闭包对于环境变量的所有权处理。那闭包自己呢？当闭包自己作为变量被传来传去时，是 Copy 还是所有权 Move？\\\"}),\\\"\\\\n\\\",l(c.p,{children:[\\\"答案是，\\\",e(c.code,{children:\\\"Fn\\\"}),\\\" 是 Copy，\\\",e(c.code,{children:\\\"FnMut\\\"}),\\\" 和 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\" 是所有权 Move。\\\"]}),\\\"\\\\n\\\",e(c.pre,{children:l(c.code,{className:\\\"hljs language-rust\\\",children:[e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"main\\\"}),\\\"() {\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"x\\\"}),\\\" = \\\",e(c.span,{className:\\\"hljs-built_in\\\",children:\\\"vec!\\\"}),\\\"[\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"1\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"2\\\"}),\\\",\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"3\\\"}),\\\"];\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure\\\"}),\\\" = |z:\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"usize\\\"}),\\\"|{ z == x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"len\\\"}),\\\"()}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 实现了 Fn\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"outter\\\"}),\\\"(closure); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 通过\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"outter\\\"}),\\\"(closure); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 通过\\\"}),\\\"\\\\r\\\\n\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"closure2\\\"}),\\\" = |z:\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"usize\\\"}),\\\"|{ x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"push\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-number\\\",children:\\\"4\\\"}),\\\");z == x.\\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"len\\\"}),\\\"()}; \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 实现了 FnMut\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"outter\\\"}),\\\"(closure2); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 通过\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"outter\\\"}),\\\"(closure2); \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// 报错, closure2 的所有权已被转移\\\"}),\\\"\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"fn\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-title function_\\\",children:\\\"outter\\\"}),\\\"\u003cT\u003e(\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"mut\\\"}),\\\" func: T)\\\\r\\\\n\\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"where\\\"}),\\\" T: \\\",e(c.span,{className:\\\"hljs-title function_ invoke__\\\",children:\\\"FnMut\\\"}),\\\"(\\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"usize\\\"}),\\\") \\\",e(c.span,{className:\\\"hljs-punctuation\\\",children:\\\"-\u003e\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-type\\\",children:\\\"bool\\\"}),\\\" { \\\",e(c.span,{className:\\\"hljs-comment\\\",children:\\\"// Fn 可以传到 FnMut 标注的参数上\\\"}),\\\"\\\\r\\\\n    \\\",e(c.span,{className:\\\"hljs-keyword\\\",children:\\\"let\\\"}),\\\" \\\",e(c.span,{className:\\\"hljs-variable\\\",children:\\\"a\\\"}),\\\" = func;\\\\r\\\\n}\\\\n\\\"]})}),\\\"\\\\n\\\",e(c.p,{children:\\\"这是非常合理的，对应着 Rust 借用的规则\\\"}),\\\"\\\\n\\\",l(c.blockquote,{children:[\\\"\\\\n\\\",l(c.p,{children:[\\\"在同一时间点，对于同一个变量，\\\",e(c.strong,{children:\\\"要么\\\"}),\\\"只能有一个可变借用(FnMut)，\\\",e(c.strong,{children:\\\"要么\\\"}),\\\"只能有\\\",e(c.strong,{children:\\\"多个不可变借用\\\"}),\\\"(Fn)。\\\"]}),\\\"\\\\n\\\"]}),\\\"\\\\n\\\",l(c.p,{children:[\\\"至于 \\\",e(c.code,{children:\\\"FnOnce\\\"}),\\\"，对环境变量的访问权限这么大，还想 Copy？只能是所有权 move。\\\"]}),\\\"\\\\n\\\",e(c.h2,{id:\\\"一些建议\\\",children:\\\"一些建议\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"如果遇到函数的参数也是一个函数，需要标注 trait 的场景，又不知道到底应该标注哪一个 trait，建议先标注 Fn ( 权限最小的 trait)，由编译器提示后再进行修改。\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"另外，闭包的所有权部分并不推荐背书，尤其不推荐总结为正交规则。三个 traits 的区别与联系在代码层面非常简单且容易分析，总结为正交规则反而是把简单的事情复杂化，而且难记。\\\"}),\\\"\\\\n\\\",e(c.p,{children:\\\"如果仍然难懂，可评论提出，后续改进。\\\"})]})}return{default:function(n={}){const{wrapper:l}=n.components||{};return l?e(l,{...n,children:e(_createMdxContent,{...n})}):_createMdxContent(n)}};\",\"toc\",[31,37,41,45,49,53],{\"_7\":32,\"_33\":34,\"_35\":36},\"什么是 Rust 的闭包\",\"url\",\"#什么是-rust-的闭包\",\"items\",[],{\"_7\":38,\"_33\":39,\"_35\":40},\"闭包中环境变量的所有权\",\"#闭包中环境变量的所有权\",[],{\"_7\":42,\"_33\":43,\"_35\":44},\"闭包的三种 traits\",\"#闭包的三种-traits\",[],{\"_7\":46,\"_33\":47,\"_35\":48},\"闭包实现三种 traits\",\"#闭包实现三种-traits\",[],{\"_7\":50,\"_33\":51,\"_35\":52},\"闭包自身的所有权\",\"#闭包自身的所有权\",[],{\"_7\":54,\"_33\":55,\"_35\":56},\"一些建议\",\"#一些建议\",[],\"tags\",[59],\"Rust\",\"categories\",\"学习\",\"keywords\",[59,64,65,66],\"闭包\",\"Closure\",\"所有权\",\"permalink\",\"/posts/rust-closure-and-ownership\",\"prevPost\",{\"_7\":71,\"_9\":71},\"记一道题排列组合题解\",\"nextPost\",{\"_7\":74,\"_9\":74},\"PPT母版的制作与使用方法\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:2"></template><!--/$--></div><script>$RC("B:1","S:1")</script><div hidden id="S:2"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:2","S:2")</script></body></html>