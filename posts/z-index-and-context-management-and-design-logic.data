[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_85":-5,"_86":87},"post",{"_7":8,"_9":10,"_11":12,"_13":14,"_15":16,"_17":18,"_23":24,"_25":26,"_27":28,"_29":30,"_73":74,"_76":77,"_78":79,"_83":84},"title","z-index 设计与海浪模型","slug","z-index-and-context-management-and-design-logic","date","2026-01-06T18:20:00.000Z","description","z-index 只是个插件，层叠上下文才是真正的 z 轴","draft",false,"metadata",{"_19":20,"_21":22},"readingTime",4,"wordCount",1109.88,"excerpt","\n摘要：本文针对前端中多个元素层叠时 z-index 管理混乱的问题，提出一个名为海浪模型的设计模型，以构建复杂 z-index 管理的最佳实践。\n\n……好像 AI。但我是人，我纯手打的。\n基础知识 - 代码的画布\n层叠上下文是代码逻辑上的画布。一旦一个元素产生了层叠上下文，它内部的所有子元素就被包裹在这个范围里。\n层叠上下文的产生\n\n根元素：<html>\n定位 + 层级：position 为 relative / absolute 且 z-index 不是 auto。\n固定定位：position: fixed 或","content_html","<blockquote>\n<p>摘要：本文针对前端中多个元素层叠时 z-index 管理混乱的问题，提出一个名为海浪模型的设计模型，以构建复杂 z-index 管理的最佳实践。</p>\n</blockquote>\n<p>……好像 AI。但我是人，我纯手打的。</p>\n<h2>基础知识 - 代码的画布</h2>\n<p>层叠上下文是代码逻辑上的画布。一旦一个元素产生了层叠上下文，它内部的所有子元素就被包裹在这个范围里。</p>\n<p><strong>层叠上下文的产生</strong></p>\n<ul>\n<li>根元素：<code>&#x3C;html></code></li>\n<li>定位 + 层级：<code>position</code> 为 <code>relative</code> / <code>absolute</code> 且 <code>z-index</code> 不是 <code>auto</code>。</li>\n<li>固定定位：<code>position: fixed</code> 或 <code>sticky</code>。</li>\n<li>CSS3 属性：\n<ul>\n<li>opacity 小于 1。</li>\n<li>transform 不为 none（比如旋转、缩放）。</li>\n<li>filter（滤镜）、flex/grid 子元素的 z-index 等。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>❗注意：层叠上下文的产生，和层内元素关系，是两套规则，两者之间<strong>没有关系，没有关系，没有关系</strong>。因为部分规则相似，很容易给记混了。</p>\n</blockquote>\n<p><strong>层叠内元素关系</strong></p>\n<p>为了好解释，我使用 context-level 说明绝对的上下覆盖关系。</p>\n<ul>\n<li>CL-1: 背景和边框（最底层）</li>\n<li>CL-2: 定位元素（如absolute）且负 z-index</li>\n<li>CL-3: 块级元素（static 定位的普通 div 等）</li>\n<li>CL-4: 浮动元素（float）</li>\n<li>CL-5: 内联/行内块元素（文字、图片）</li>\n<li>CL-6: 定位元素（如absolute）且 z-index 没有设定为负，还有 opacity，transform 等。</li>\n<li>CL-7: 定位元素（如absolute）正 z-index（最顶层）</li>\n</ul>\n<p>z-index 在其中的作用相当于是一个算层叠关系的插件。<strong>必须和定位配套使用，否则不生效。</strong></p>\n<p>从功能上说，<strong>层叠上下文才是真正面向用户的Z轴</strong>，z-index属性只是这个 z轴的一个插件。</p>\n<h2>视觉画布</h2>\n<p>可以发现，被提升到 <strong>CL-6</strong> 的层，其规则和产生一个层叠上下文高度重合，<strong>就像产生了一个新的画布</strong>。这也是为什么说，容易把 CL-6 层等同于产生层叠上下文的层，但是不是的，<strong>CL-6 是描述自己作为子元素的层级</strong>，而“产生层叠上下文”描述的自己作为父元素的行为。</p>\n<ul>\n<li>opacity 且 z-index: 0。位于 CL-3，产生了层叠上下层文，但是其实层级很低，z-index 是无效的。</li>\n<li>CL6: relative 且 z-index: auto。位于 CL-6，产生不了层叠上下文，其子元素如果有更低的层级，可能会被盖掉。子元素有更高的层级，会盖掉别人。</li>\n<li>CL6: relative 且 z-index: 0。位于 CL-6，产生不层叠上下层文，其子元素层级和当前元素严格一致。</li>\n</ul>\n<p>理解了这一点，可以记住。在做目录头时，并不是设置了 <code>relative</code> 就万事大吉了，如果你的后面的元素也是 relative，很容易被覆盖。</p>\n<h2>Z-Index 划分</h2>\n<p>考虑到我们不可能把所有画布内元素全挤在 CL-6，全靠 DOM 关系划分层级，因此需要设计 CL-7 的层级，也就是正 index 区域。</p>\n<p>正 z-index 的画布内元素应处于同一个层叠上下文内。如果不在同一个，则按产生了新的层叠上下文设计。</p>\n<h3>基础逻辑</h3>\n<p>对于一个画布（层叠上下文）内，我设计新产生的画布设计上分100层。对应 z-index 0（CL-6）到 z-index 100。每 20 层为一个全屏大画布，比如 Modal。也就是</p>\n<ul>\n<li>0-20：画布内组件层级</li>\n<li>20、40、60、80、100：新画布层级</li>\n</ul>\n<p>那 21-39 有什么用？<strong>没有用，不要用</strong>。只是为了提醒你，这个东西是个大画布。如果把画布内组件设定到了 20 以上，你可能就不知道什么东西溢出到了 Modal。</p>\n<p>此外，如果真的想做一些在不同层级上换来换去的小组件，也可以根据模型的定义很快决定放到哪个层级，非常方便。</p>\n<h3>海浪模型</h3>\n<p>想象一个海星被 5 层海浪（大画布）冲到沙滩上，每一层海浪上有自己的生物群。</p>\n<p>大部分生物都挤在海底（0层以下）层，形成了基石。到第 0-19 层有一堆小东西争先恐后地彰显存在感，但是你又觉得不那么重要。之后的20层、40层、60层通常而言清澈透明，但一旦染色后，就会将下面的生物变得不见天日。</p>\n<p>此时你觉得这个海星，你应该看到它吗？应该放在哪一层？</p>\n<p>通常而言，层级设计遵循以下基础逻辑。</p>\n<ul>\n<li>大尺寸元素的层级低小，小尺寸元素的层级高。</li>\n<li>重要性高的层级高。</li>\n</ul>\n<p>第一条是一个视觉规律，第二条则是功能需要。</p>\n<h3>0-19 层</h3>\n<p>根据基础的逻辑，0-20 层我会如下划分。</p>\n<ul>\n<li>移动端菜单栏 -> 中偏小，重要，9</li>\n<li>浮动按钮 -> 中偏小，但不重要，5</li>\n<li>侧边栏 -> 大，但重要。你很难说和浮动按钮哪个在上面。这两个要权衡一下，给到 4。</li>\n<li>Hover tips -> 小，重要，19<br>\n如果 Hover tip 也可能本身是一个交互丰富的大画布，这时要看重要性。如果重要性与 Modal 相当，设到 20（新一层海浪）。如果只是随便看看，共享当前层的主要内容，只是覆盖一下正文，设到 0 或 1。大画布谨慎设置中间值，容易造成混乱。</li>\n<li>目录头：暂时一下冒头，给到 0（注意是 z-index:0，不能是 z-index:auto）</li>\n<li>拖拽：暂时冒一下头，给到0。</li>\n</ul>\n<p>在海浪模型里，<strong>带 9 的数字被表示为重要，而整十数表示为新的起点</strong>。</p>\n<h3>20、40、60层</h3>\n<p>几乎为 Modal 层。通常页面上只会出现一个Modal，一个20层足够使用，或者你要设置为40，60，都可以。如果你有很多层 Modal 要排序（窗口管理）。要么从 z-index 入手，要么从 DOM 结构入手。显然，别去动 DOM 结构树，靠 z-Index 足够完成窗口层级管理。</p>\n<h3>最重要的海星</h3>\n<p>这个海星如果你认为是稀世珍宝，任何时候都需要被看见，请直接设置到 999。但一旦，你认为他有可能会被覆盖，请思考他被覆盖时，是不是还是这么重要。</p>\n<p>如果不确定，参考基础逻辑：<strong>面积越小通常越重要</strong>。这不是一个我定义的规则，而是客观的视觉逻辑。面积越小，代表了信息量越密集。一个很常见的对比是：</p>\n<ul>\n<li>Hover tips（小面积）：在一个层非常非常重要。但需要被新画布覆盖</li>\n<li>消息通知：重要吗？超重要的，但是消息通知上是不是还是应该可以 Hover 一些提示？</li>\n<li>Hovered reference（大面积）：比如参考。重要吗？很重要。但是你觉得需要被消息通知、进度条覆盖吗？需要。</li>\n</ul>\n<h3>天空层（1000+）</h3>\n<p>总有些东西，你希望他们不要在海浪里浮动，而浮动在天上，不被任何东西覆盖。比如全局进度条、全局Hover、全局消息。</p>\n<p>放在天空的这点问题本身不大。最大的问题是，你觉得这个海星，应该放在海浪还是天空？<strong>不要让本该在海里的海星升天</strong>。一旦你觉得这个海星会被新逻辑的 Modal 覆盖，请让海星立刻返回 0-20 层。</p>\n<h2>为什么要思考海浪模型</h2>\n<ul>\n<li>易于复用：对于可复用的浮动组件，不管其父元素的 CL 层级，总能被安插到正确的位置。如果发现异常，那就是忘了使父元素产生层叠上下文来包裹他</li>\n<li>避免混乱，减少设计的心智负担</li>\n</ul>","content_jsx","const{Fragment:n,jsx:e,jsxs:i}=arguments[0];function _createMdxContent(l){const d={blockquote:\"blockquote\",br:\"br\",code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",p:\"p\",strong:\"strong\",ul:\"ul\",...l.components};return i(n,{children:[i(d.blockquote,{children:[\"\\n\",e(d.p,{children:\"摘要：本文针对前端中多个元素层叠时 z-index 管理混乱的问题，提出一个名为海浪模型的设计模型，以构建复杂 z-index 管理的最佳实践。\"}),\"\\n\"]}),\"\\n\",e(d.p,{children:\"……好像 AI。但我是人，我纯手打的。\"}),\"\\n\",e(d.h2,{id:\"基础知识---代码的画布\",children:\"基础知识 - 代码的画布\"}),\"\\n\",e(d.p,{children:\"层叠上下文是代码逻辑上的画布。一旦一个元素产生了层叠上下文，它内部的所有子元素就被包裹在这个范围里。\"}),\"\\n\",e(d.p,{children:e(d.strong,{children:\"层叠上下文的产生\"})}),\"\\n\",i(d.ul,{children:[\"\\n\",i(d.li,{children:[\"根元素：\",e(d.code,{children:\"<html>\"})]}),\"\\n\",i(d.li,{children:[\"定位 + 层级：\",e(d.code,{children:\"position\"}),\" 为 \",e(d.code,{children:\"relative\"}),\" / \",e(d.code,{children:\"absolute\"}),\" 且 \",e(d.code,{children:\"z-index\"}),\" 不是 \",e(d.code,{children:\"auto\"}),\"。\"]}),\"\\n\",i(d.li,{children:[\"固定定位：\",e(d.code,{children:\"position: fixed\"}),\" 或 \",e(d.code,{children:\"sticky\"}),\"。\"]}),\"\\n\",i(d.li,{children:[\"CSS3 属性：\",\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"opacity 小于 1。\"}),\"\\n\",e(d.li,{children:\"transform 不为 none（比如旋转、缩放）。\"}),\"\\n\",e(d.li,{children:\"filter（滤镜）、flex/grid 子元素的 z-index 等。\"}),\"\\n\"]}),\"\\n\"]}),\"\\n\"]}),\"\\n\",i(d.blockquote,{children:[\"\\n\",i(d.p,{children:[\"❗注意：层叠上下文的产生，和层内元素关系，是两套规则，两者之间\",e(d.strong,{children:\"没有关系，没有关系，没有关系\"}),\"。因为部分规则相似，很容易给记混了。\"]}),\"\\n\"]}),\"\\n\",e(d.p,{children:e(d.strong,{children:\"层叠内元素关系\"})}),\"\\n\",e(d.p,{children:\"为了好解释，我使用 context-level 说明绝对的上下覆盖关系。\"}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"CL-1: 背景和边框（最底层）\"}),\"\\n\",e(d.li,{children:\"CL-2: 定位元素（如absolute）且负 z-index\"}),\"\\n\",e(d.li,{children:\"CL-3: 块级元素（static 定位的普通 div 等）\"}),\"\\n\",e(d.li,{children:\"CL-4: 浮动元素（float）\"}),\"\\n\",e(d.li,{children:\"CL-5: 内联/行内块元素（文字、图片）\"}),\"\\n\",e(d.li,{children:\"CL-6: 定位元素（如absolute）且 z-index 没有设定为负，还有 opacity，transform 等。\"}),\"\\n\",e(d.li,{children:\"CL-7: 定位元素（如absolute）正 z-index（最顶层）\"}),\"\\n\"]}),\"\\n\",i(d.p,{children:[\"z-index 在其中的作用相当于是一个算层叠关系的插件。\",e(d.strong,{children:\"必须和定位配套使用，否则不生效。\"})]}),\"\\n\",i(d.p,{children:[\"从功能上说，\",e(d.strong,{children:\"层叠上下文才是真正面向用户的Z轴\"}),\"，z-index属性只是这个 z轴的一个插件。\"]}),\"\\n\",e(d.h2,{id:\"视觉画布\",children:\"视觉画布\"}),\"\\n\",i(d.p,{children:[\"可以发现，被提升到 \",e(d.strong,{children:\"CL-6\"}),\" 的层，其规则和产生一个层叠上下文高度重合，\",e(d.strong,{children:\"就像产生了一个新的画布\"}),\"。这也是为什么说，容易把 CL-6 层等同于产生层叠上下文的层，但是不是的，\",e(d.strong,{children:\"CL-6 是描述自己作为子元素的层级\"}),\"，而“产生层叠上下文”描述的自己作为父元素的行为。\"]}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"opacity 且 z-index: 0。位于 CL-3，产生了层叠上下层文，但是其实层级很低，z-index 是无效的。\"}),\"\\n\",e(d.li,{children:\"CL6: relative 且 z-index: auto。位于 CL-6，产生不了层叠上下文，其子元素如果有更低的层级，可能会被盖掉。子元素有更高的层级，会盖掉别人。\"}),\"\\n\",e(d.li,{children:\"CL6: relative 且 z-index: 0。位于 CL-6，产生不层叠上下层文，其子元素层级和当前元素严格一致。\"}),\"\\n\"]}),\"\\n\",i(d.p,{children:[\"理解了这一点，可以记住。在做目录头时，并不是设置了 \",e(d.code,{children:\"relative\"}),\" 就万事大吉了，如果你的后面的元素也是 relative，很容易被覆盖。\"]}),\"\\n\",e(d.h2,{id:\"z-index-划分\",children:\"Z-Index 划分\"}),\"\\n\",e(d.p,{children:\"考虑到我们不可能把所有画布内元素全挤在 CL-6，全靠 DOM 关系划分层级，因此需要设计 CL-7 的层级，也就是正 index 区域。\"}),\"\\n\",e(d.p,{children:\"正 z-index 的画布内元素应处于同一个层叠上下文内。如果不在同一个，则按产生了新的层叠上下文设计。\"}),\"\\n\",e(d.h3,{id:\"基础逻辑\",children:\"基础逻辑\"}),\"\\n\",e(d.p,{children:\"对于一个画布（层叠上下文）内，我设计新产生的画布设计上分100层。对应 z-index 0（CL-6）到 z-index 100。每 20 层为一个全屏大画布，比如 Modal。也就是\"}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"0-20：画布内组件层级\"}),\"\\n\",e(d.li,{children:\"20、40、60、80、100：新画布层级\"}),\"\\n\"]}),\"\\n\",i(d.p,{children:[\"那 21-39 有什么用？\",e(d.strong,{children:\"没有用，不要用\"}),\"。只是为了提醒你，这个东西是个大画布。如果把画布内组件设定到了 20 以上，你可能就不知道什么东西溢出到了 Modal。\"]}),\"\\n\",e(d.p,{children:\"此外，如果真的想做一些在不同层级上换来换去的小组件，也可以根据模型的定义很快决定放到哪个层级，非常方便。\"}),\"\\n\",e(d.h3,{id:\"海浪模型\",children:\"海浪模型\"}),\"\\n\",e(d.p,{children:\"想象一个海星被 5 层海浪（大画布）冲到沙滩上，每一层海浪上有自己的生物群。\"}),\"\\n\",e(d.p,{children:\"大部分生物都挤在海底（0层以下）层，形成了基石。到第 0-19 层有一堆小东西争先恐后地彰显存在感，但是你又觉得不那么重要。之后的20层、40层、60层通常而言清澈透明，但一旦染色后，就会将下面的生物变得不见天日。\"}),\"\\n\",e(d.p,{children:\"此时你觉得这个海星，你应该看到它吗？应该放在哪一层？\"}),\"\\n\",e(d.p,{children:\"通常而言，层级设计遵循以下基础逻辑。\"}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"大尺寸元素的层级低小，小尺寸元素的层级高。\"}),\"\\n\",e(d.li,{children:\"重要性高的层级高。\"}),\"\\n\"]}),\"\\n\",e(d.p,{children:\"第一条是一个视觉规律，第二条则是功能需要。\"}),\"\\n\",e(d.h3,{id:\"0-19-层\",children:\"0-19 层\"}),\"\\n\",e(d.p,{children:\"根据基础的逻辑，0-20 层我会如下划分。\"}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"移动端菜单栏 -> 中偏小，重要，9\"}),\"\\n\",e(d.li,{children:\"浮动按钮 -> 中偏小，但不重要，5\"}),\"\\n\",e(d.li,{children:\"侧边栏 -> 大，但重要。你很难说和浮动按钮哪个在上面。这两个要权衡一下，给到 4。\"}),\"\\n\",i(d.li,{children:[\"Hover tips -> 小，重要，19\",e(d.br,{}),\"\\n\",\"如果 Hover tip 也可能本身是一个交互丰富的大画布，这时要看重要性。如果重要性与 Modal 相当，设到 20（新一层海浪）。如果只是随便看看，共享当前层的主要内容，只是覆盖一下正文，设到 0 或 1。大画布谨慎设置中间值，容易造成混乱。\"]}),\"\\n\",e(d.li,{children:\"目录头：暂时一下冒头，给到 0（注意是 z-index:0，不能是 z-index:auto）\"}),\"\\n\",e(d.li,{children:\"拖拽：暂时冒一下头，给到0。\"}),\"\\n\"]}),\"\\n\",i(d.p,{children:[\"在海浪模型里，\",e(d.strong,{children:\"带 9 的数字被表示为重要，而整十数表示为新的起点\"}),\"。\"]}),\"\\n\",e(d.h3,{id:\"204060层\",children:\"20、40、60层\"}),\"\\n\",e(d.p,{children:\"几乎为 Modal 层。通常页面上只会出现一个Modal，一个20层足够使用，或者你要设置为40，60，都可以。如果你有很多层 Modal 要排序（窗口管理）。要么从 z-index 入手，要么从 DOM 结构入手。显然，别去动 DOM 结构树，靠 z-Index 足够完成窗口层级管理。\"}),\"\\n\",e(d.h3,{id:\"最重要的海星\",children:\"最重要的海星\"}),\"\\n\",e(d.p,{children:\"这个海星如果你认为是稀世珍宝，任何时候都需要被看见，请直接设置到 999。但一旦，你认为他有可能会被覆盖，请思考他被覆盖时，是不是还是这么重要。\"}),\"\\n\",i(d.p,{children:[\"如果不确定，参考基础逻辑：\",e(d.strong,{children:\"面积越小通常越重要\"}),\"。这不是一个我定义的规则，而是客观的视觉逻辑。面积越小，代表了信息量越密集。一个很常见的对比是：\"]}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"Hover tips（小面积）：在一个层非常非常重要。但需要被新画布覆盖\"}),\"\\n\",e(d.li,{children:\"消息通知：重要吗？超重要的，但是消息通知上是不是还是应该可以 Hover 一些提示？\"}),\"\\n\",e(d.li,{children:\"Hovered reference（大面积）：比如参考。重要吗？很重要。但是你觉得需要被消息通知、进度条覆盖吗？需要。\"}),\"\\n\"]}),\"\\n\",e(d.h3,{id:\"天空层1000\",children:\"天空层（1000+）\"}),\"\\n\",e(d.p,{children:\"总有些东西，你希望他们不要在海浪里浮动，而浮动在天上，不被任何东西覆盖。比如全局进度条、全局Hover、全局消息。\"}),\"\\n\",i(d.p,{children:[\"放在天空的这点问题本身不大。最大的问题是，你觉得这个海星，应该放在海浪还是天空？\",e(d.strong,{children:\"不要让本该在海里的海星升天\"}),\"。一旦你觉得这个海星会被新逻辑的 Modal 覆盖，请让海星立刻返回 0-20 层。\"]}),\"\\n\",e(d.h2,{id:\"为什么要思考海浪模型\",children:\"为什么要思考海浪模型\"}),\"\\n\",i(d.ul,{children:[\"\\n\",e(d.li,{children:\"易于复用：对于可复用的浮动组件，不管其父元素的 CL 层级，总能被安插到正确的位置。如果发现异常，那就是忘了使父元素产生层叠上下文来包裹他\"}),\"\\n\",e(d.li,{children:\"避免混乱，减少设计的心智负担\"}),\"\\n\"]})]})}return{default:function(n={}){const{wrapper:i}=n.components||{};return i?e(i,{...n,children:e(_createMdxContent,{...n})}):_createMdxContent(n)}};","toc",[31,37,41,69],{"_7":32,"_33":34,"_35":36},"基础知识 - 代码的画布","url","#基础知识---代码的画布","items",[],{"_7":38,"_33":39,"_35":40},"视觉画布","#视觉画布",[],{"_7":42,"_33":43,"_35":44},"Z-Index 划分","#z-index-划分",[45,49,53,57,61,65],{"_7":46,"_33":47,"_35":48},"基础逻辑","#基础逻辑",[],{"_7":50,"_33":51,"_35":52},"海浪模型","#海浪模型",[],{"_7":54,"_33":55,"_35":56},"0-19 层","#0-19-层",[],{"_7":58,"_33":59,"_35":60},"20、40、60层","#204060层",[],{"_7":62,"_33":63,"_35":64},"最重要的海星","#最重要的海星",[],{"_7":66,"_33":67,"_35":68},"天空层（1000+）","#天空层1000",[],{"_7":70,"_33":71,"_35":72},"为什么要思考海浪模型","#为什么要思考海浪模型",[],"tags",[75],"前端","categories","学习","keywords",[80,81,82],"z-index","层叠上下文","","permalink","/posts/z-index-and-context-management-and-design-logic","prevPost","nextPost",{"_7":88,"_9":89},"Better Web Typography for a Better Web 中文版","2025-12-30-Better-Web-Typography-for-a-Better-Web-Chinese-Version"]
