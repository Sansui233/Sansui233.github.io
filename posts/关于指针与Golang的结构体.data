[{"_1":2},"routes/posts.$slug",{"_3":4},"data",{"_5":6,"_52":53,"_55":56},"post",{"_7":8,"_9":8,"_10":11,"_12":8,"_13":14,"_15":16,"_21":22,"_23":24,"_25":26,"_27":28,"_39":40,"_42":43,"_44":45,"_50":51},"title","关于指针与Golang的结构体","slug","date","2020-11-26T16:00:00.000Z","description","draft",false,"metadata",{"_17":18,"_19":20},"readingTime",3,"wordCount",706.88,"excerpt","之前在学C++的时候，指针的用法就困惑了很久。后来有了计算机体系结构基础后，再加上Golang的一些说明，就突然明白了，之前为什么不理解指针。纠结的点在哪里。\n指针的概念\n(学的语言太多语法有些混了，看个意思就好，代码是四不像并不可以运行)\n\n地址：一个变量在内存中的存储形式是 地址 + value，地址是在指内存中的地址。\n\n比如 int a = 3，意思是变量 a 在内存中有一个地址，这个地址储存的 value 为 3。\n\n指针 (pointer) ：是一种变量，它的 value 仍然是一个地址。常用*定义指针","content_html","<p>之前在学C++的时候，指针的用法就困惑了很久。后来有了计算机体系结构基础后，再加上Golang的一些说明，就突然明白了，之前为什么不理解指针。纠结的点在哪里。</p>\n<h2>指针的概念</h2>\n<p>(学的语言太多语法有些混了，看个意思就好，代码是四不像并不可以运行)</p>\n<ul>\n<li><strong>地址</strong>：一个变量在内存中的存储形式是 <strong>地址 + value</strong>，地址是在指内存中的地址。</li>\n</ul>\n<p>比如 <code>int a = 3</code>，意思是变量 a 在内存中有一个地址，<strong>这个地址储存的 value 为 3</strong>。</p>\n<ul>\n<li><strong>指针 (pointer)</strong> ：是一种变量，<strong>它的 value 仍然是一个地址</strong>。常用<code>*</code>定义指针变量。</li>\n</ul>\n<p>比如 <code>int *b = &#x26;a</code>，意思是 <strong>指针变量</strong> b 在内存中有一个地址，<strong>这个地址储存的 value 为 a 的地址</strong>。</p>\n<p>在使用变量（而不是声明或定义变量）时，<code>&#x26;</code> 为取地址符。对应的还有一个<code>*</code>为取内容符。比如</p>\n<pre><code class=\"language-c++\">int a = 3\nint *b = &#x26;a // 将 a 的地址作为 b 的 value\nprint(b) // 输出 b 的 value，结果为一个地址，等于 a 的地址(&#x26;a)\nprint(*b) //将 b 的 value 作为地址，输出地址中存的值，结果为 3\n</code></pre>\n<p>上面仅是个人的概念解释，尽量少地引入新概念。以上概念有更通俗的叫法。</p>\n<p>比如<code>int *b = &#x26;a</code>，通常会叫做“变量 b 持有 a 的引用”。个人觉得虽然直观，但对于初学者并不友好。首先，“变量 b”就没有说清楚指针变量的特殊性。然后“a 的引用”，倒是说清楚什么叫做 a 的引用啊……尤其是一些语言没有指针的概念，但引用是随处可见的（比如 Javascript 的 Object 类型）</p>\n<h2>Golang Struct 与 指针的访问</h2>\n<p>其实让我明白的只是因为<a href=\"https://tour.golang.org/moretypes/4\">Go tour</a>中的两句话：</p>\n<blockquote>\n<p>Struct fields can be accessed through a struct pointer.\n结构体字段可以使用结构体指针获取。</p>\n</blockquote>\n<blockquote>\n<p>To access the field X of a struct when we have the struct pointer p we could write <code>(*p).X</code>. However, that notation is cumbersome, so the language permits us instead to write just <code>p.X</code>, without the explicit dereference.\n结构体指针访问字段本来应该写成<code>(*p).x</code>，但是由于这么写太蠢了，所以允许直接写成<code>p.x</code>。</p>\n</blockquote>\n<p>也就是说，如果见到类似<code>T.x</code>的结构体访问，T有可能是结构体本身，也可能是指针……需要自行区分。仅此而已。</p>\n<p>而我之前一直以为 T 只能是结构体本身= =，所以对于指针一直头大……</p>\n<p>但由于存在指针这种特殊的访问方式，在结构体的组合与接口实现中会有一些想不到的情况：</p>\n<ul>\n<li>\n<p>定义了一个接口Interface，方法有Intera()，Interb()</p>\n<pre><code class=\"language-go\">type Interface interface{\n\tIntera()\n\tInterb()\n}\n</code></pre>\n</li>\n<li>\n<p>定义了一个结构体Base，用结构体指针的方式实现了Intera()</p>\n<pre><code class=\"language-go\">type Base struct {}\nfunc (b *Base) Intera() {}\n</code></pre>\n</li>\n<li>\n<p>定义了一个结构体Extend，匿名组合了Base，用正常结构体的方式实现了Interb()</p>\n<pre><code class=\"language-go\">type Extend struct {\n\tBase\n}\nfunc (e Extend) Interb() {}\n</code></pre>\n</li>\n</ul>\n<p>这个时候，请问有谁实现了Interface？</p>\n<p>答案是：<strong>Base 和 Extend 本身都没有实现 Interface</strong>。但是上述代码中完全没有出现的 *<strong>Extend（Extend的指针）实现了Interface</strong>。</p>\n<p>为什么呢？虽然 、*<strong>Extend</strong> 并没有实现第二个方法，但 <strong>Extend</strong> 实现了，所以 ***Extend **是也是可以直接访问第二个方法的（参考上面的(*p).x的解释）。</p>\n<p>而*<strong>Base</strong>实现了第一个方法（Base没有实现），而 <strong>Extend</strong> 组合了 <strong>Base</strong>。因此第一个方法可以也通过 *<strong>Extend</strong> 访问（Extend无法访问）。</p>\n<p>所以*<strong>Extend</strong>两个方法都能访问，因此实现了Interface。而 **Extend **只能访问第二个方法，因此没有实现Interface。</p>\n<p>然后日常使用 <strong>Extend</strong> 的时候，为了能使用Interface的方法，需要使用 *<strong>Extend</strong>：</p>\n<pre><code class=\"language-go\">interfacelist := make([]Interface, 0)\ninterfacelist = append(interfacelist, &#x26;Extend{}) // 因为是指针实现Interface，需要传入地址\ne = interfacelist[0]\n</code></pre>\n<p>在 goland 对 e 按下 F1 时，只会显示，这是个 Interface，不会告诉你这是 *<strong>Extend</strong>。如果不是自己从头写的代码，你可能很久都无法发现，是个指针类型实现了 Interface。你必须在层层组合中，找到是哪一层（这里是Base）让 Extend 变成了 Interface 的指针实现。</p>\n<p>对 e 的 type assertion 也应该这么写：</p>\n<pre><code class=\"language-go\">e_ptr = e.(*Extend) // 从Interface类型返回一个Extend类型的指针\ne_ptr.Base // 等于(*e_ptr).Base\n</code></pre>","content_jsx","const{Fragment:e,jsx:n,jsxs:c}=arguments[0];function _createMdxContent(l){const r={a:\"a\",blockquote:\"blockquote\",code:\"code\",h2:\"h2\",li:\"li\",p:\"p\",pre:\"pre\",span:\"span\",strong:\"strong\",ul:\"ul\",...l.components};return c(e,{children:[n(r.p,{children:\"之前在学C++的时候，指针的用法就困惑了很久。后来有了计算机体系结构基础后，再加上Golang的一些说明，就突然明白了，之前为什么不理解指针。纠结的点在哪里。\"}),\"\\n\",n(r.h2,{id:\"指针的概念\",children:\"指针的概念\"}),\"\\n\",n(r.p,{children:\"(学的语言太多语法有些混了，看个意思就好，代码是四不像并不可以运行)\"}),\"\\n\",c(r.ul,{children:[\"\\n\",c(r.li,{children:[n(r.strong,{children:\"地址\"}),\"：一个变量在内存中的存储形式是 \",n(r.strong,{children:\"地址 + value\"}),\"，地址是在指内存中的地址。\"]}),\"\\n\"]}),\"\\n\",c(r.p,{children:[\"比如 \",n(r.code,{children:\"int a = 3\"}),\"，意思是变量 a 在内存中有一个地址，\",n(r.strong,{children:\"这个地址储存的 value 为 3\"}),\"。\"]}),\"\\n\",c(r.ul,{children:[\"\\n\",c(r.li,{children:[n(r.strong,{children:\"指针 (pointer)\"}),\" ：是一种变量，\",n(r.strong,{children:\"它的 value 仍然是一个地址\"}),\"。常用\",n(r.code,{children:\"*\"}),\"定义指针变量。\"]}),\"\\n\"]}),\"\\n\",c(r.p,{children:[\"比如 \",n(r.code,{children:\"int *b = &a\"}),\"，意思是 \",n(r.strong,{children:\"指针变量\"}),\" b 在内存中有一个地址，\",n(r.strong,{children:\"这个地址储存的 value 为 a 的地址\"}),\"。\"]}),\"\\n\",c(r.p,{children:[\"在使用变量（而不是声明或定义变量）时，\",n(r.code,{children:\"&\"}),\" 为取地址符。对应的还有一个\",n(r.code,{children:\"*\"}),\"为取内容符。比如\"]}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-c++\",children:[n(r.span,{className:\"hljs-type\",children:\"int\"}),\" a = \",n(r.span,{className:\"hljs-number\",children:\"3\"}),\"\\n\",n(r.span,{className:\"hljs-type\",children:\"int\"}),\" *b = &a \",n(r.span,{className:\"hljs-comment\",children:\"// 将 a 的地址作为 b 的 value\"}),\"\\n\",n(r.span,{className:\"hljs-built_in\",children:\"print\"}),\"(b) \",n(r.span,{className:\"hljs-comment\",children:\"// 输出 b 的 value，结果为一个地址，等于 a 的地址(&a)\"}),\"\\n\",n(r.span,{className:\"hljs-built_in\",children:\"print\"}),\"(*b) \",n(r.span,{className:\"hljs-comment\",children:\"//将 b 的 value 作为地址，输出地址中存的值，结果为 3\"}),\"\\n\"]})}),\"\\n\",n(r.p,{children:\"上面仅是个人的概念解释，尽量少地引入新概念。以上概念有更通俗的叫法。\"}),\"\\n\",c(r.p,{children:[\"比如\",n(r.code,{children:\"int *b = &a\"}),\"，通常会叫做“变量 b 持有 a 的引用”。个人觉得虽然直观，但对于初学者并不友好。首先，“变量 b”就没有说清楚指针变量的特殊性。然后“a 的引用”，倒是说清楚什么叫做 a 的引用啊……尤其是一些语言没有指针的概念，但引用是随处可见的（比如 Javascript 的 Object 类型）\"]}),\"\\n\",n(r.h2,{id:\"golang-struct-与-指针的访问\",children:\"Golang Struct 与 指针的访问\"}),\"\\n\",c(r.p,{children:[\"其实让我明白的只是因为\",n(r.a,{href:\"https://tour.golang.org/moretypes/4\",children:\"Go tour\"}),\"中的两句话：\"]}),\"\\n\",c(r.blockquote,{children:[\"\\n\",n(r.p,{children:\"Struct fields can be accessed through a struct pointer.\\n结构体字段可以使用结构体指针获取。\"}),\"\\n\"]}),\"\\n\",c(r.blockquote,{children:[\"\\n\",c(r.p,{children:[\"To access the field X of a struct when we have the struct pointer p we could write \",n(r.code,{children:\"(*p).X\"}),\". However, that notation is cumbersome, so the language permits us instead to write just \",n(r.code,{children:\"p.X\"}),\", without the explicit dereference.\\n结构体指针访问字段本来应该写成\",n(r.code,{children:\"(*p).x\"}),\"，但是由于这么写太蠢了，所以允许直接写成\",n(r.code,{children:\"p.x\"}),\"。\"]}),\"\\n\"]}),\"\\n\",c(r.p,{children:[\"也就是说，如果见到类似\",n(r.code,{children:\"T.x\"}),\"的结构体访问，T有可能是结构体本身，也可能是指针……需要自行区分。仅此而已。\"]}),\"\\n\",n(r.p,{children:\"而我之前一直以为 T 只能是结构体本身= =，所以对于指针一直头大……\"}),\"\\n\",n(r.p,{children:\"但由于存在指针这种特殊的访问方式，在结构体的组合与接口实现中会有一些想不到的情况：\"}),\"\\n\",c(r.ul,{children:[\"\\n\",c(r.li,{children:[\"\\n\",n(r.p,{children:\"定义了一个接口Interface，方法有Intera()，Interb()\"}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-go\",children:[n(r.span,{className:\"hljs-keyword\",children:\"type\"}),\" Interface \",n(r.span,{className:\"hljs-keyword\",children:\"interface\"}),\"{\\n\\tIntera()\\n\\tInterb()\\n}\\n\"]})}),\"\\n\"]}),\"\\n\",c(r.li,{children:[\"\\n\",n(r.p,{children:\"定义了一个结构体Base，用结构体指针的方式实现了Intera()\"}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-go\",children:[n(r.span,{className:\"hljs-keyword\",children:\"type\"}),\" Base \",n(r.span,{className:\"hljs-keyword\",children:\"struct\"}),\" {}\\n\",c(r.span,{className:\"hljs-function\",children:[n(r.span,{className:\"hljs-keyword\",children:\"func\"}),\" \",n(r.span,{className:\"hljs-params\",children:\"(b *Base)\"})]}),\" Intera() {}\\n\"]})}),\"\\n\"]}),\"\\n\",c(r.li,{children:[\"\\n\",n(r.p,{children:\"定义了一个结构体Extend，匿名组合了Base，用正常结构体的方式实现了Interb()\"}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-go\",children:[n(r.span,{className:\"hljs-keyword\",children:\"type\"}),\" Extend \",n(r.span,{className:\"hljs-keyword\",children:\"struct\"}),\" {\\n\\tBase\\n}\\n\",c(r.span,{className:\"hljs-function\",children:[n(r.span,{className:\"hljs-keyword\",children:\"func\"}),\" \",n(r.span,{className:\"hljs-params\",children:\"(e Extend)\"})]}),\" Interb() {}\\n\"]})}),\"\\n\"]}),\"\\n\"]}),\"\\n\",n(r.p,{children:\"这个时候，请问有谁实现了Interface？\"}),\"\\n\",c(r.p,{children:[\"答案是：\",n(r.strong,{children:\"Base 和 Extend 本身都没有实现 Interface\"}),\"。但是上述代码中完全没有出现的 *\",n(r.strong,{children:\"Extend（Extend的指针）实现了Interface\"}),\"。\"]}),\"\\n\",c(r.p,{children:[\"为什么呢？虽然 、*\",n(r.strong,{children:\"Extend\"}),\" 并没有实现第二个方法，但 \",n(r.strong,{children:\"Extend\"}),\" 实现了，所以 ***Extend **是也是可以直接访问第二个方法的（参考上面的(*p).x的解释）。\"]}),\"\\n\",c(r.p,{children:[\"而*\",n(r.strong,{children:\"Base\"}),\"实现了第一个方法（Base没有实现），而 \",n(r.strong,{children:\"Extend\"}),\" 组合了 \",n(r.strong,{children:\"Base\"}),\"。因此第一个方法可以也通过 *\",n(r.strong,{children:\"Extend\"}),\" 访问（Extend无法访问）。\"]}),\"\\n\",c(r.p,{children:[\"所以*\",n(r.strong,{children:\"Extend\"}),\"两个方法都能访问，因此实现了Interface。而 **Extend **只能访问第二个方法，因此没有实现Interface。\"]}),\"\\n\",c(r.p,{children:[\"然后日常使用 \",n(r.strong,{children:\"Extend\"}),\" 的时候，为了能使用Interface的方法，需要使用 *\",n(r.strong,{children:\"Extend\"}),\"：\"]}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-go\",children:[\"interfacelist := \",n(r.span,{className:\"hljs-built_in\",children:\"make\"}),\"([]Interface, \",n(r.span,{className:\"hljs-number\",children:\"0\"}),\")\\ninterfacelist = \",n(r.span,{className:\"hljs-built_in\",children:\"append\"}),\"(interfacelist, &Extend{}) \",n(r.span,{className:\"hljs-comment\",children:\"// 因为是指针实现Interface，需要传入地址\"}),\"\\ne = interfacelist[\",n(r.span,{className:\"hljs-number\",children:\"0\"}),\"]\\n\"]})}),\"\\n\",c(r.p,{children:[\"在 goland 对 e 按下 F1 时，只会显示，这是个 Interface，不会告诉你这是 *\",n(r.strong,{children:\"Extend\"}),\"。如果不是自己从头写的代码，你可能很久都无法发现，是个指针类型实现了 Interface。你必须在层层组合中，找到是哪一层（这里是Base）让 Extend 变成了 Interface 的指针实现。\"]}),\"\\n\",n(r.p,{children:\"对 e 的 type assertion 也应该这么写：\"}),\"\\n\",n(r.pre,{children:c(r.code,{className:\"hljs language-go\",children:[\"e_ptr = e.(*Extend) \",n(r.span,{className:\"hljs-comment\",children:\"// 从Interface类型返回一个Extend类型的指针\"}),\"\\ne_ptr.Base \",n(r.span,{className:\"hljs-comment\",children:\"// 等于(*e_ptr).Base\"}),\"\\n\"]})})]})}return{default:function(e={}){const{wrapper:c}=e.components||{};return c?n(c,{...e,children:n(_createMdxContent,{...e})}):_createMdxContent(e)}};","toc",[29,35],{"_7":30,"_31":32,"_33":34},"指针的概念","url","#指针的概念","items",[],{"_7":36,"_31":37,"_33":38},"Golang Struct 与 指针的访问","#golang-struct-与-指针的访问",[],"tags",[41],"Golang","categories","学习","keywords",[46,47,48,49],"Mac","shell","自动化","脚本","permalink","/posts/关于指针与Golang的结构体","prevPost",{"_7":54,"_9":54},"看看是谁在D我","nextPost",{"_7":57,"_9":57},"Mac上如何开机与关机时自动运行Shell脚本"]
